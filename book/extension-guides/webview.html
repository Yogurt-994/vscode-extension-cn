<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Webview - VS Code 插件开发文档</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><li class="part-title">预备知识</li><li class="spacer"></li><li class="chapter-item expanded "><a href="../preknowledge/first-step.html"><strong aria-hidden="true">1.</strong> 非JS开发者的第一步</a></li><li class="chapter-item expanded "><a href="../preknowledge/variable-and-type.html"><strong aria-hidden="true">2.</strong> Typescript-变量和类型</a></li><li class="chapter-item expanded "><a href="../preknowledge/class.html"><strong aria-hidden="true">3.</strong> Typescript-类</a></li><li class="chapter-item expanded "><a href="../preknowledge/interface-and-namespace.html"><strong aria-hidden="true">4.</strong> Typescript-接口和命名空间</a></li><li class="chapter-item expanded "><a href="../preknowledge/generics.html"><strong aria-hidden="true">5.</strong> Typescript-泛型</a></li><li class="chapter-item expanded "><a href="../preknowledge/declaration-files.html"><strong aria-hidden="true">6.</strong> Typescript-声明文件</a></li><li class="chapter-item expanded affix "><li class="part-title">第一步</li><li class="spacer"></li><li class="chapter-item expanded "><a href="../get-started/your-first-extension.html"><strong aria-hidden="true">7.</strong> 你的第一个插件</a></li><li class="chapter-item expanded "><a href="../get-started/extension-anatomy.html"><strong aria-hidden="true">8.</strong> 解析插件结构</a></li><li class="chapter-item expanded "><a href="../get-started/wrapping-up.html"><strong aria-hidden="true">9.</strong> 小结</a></li><li class="chapter-item expanded affix "><li class="part-title">开发插件</li><li class="spacer"></li><li class="chapter-item expanded "><a href="../working-with-extensions/testing-extension.html"><strong aria-hidden="true">10.</strong> 测试插件</a></li><li class="chapter-item expanded "><a href="../working-with-extensions/publish-extension.html"><strong aria-hidden="true">11.</strong> 发布插件</a></li><li class="chapter-item expanded "><a href="../working-with-extensions/bundling-extension.html"><strong aria-hidden="true">12.</strong> 打包插件</a></li><li class="chapter-item expanded "><a href="../working-with-extensions/continuous-integration.html"><strong aria-hidden="true">13.</strong> 持集成</a></li><li class="chapter-item expanded affix "><li class="part-title">插件功能</li><li class="spacer"></li><li class="chapter-item expanded "><a href="../extension-capabilities/index.html"><strong aria-hidden="true">14.</strong> 概述</a></li><li class="chapter-item expanded "><a href="../extension-capabilities/common-capabilities.html"><strong aria-hidden="true">15.</strong> 常用功能</a></li><li class="chapter-item expanded "><a href="../extension-capabilities/theming.html"><strong aria-hidden="true">16.</strong> 主题</a></li><li class="chapter-item expanded "><a href="../extension-capabilities/extending-workbench.html"><strong aria-hidden="true">17.</strong> 扩展工作台</a></li><li class="chapter-item expanded affix "><li class="part-title">插件指南</li><li class="spacer"></li><li class="chapter-item expanded "><a href="../extension-guides/index.html"><strong aria-hidden="true">18.</strong> 概述</a></li><li class="chapter-item expanded "><a href="../extension-guides/command.html"><strong aria-hidden="true">19.</strong> 命令</a></li><li class="chapter-item expanded "><a href="../extension-guides/color-theme.html"><strong aria-hidden="true">20.</strong> 色彩主题</a></li><li class="chapter-item expanded "><a href="../extension-guides/file-icon-theme.html"><strong aria-hidden="true">21.</strong> 文件图标主题</a></li><li class="chapter-item expanded "><a href="../extension-guides/product-icon-theme.html"><strong aria-hidden="true">22.</strong> 产品图标主题</a></li><li class="chapter-item expanded "><a href="../extension-guides/tree-view.html"><strong aria-hidden="true">23.</strong> 树视图</a></li><li class="chapter-item expanded "><a href="../extension-guides/webview.html" class="active"><strong aria-hidden="true">24.</strong> Webview</a></li><li class="chapter-item expanded "><a href="../extension-guides/notebook.html"><strong aria-hidden="true">25.</strong> 笔记本</a></li><li class="chapter-item expanded "><a href="../extension-guides/virtual-documents.html"><strong aria-hidden="true">26.</strong> 虚拟文档</a></li><li class="chapter-item expanded "><a href="../extension-guides/task-provider.html"><strong aria-hidden="true">27.</strong> 任务</a></li><li class="chapter-item expanded "><a href="../extension-guides/scm-provider.html"><strong aria-hidden="true">28.</strong> 源控制</a></li><li class="chapter-item expanded "><a href="../extension-guides/debugger-extension.html"><strong aria-hidden="true">29.</strong> 调试器插件</a></li><li class="chapter-item expanded "><a href="../extension-guides/markdown-extension.html"><strong aria-hidden="true">30.</strong> Markdown插件</a></li><li class="chapter-item expanded "><a href="../extension-guides/custom-editors.html"><strong aria-hidden="true">31.</strong> 自定义编辑器</a></li><li class="chapter-item expanded "><a href="../extension-guides/custom-data-extension.html"><strong aria-hidden="true">32.</strong> 自定义数据插件</a></li><li class="chapter-item expanded affix "><li class="part-title">语言插件</li><li class="spacer"></li><li class="chapter-item expanded "><a href="../language-extensions/index.html"><strong aria-hidden="true">33.</strong> 概述</a></li><li class="chapter-item expanded "><a href="../language-extensions/syntax-highlight-guide.html"><strong aria-hidden="true">34.</strong> 语法高亮</a></li><li class="chapter-item expanded "><a href="../language-extensions/semantic-highlight-guide.html"><strong aria-hidden="true">35.</strong> 语义高亮</a></li><li class="chapter-item expanded "><a href="../language-extensions/snippet-guide.html"><strong aria-hidden="true">36.</strong> 代码片段</a></li><li class="chapter-item expanded "><a href="../language-extensions/language-configuration-guide.html"><strong aria-hidden="true">37.</strong> 语言配置</a></li><li class="chapter-item expanded "><a href="../language-extensions/programmatic-language-features.html"><strong aria-hidden="true">38.</strong> 程序性语言特性</a></li><li class="chapter-item expanded "><a href="../language-extensions/language-server-extension-guide.html"><strong aria-hidden="true">39.</strong> 语言服务器</a></li><li class="chapter-item expanded "><a href="../language-extensions/embedded-languages.html"><strong aria-hidden="true">40.</strong> 嵌入语言</a></li><li class="chapter-item expanded affix "><li class="part-title">进阶主题</li><li class="spacer"></li><li class="chapter-item expanded "><a href="../advanced-topics/extension-host.html"><strong aria-hidden="true">41.</strong> 插件主机</a></li><li class="chapter-item expanded "><a href="../advanced-topics/remote-extensions.html"><strong aria-hidden="true">42.</strong> 远程开发</a></li><li class="chapter-item expanded "><a href="../advanced-topics/using-proposed-api.html"><strong aria-hidden="true">43.</strong> 使用不稳定的API</a></li><li class="chapter-item expanded affix "><li class="part-title">️️参考</li><li class="spacer"></li><li class="chapter-item expanded "><a href="../references/vscode-api.html"><strong aria-hidden="true">44.</strong> VS Code API</a></li><li class="chapter-item expanded "><a href="../references/contribution-points.html"><strong aria-hidden="true">45.</strong> 发布内容配置</a></li><li class="chapter-item expanded "><a href="../references/activation-events.html"><strong aria-hidden="true">46.</strong> 激活事件</a></li><li class="chapter-item expanded "><a href="../references/extension-manifest.html"><strong aria-hidden="true">47.</strong> 插件清单</a></li><li class="chapter-item expanded "><a href="../references/commands.html"><strong aria-hidden="true">48.</strong> 命令</a></li><li class="chapter-item expanded "><a href="../references/when-clause-contexts.html"><strong aria-hidden="true">49.</strong> when 子句上下文</a></li><li class="chapter-item expanded "><a href="../references/theme-color.html"><strong aria-hidden="true">50.</strong> 主题色彩</a></li><li class="chapter-item expanded "><a href="../references/icons-in-labels.html"><strong aria-hidden="true">51.</strong> 标签中的图标</a></li><li class="chapter-item expanded "><a href="../references/document-selector.html"><strong aria-hidden="true">52.</strong> 文档选择器</a></li><li class="chapter-item expanded "><a href="../references/extension-guidelines.html"><strong aria-hidden="true">53.</strong> 插件开发准则</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">VS Code 插件开发文档</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="webview-api"><a class="header" href="#webview-api">Webview API</a></h1>
<p>webview API为开发者提供了完全自定义视图的能力，例如内置的Markdown插件使用了webview渲染Markdown预览文件。Webview也能用于构建比VS Code原生API支持构建的更加复杂的用户交互界面。</p>
<p>可以把webview看成是VS Code中的<code>iframe</code>，它可以渲染几乎全部的HTML内容，它通过消息机制和插件通信。这样的自由度令我们的webview非常强劲并将插件的潜力提升到了新的高度。</p>
<h2 id="相关链接"><a class="header" href="#相关链接">相关链接</a></h2>
<hr />
<ul>
<li><a href="https://github.com/Microsoft/vscode-extension-samples/blob/master/webview-sample/README.md">Webview 示例</a></li>
</ul>
<h3 id="使用的vs-code-api"><a class="header" href="#使用的vs-code-api">使用的VS Code API</a></h3>
<ul>
<li><a href="https://code.visualstudio.com/api/references/vscode-api#window.createWebviewPanel">window.createWebviewPanel</a></li>
<li><a href="https://code.visualstudio.com/api/references/vscode-api#window.registerWebviewPanelSerializer">window.registerWebviewPanelSerializer</a></li>
</ul>
<h2 id="我应该用webview吗"><a class="header" href="#我应该用webview吗">我应该用webview吗？</a></h2>
<hr />
<p>webview虽然很赞，但是我们应该节制地使用这个功能——比如当VS Code原生API不够用时。Webview重度依赖资源，所以它脱离插件的进程而单独运行在其他环境中。在VS Code中使用设计不良的webview会让用户抓狂。</p>
<p>在使用webview之前，请作以下考虑：</p>
<ul>
<li>这个功能真的需要VS Code来提供吗？分离成一个应用或者网站会不会更好？</li>
<li>webview是实现这个特性的最后方案吗？VS Code原生API是否能达到同样的目的呢？</li>
<li>你的webview所牺牲的高资源占用是否能换得同样的用户价值？</li>
</ul>
<p>请记住：不要因为能使用webview而滥用webview。相反，如果你有充足的理由和自信，那么本篇教程对你来说会非常有用，现在就让我们开始吧。</p>
<h2 id="webviews-api-基础"><a class="header" href="#webviews-api-基础">Webviews API 基础</a></h2>
<hr />
<p>为了解释webviewAPI，我们先构建一个简单的<strong>Cat Coding</strong>插件。这个插件会用一个webview显示猫写代码的gif。随着我们不断了解API，我们会不断地给插件添加功能，包括我们的猫写了多少行代码的计数跟踪器，如果猫猫写出了bug还会有一个提示弹出框。</p>
<p>这是<strong>Cat Coding</strong>插件的第一版<code>package.json</code>，你可以在<a href="https://github.com/Microsoft/vscode-extension-samples/blob/master/webview-sample/README.md">这里</a>找到完整的代码。我们的第一版插件<a href="/extensibility-reference/contribution-points#contributescommands">提供了一个命令</a>，叫做<code>catCoding.start</code>。当用户从<strong>命令面板</strong>调用<em>Cat Coding: Start new cat coding session</em>，或者一个创建好的<em>键绑定</em>命令，我们的猫猫会出现在webview窗口内。</p>
<pre><code class="language-json">{
  &quot;name&quot;: &quot;cat-coding&quot;,
  &quot;description&quot;: &quot;Cat Coding&quot;,
  &quot;version&quot;: &quot;0.0.1&quot;,
  &quot;publisher&quot;: &quot;bierner&quot;,
  &quot;engines&quot;: {
    &quot;vscode&quot;: &quot;^1.23.0&quot;
  },
  &quot;activationEvents&quot;: [&quot;onCommand:catCoding.start&quot;],
  &quot;main&quot;: &quot;./out/src/extension&quot;,
  &quot;contributes&quot;: {
    &quot;commands&quot;: [
      {
        &quot;command&quot;: &quot;catCoding.start&quot;,
        &quot;title&quot;: &quot;Start new cat coding session&quot;,
        &quot;category&quot;: &quot;Cat Coding&quot;
      }
    ]
  },
  &quot;scripts&quot;: {
    &quot;vscode:prepublish&quot;: &quot;tsc -p ./&quot;,
    &quot;compile&quot;: &quot;tsc -watch -p ./&quot;,
    &quot;postinstall&quot;: &quot;node ./node_modules/vscode/bin/install&quot;
  },
  &quot;dependencies&quot;: {
    &quot;vscode&quot;: &quot;*&quot;
  },
  &quot;devDependencies&quot;: {
    &quot;@types/node&quot;: &quot;^9.4.6&quot;,
    &quot;typescript&quot;: &quot;^2.8.3&quot;
  }
}
</code></pre>
<p>现在让我们实现<code>catCoding.start</code>命令，在我们的主文件中，像下面这样注册一个基础的webview：</p>
<pre><code class="language-typescript">import * as vscode from 'vscode';

export function activate(context: vscode.ExtensionContext) {
  context.subscriptions.push(
    vscode.commands.registerCommand('catCoding.start', () =&gt; {
      // 创建并显示新的webview
      const panel = vscode.window.createWebviewPanel(
        'catCoding', // 只供内部使用，这个webview的标识
        'Cat Coding', // 给用户显示的面板标题
        vscode.ViewColumn.One, // 给新的webview面板一个编辑器视图
        {} // Webview选项。我们稍后会用上
      );
    })
  );
}
</code></pre>
<p><code>vscode.window.createWebviewPanel</code>函数创建并在编辑区展示了一个webview，下图显示了如果你试着运行<code>catCoding.start</code>命令会显示的东西：</p>
<p><img src="https://media.githubusercontent.com/media/Microsoft/vscode-docs/master/api/extension-guides/images/webview/basics-no_content.png" alt="一个空的webview" /></p>
<p>我们的命令以正确的标题打开了一个新的webview面板，但是没有任何内容！要想把我们的猫加到这个面板里面，我们需要<code>webview.html</code>设置HTML内容。</p>
<pre><code class="language-typescript">import * as vscode from 'vscode';

export function activate(context: vscode.ExtensionContext) {
  context.subscriptions.push(
    vscode.commands.registerCommand('catCoding.start', () =&gt; {
      // 创建和显示webview
      const panel = vscode.window.createWebviewPanel(
        'catCoding',
        'Cat Coding',
        vscode.ViewColumn.One,
        {}
      );

      // 设置HTML内容
      panel.webview.html = getWebviewContent();
    })
  );
}

function getWebviewContent() {
  return
    `
        &lt;!DOCTYPE html&gt;
        &lt;html lang=&quot;en&quot;&gt;
        &lt;head&gt;
            &lt;meta charset=&quot;UTF-8&quot;&gt;
            &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
            &lt;title&gt;Cat Coding&lt;/title&gt;
        &lt;/head&gt;
        &lt;body&gt;
            &lt;img src=&quot;https://media.giphy.com/media/JIX9t2j0ZTN9S/giphy.gif&quot; width=&quot;300&quot; /&gt;
        &lt;/body&gt;
        &lt;/html&gt;
    `;
}
</code></pre>
<p>如果你再次运行命令，应该能看到下图：</p>
<p><img src="https://media.githubusercontent.com/media/Microsoft/vscode-docs/master/api/extension-guides/images/webview/basics-html.png" alt="含有html内容的webview" /></p>
<p>大功告成！</p>
<p><code>webview.html</code>应该是一个完整的HTML文档。使用HTML片段或者格式错乱的HTML会造成异常。</p>
<h3 id="更新webview内容"><a class="header" href="#更新webview内容">更新webview内容</a></h3>
<p><code>webview.html</code>也能在webview创建后更新内容，让我们用猫猫轮播图使<strong>Cat Coding</strong>具有动态性：</p>
<pre><code class="language-typescript">import * as vscode from 'vscode';

const cats = {
  'Coding Cat': 'https://media.giphy.com/media/JIX9t2j0ZTN9S/giphy.gif',
  'Compiling Cat': 'https://media.giphy.com/media/mlvseq9yvZhba/giphy.gif'
};

export function activate(context: vscode.ExtensionContext) {
  context.subscriptions.push(
    vscode.commands.registerCommand('catCoding.start', () =&gt; {
      const panel = vscode.window.createWebviewPanel(
        'catCoding',
        'Cat Coding',
        vscode.ViewColumn.One,
        {}
      );

      let iteration = 0;
      const updateWebview = () =&gt; {
        const cat = iteration++ % 2 ? 'Compiling Cat' : 'Coding Cat';
        panel.title = cat;
        panel.webview.html = getWebviewContent(cat);
      };

      // 设置初始化内容
      updateWebview();

      // 每秒更新内容
      setInterval(updateWebview, 1000);
    })
  );
}

function getWebviewContent(cat: keyof typeof cats) {
  return
    `
        &lt;!DOCTYPE html&gt;
        &lt;html lang=&quot;en&quot;&gt;
        &lt;head&gt;
            &lt;meta charset=&quot;UTF-8&quot;&gt;
            &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
            &lt;title&gt;Cat Coding&lt;/title&gt;
        &lt;/head&gt;
        &lt;body&gt;
            &lt;img src=&quot;${cats[cat]}&quot; width=&quot;300&quot; /&gt;
        &lt;/body&gt;
        &lt;/html&gt;
    `;
}
</code></pre>
<p><img src="https://media.githubusercontent.com/media/Microsoft/vscode-docs/master/api/extension-guides/images/webview/basics-update.gif" alt="更新webview内容" /></p>
<p>因为<code>webview.html</code>方法替换了整个webview内容，页面看起来像重新加载了一个iframe。记住：如果你在webview中使用了脚本，那就意味着<code>webview.html</code>的重置会使脚本状态重置。</p>
<p>上述示例也使用了<code>webview.title</code>改变编辑器中的展示的文件名称，设置标题不会使webview重载。</p>
<h3 id="生命周期"><a class="header" href="#生命周期">生命周期</a></h3>
<p>webview从属于创建他们的插件，插件必须保持住从webview返回的<code>createWebviewPanel</code>。如果你的插件失去了这个关联，它就不能再访问webview了，不过即使这样，webview还会继续展示在VS Code中。</p>
<p>因为webview是一个文本编辑器视图，所以用户可以随时关闭webview。当用户关闭了webview面板后，webview就被销毁了。在我们的例子中，销毁webview时抛出了一个异常，说明我们上面的示例中使用的<code>seInterval</code>实际上产生了非常严重的Bug：如果用户关闭了面板，<code>setInterval</code>会继续触发，而且还会尝试更新<code>panel.webview.html</code>，这当然会抛出异常。喵星人可不喜欢异常，我们现在就来解决这个问题吧。</p>
<p><code>onDidDispose</code>事件在webview被销毁时触发，我们在这个事件结束之后更新并释放webview资源。</p>
<pre><code class="language-typescript">import * as vscode from 'vscode';

const cats = {
  'Coding Cat': 'https://media.giphy.com/media/JIX9t2j0ZTN9S/giphy.gif',
  'Compiling Cat': 'https://media.giphy.com/media/mlvseq9yvZhba/giphy.gif'
};

export function activate(context: vscode.ExtensionContext) {
  context.subscriptions.push(
    vscode.commands.registerCommand('catCoding.start', () =&gt; {
      const panel = vscode.window.createWebviewPanel(
        'catCoding',
        'Cat Coding',
        vscode.ViewColumn.One,
        {}
      );

      let iteration = 0;
      const updateWebview = () =&gt; {
        const cat = iteration++ % 2 ? 'Compiling Cat' : 'Coding Cat';
        panel.title = cat;
        panel.webview.html = getWebviewContent(cat);
      };

      updateWebview();
      const interval = setInterval(updateWebview, 1000);

      panel.onDidDispose(
        () =&gt; {
          // 当面板关闭时，取消webview内容之后的更新
          clearInterval(interval);
        },
        null,
        context.subscriptions
      );
    })
  );
}
</code></pre>
<p>插件也可以通过编程方式关闭webview视图——调用它们的<code>dispose()</code>方法。我们假设，现在限制我们的猫猫每天工作5秒钟：</p>
<pre><code class="language-typescript">export function activate(context: vscode.ExtensionContext) {
  context.subscriptions.push(
    vscode.commands.registerCommand('catCoding.start', () =&gt; {
      const panel = vscode.window.createWebviewPanel(
        'catCoding',
        'Cat Coding',
        vscode.ViewColumn.One,
        {}
      );

      panel.webview.html = getWebviewContent(cats['Coding Cat']);

      // 5秒后，程序性地关闭webview面板
      const timeout = setTimeout(() =&gt; panel.dispose(), 5000);

      panel.onDidDispose(
        () =&gt; {
          // 在第五秒结束之前处理用户手动的关闭动作
          clearTimeout(timeout);
        },
        null,
        context.subscriptions
      );
    })
  );
}
</code></pre>
<h3 id="移动和可见性"><a class="header" href="#移动和可见性">移动和可见性</a></h3>
<p>当webview面板被移动到了非激活标签上，它就隐藏起来了。但这时并不是销毁，当重新激活标签后，VS Code会从<code>webview.html</code>自动恢复webview的内容。</p>
<p><img src="https://media.githubusercontent.com/media/Microsoft/vscode-docs/master/api/extension-guides/images/webview/basics-restore.gif" alt="webview自动恢复内容" /></p>
<p><code>.visible</code>属性告诉你当前webview面板是否是可见的。</p>
<p>插件也可以通过调用<code>reveal()</code>方法，程序性地将webview面板激活。这个方法可以接受一个用于放置面板的目标视图布局。一个面板一次只能显示在一个编辑布局中。调用<code>reveal()</code>或者拖动webview面板到新的编辑布局中去。</p>
<p><img src="https://media.githubusercontent.com/media/Microsoft/vscode-docs/master/api/extension-guides/images/webview/basics-drag.gif" alt="在标签页中移动webview视图" /></p>
<p>现在更新我们的插件，一次只允许存在一个webview视图。如果面板处于非激活状态，那<code>catCoding.start</code>命令就把这个面板激活。</p>
<pre><code class="language-typescript">export function activate(context: vscode.ExtensionContext) {
  // 追踪当前webview面板
  let currentPanel: vscode.WebviewPanel | undefined = undefined;

  context.subscriptions.push(
    vscode.commands.registerCommand('catCoding.start', () =&gt; {
      const columnToShowIn = vscode.window.activeTextEditor
        ? vscode.window.activeTextEditor.viewColumn
        : undefined;

      if (currentPanel) {
        // 如果我们已经有了一个面板，那就把它显示到目标列布局中
        currentPanel.reveal(columnToShowIn);
      } else {
        // 不然，创建一个新面板
        currentPanel = vscode.window.createWebviewPanel(
          'catCoding',
          'Cat Coding',
          columnToShowIn,
          {}
        );
        currentPanel.webview.html = getWebviewContent(cats['Coding Cat']);

        // 当前面板被关闭后重置
        currentPanel.onDidDispose(
          () =&gt; {
            currentPanel = undefined;
          },
          null,
          context.subscriptions
        );
      }
    })
  );
}
</code></pre>
<p>下面是一个新插件的行为：</p>
<p><img src="https://media.githubusercontent.com/media/Microsoft/vscode-docs/master/api/extension-guides/images/webview/basics-single_panel.gif" alt="在单个面板中展示" /></p>
<p>不论何时，如果webview的可见性改变了，或者当webview移动到了新的视图布局中，就会触发<code>onDidChangeViewState</code>。我们的插件可以利用这个时间改变布局中的webview显示的猫：</p>
<pre><code class="language-typescript">const cats = {
  'Coding Cat': 'https://media.giphy.com/media/JIX9t2j0ZTN9S/giphy.gif',
  'Compiling Cat': 'https://media.giphy.com/media/mlvseq9yvZhba/giphy.gif',
  'Testing Cat': 'https://media.giphy.com/media/3oriO0OEd9QIDdllqo/giphy.gif'
};

export function activate(context: vscode.ExtensionContext) {
  context.subscriptions.push(
    vscode.commands.registerCommand('catCoding.start', () =&gt; {
      const panel = vscode.window.createWebviewPanel(
        'catCoding',
        'Cat Coding',
        vscode.ViewColumn.One,
        {}
      );
      panel.webview.html = getWebviewContent(cats['Coding Cat']);

      // 根据视图状态变动更新内容
      panel.onDidChangeViewState(
        e =&gt; {
          const panel = e.webviewPanel;
          switch (panel.viewColumn) {
            case vscode.ViewColumn.One:
              updateWebviewForCat(panel, 'Coding Cat');
              return;

            case vscode.ViewColumn.Two:
              updateWebviewForCat(panel, 'Compiling Cat');
              return;

            case vscode.ViewColumn.Three:
              updateWebviewForCat(panel, 'Testing Cat');
              return;
          }
        },
        null,
        context.subscriptions
      );
    })
  );
}

function updateWebviewForCat(panel: vscode.WebviewPanel, catName: keyof typeof cats) {
  panel.title = catName;
  panel.webview.html = getWebviewContent(cats[catName]);
}
</code></pre>
<p><img src="https://media.githubusercontent.com/media/Microsoft/vscode-docs/master/api/extension-guides/images/webview/basics-ondidchangeviewstate.gif" alt="响应onDidChangeViewState事件" /></p>
<h3 id="检查和调试webviews"><a class="header" href="#检查和调试webviews">检查和调试webviews</a></h3>
<p>在命令面板中输入<strong>Developer: Toggle Developer Tools</strong>能帮助你调试webview。运行命令之后会为当前可见的webview加载一个devtool：</p>
<p><img src="https://media.githubusercontent.com/media/Microsoft/vscode-docs/master/api/extension-guides/images/webview/basics-developer_tools.png" alt="Webview开发者工具" /></p>
<p>webview的内容是在webview文档中的一个iframe中的，用开发者工具检查和修改webview的DOM，在webview内调试脚本。</p>
<p>如果你用了webview开发者工具的console，确保你在Console面板左上角的下拉框里选中了当前<strong>激活窗体</strong>环境：</p>
<p><img src="https://media.githubusercontent.com/media/Microsoft/vscode-docs/master/api/extension-guides/images/webview/debug-active-frame.png" alt="选择激活窗体" /></p>
<p><strong>激活窗体</strong>环境是webview脚本执行的地方。</p>
<p>另外，<strong>Developer: Reload Webview</strong>命令会刷新所有已激活的webview。如果你需要重置一个webview的状态，这个命令会非常有用，或者你想要读取硬盘内容的webview更新一下，也可以使用这个方法。</p>
<h2 id="加载本地内容"><a class="header" href="#加载本地内容">加载本地内容</a></h2>
<hr />
<p>webview运行在独立的环境中，因此不能直接访问本地资源，这是出于安全性考虑的做法。这也意味着要想从你的插件中加载图片、样式等其他资源，或是从用户当前的工作区加载任何内容的话，你必须使用webview中的<code>vscode-resource:</code>协议。</p>
<p><code>vscode-resource:</code>协议就像<code>file:</code>协议一样，不过它只允许访问本地文件。和<code>file:</code>一样的是，<code>vscode-resource:</code>只能从绝对路径中加载资源。</p>
<p>想象一下，我们想要从本地把喵喵们的gif打包进来，而不是从Giphy（国外出名的gif收集站）里加载进来。要想做到这点，我们首先给本地文件新建一个URI，然后用<code>vscode-resource:</code>协议更新这些URI：</p>
<pre><code class="language-typescript">import * as vscode from 'vscode';
import * as path from 'path';

export function activate(context: vscode.ExtensionContext) {
  context.subscriptions.push(
    vscode.commands.registerCommand('catCoding.start', () =&gt; {
      const panel = vscode.window.createWebviewPanel(
        'catCoding',
        'Cat Coding',
        vscode.ViewColumn.One,
        {}
      );

      // 获取磁盘上的资源路径
      const onDiskPath = vscode.Uri.file(
        path.join(context.extensionPath, 'media', 'cat.gif')
      );

      // 获取在webview中使用的特殊URI
      const catGifSrc = onDiskPath.with({ scheme: 'vscode-resource' });

      panel.webview.html = getWebviewContent(catGifSrc);
    })
  );
}
</code></pre>
<p><code>catGifSrc</code>的值最后会像这样：</p>
<pre><code class="language-bash">vscode-resource:/Users/toonces/projects/vscode-cat-coding/media/cat.gif
</code></pre>
<p>默认情况下，<code>scode-resource:</code>只能访问下列地址的资源：</p>
<ul>
<li>你的插件安装的目录</li>
<li>用户当前激活的工作区</li>
</ul>
<p>你也可以用data URI将资源直接嵌套到webview中去。</p>
<h3 id="控制本地资源访问"><a class="header" href="#控制本地资源访问">控制本地资源访问</a></h3>
<p>使用<code>localResourceRoots</code>选项，webview可以控制<code>vscode-resource:</code>加载的的资源。
<code>localResourceRoots</code>定义了可能被加载的本地内容的根URI。</p>
<p>我们用<code>localResourceRoots</code>去约束<strong>Cat Coding</strong>webview只加载我们插件的<code>media</code>目录下的内容：</p>
<pre><code class="language-typescript">import * as vscode from 'vscode';
import * as path from 'path';

export function activate(context: vscode.ExtensionContext) {
  context.subscriptions.push(
    vscode.commands.registerCommand('catCoding.start', () =&gt; {
      const panel = vscode.window.createWebviewPanel(
        'catCoding',
        'Cat Coding',
        vscode.ViewColumn.One,
        {
          // 只允许webview加载我们插件的`media`目录下的资源
          localResourceRoots: [vscode.Uri.file(path.join(context.extensionPath, 'media'))]
        }
      );

      const onDiskPath = vscode.Uri.file(
        path.join(context.extensionPath, 'media', 'cat.gif')
      );
      const catGifSrc = onDiskPath.with({ scheme: 'vscode-resource' });

      panel.webview.html = getWebviewContent(catGifSrc);
    })
  );
}
</code></pre>
<p>为了禁止所有的本地资源，只要把<code>localResourceRoots</code>设为<code>[]</code>就好了。</p>
<p>通常来说，webview应该和加载本地资源一样严格，然而，<code>vscode-resource</code>和<code>localResourceRoots</code>并不保证百分百的安全性。请确保你的webview遵循<a href="/extension-guides/webview#%E5%AE%89%E5%85%A8%E6%80%A7">安全性最佳实践</a>，强烈建议考虑添加一个<a href="/extension-guides/webview#%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E7%AD%96%E7%95%A5">内容安全政策</a>以便约束之后加载的内容。</p>
<h3 id="给webview内容加上主题"><a class="header" href="#给webview内容加上主题">给webview内容加上主题</a></h3>
<p>webview可以基于当前的VS Code主题和CSS改变自身的样式。VS Code将主题分成3中类别，而且在<code>body</code>元素上加上了特殊类名以表明当前主题：</p>
<ul>
<li><code>vscode-light</code>——亮色主题</li>
<li><code>vscode-dark</code>——暗色主题</li>
<li><code>vscode-high-contrast</code>——高反差主题</li>
</ul>
<p>下列CSS改变了基于用户当前主题的webview字体颜色：</p>
<pre><code class="language-css">body.vscode-light {
  color: black;
}

body.vscode-dark {
  color: white;
}

body.vscode-high-contrast {
  color: red;
}
</code></pre>
<p>当开发一个webview应用的时候，请保证应用能在三种主题下都可以运作，务必在高反差模式下测试你的webview，以便有视觉障碍的用户也能正常使用。</p>
<p>webview可以通过<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Using_CSS_variables">CSS variables</a>访问VS Code主题，这些变量以<code>vscode</code>为前缀，并且用<code>-</code>替代了<code>.</code>，例如<code>editor.foreground</code>变成了<code>var(--vscode-editor-foreground)</code>：</p>
<pre><code class="language-css">code {
  color: var(--vscode-editor-foreground);
}
</code></pre>
<p>更多可用的主题变量，参阅<a href="/references/theme-color">主题色彩</a>。</p>
<p>下面也定义了一些与字体有关的变量：</p>
<ul>
<li><code>-vscode-editor-font-family</code> - 编辑器的文字类型(设置中的<code>editor.fontFamily</code>配置项)</li>
<li><code>-vscode-editor-font-weight</code> - 编辑器的文字粗细(设置中的<code>editor.fontWeight</code>配置项)</li>
<li><code>-vscode-editor-font-size</code> - 编辑器文字大小(设置中的<code>editor.fontSize</code>配置项)</li>
</ul>
<h2 id="脚本和信息传递"><a class="header" href="#脚本和信息传递">脚本和信息传递</a></h2>
<hr />
<p>既然webview就像iframe一样，也就是说它们也可以运行脚本，webview中的Javascript默认是禁用的，不过我们能用<code>enableScripts: true</code>打开它。</p>
<p>让我们写一段脚本，追踪我们家喵星人写代码的行数。运行一个基础脚本非常的容易，但是注意这个示例只作演示用途，在实践中，你的webview应该遵循<a href="#%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E7%AD%96%E7%95%A5">内容安全政策</a>，禁止行内脚本。</p>
<pre><code class="language-typescript">import * as path from 'path';
import * as vscode from 'vscode';

export function activate(context: vscode.ExtensionContext) {
    context.subscriptions.push(vscode.commands.registerCommand('catCoding.start', () =&gt; {
        const panel = vscode.window.createWebviewPanel('catCoding', &quot;Cat Coding&quot;, vscode.ViewColumn.One, {
            // 在webview中启用脚本
            enableScripts: true
        });

        panel.webview.html = getWebviewContent();
    }));
}

function getWebviewContent() {
    return
        `
            &lt;!DOCTYPE html&gt;
            &lt;html lang=&quot;en&quot;&gt;
            &lt;head&gt;
                &lt;meta charset=&quot;UTF-8&quot;&gt;
                &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
                &lt;title&gt;Cat Coding&lt;/title&gt;
            &lt;/head&gt;
            &lt;body&gt;
                &lt;img src=&quot;https://media.giphy.com/media/JIX9t2j0ZTN9S/giphy.gif&quot; width=&quot;300&quot; /&gt;
                &lt;h1 id=&quot;lines-of-code-counter&quot;&gt;0&lt;/h1&gt;

                &lt;script&gt;
                    const counter = document.getElementById('lines-of-code-counter');

                    let count = 0;
                    setInterval(() =&gt; {
                        counter.textContent = count++;
                    }, 100);
                &lt;/script&gt;
            &lt;/body&gt;
            &lt;/html&gt;
        `;
}
</code></pre>
<p><img src="https://media.githubusercontent.com/media/Microsoft/vscode-docs/master/api/extension-guides/images/webview/scripts-basic.gif" alt="在webview中运行脚本" /></p>
<p>哇！真是位高产的喵主子!</p>
<p>!&gt; webveiw的脚本能做到任何普通网页脚本能做到的事情，但是webview运行在自己的上下文中，脚本不能访问VS Code API。</p>
<h3 id="将插件的信息传递到webview"><a class="header" href="#将插件的信息传递到webview">将插件的信息传递到webview</a></h3>
<p>插件可以用<code>webview.postMessage()</code>将数据发送到它的webview中。这个方法能发送任何序列化的JSON数据到webview中，在webview中则通过<code>message</code>事件接受信息。</p>
<p>我们现在就来看看这个实现，在Cat Coding中新增一个命令来表示我们家的喵在重构他的代码（所以会减少代码总行数）。新增<code>catCoding.doRefactor</code>命令，利用<code>postMessage</code>把指示发送到webview中，webview中的<code>window.addEventListener('message' event =&gt; { ... })</code>则会处理这些信息：</p>
<pre><code class="language-typescript">export function activate(context: vscode.ExtensionContext) {

    // 现在只有一只喵喵程序员了
    let currentPanel: vscode.WebviewPanel | undefined = undefined;

    context.subscriptions.push(vscode.commands.registerCommand('catCoding.start', () =&gt; {
        if (currentPanel) {
            currentPanel.reveal(vscode.ViewColumn.One);
        } else {
            currentPanel = vscode.window.createWebviewPanel('catCoding', &quot;Cat Coding&quot;, vscode.ViewColumn.One, {
                enableScripts: true
            });
            currentPanel.webview.html = getWebviewContent();
            currentPanel.onDidDispose(() =&gt; { currentPanel = undefined; }, undefined, context.subscriptions);
        }
    }));

    // 我们新的命令
    context.subscriptions.push(vscode.commands.registerCommand('catCoding.doRefactor', () =&gt; {
        if (!currentPanel) {
            return;
        }

        // 把信息发送到webview
        // 你可以发送任何序列化的JSON数据
        currentPanel.webview.postMessage({ command: 'refactor' });
    }));
}

function getWebviewContent() {
    return
        `
            &lt;!DOCTYPE html&gt;
            &lt;html lang=&quot;en&quot;&gt;
            &lt;head&gt;
                &lt;meta charset=&quot;UTF-8&quot;&gt;
                &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
                &lt;title&gt;Cat Coding&lt;/title&gt;
            &lt;/head&gt;
            &lt;body&gt;
                &lt;img src=&quot;https://media.giphy.com/media/JIX9t2j0ZTN9S/giphy.gif&quot; width=&quot;300&quot; /&gt;
                &lt;h1 id=&quot;lines-of-code-counter&quot;&gt;0&lt;/h1&gt;

                &lt;script&gt;
                    const counter = document.getElementById('lines-of-code-counter');

                    let count = 0;
                    setInterval(() =&gt; {
                        counter.textContent = count++;
                    }, 100);

                    // Handle the message inside the webview
                    window.addEventListener('message', event =&gt; {

                        const message = event.data; // The JSON data our extension sent

                        switch (message.command) {
                            case 'refactor':
                                count = Math.ceil(count * 0.5);
                                counter.textContent = count;
                                break;
                        }
                    });
                &lt;/script&gt;
            &lt;/body&gt;
            &lt;/html&gt;
        `;
</code></pre>
<p><img src="https://media.githubusercontent.com/media/Microsoft/vscode-docs/master/api/extension-guides/images/webview/scripts-extension_to_webview.gif" alt="向webview传递信息" /></p>
<h3 id="将webview的信息传递到插件中"><a class="header" href="#将webview的信息传递到插件中">将webview的信息传递到插件中</a></h3>
<p>webview也可以把信息传递回对应的插件中，用VS Code API 为webview提供的<code>postMessage</code>函数我们就可以完成这个目标。调用webview中的<code>acquireVsCodeApi</code>获取VS Code API对象。这个函数在一个会话中只能调用一次，你必须保持住这个方法返回的VS Code API实例，然后再转交到需要调用这个实例的地方。</p>
<p>现在我们在<strong>Cat Coding</strong>添加一个弹出bug的警示框：</p>
<pre><code class="language-typescript">export function activate(context: vscode.ExtensionContext) {
    context.subscriptions.push(vscode.commands.registerCommand('catCoding.start', () =&gt; {
        const panel = vscode.window.createWebviewPanel('catCoding', &quot;Cat Coding&quot;, vscode.ViewColumn.One, {
            enableScripts: true
        });

        panel.webview.html = getWebviewContent();

        // 处理webview中的信息
        panel.webview.onDidReceiveMessage(message =&gt; {
            switch (message.command) {
                case 'alert':
                    vscode.window.showErrorMessage(message.text);
                    return;
            }
        }, undefined, context.subscriptions);
    }));
}

function getWebviewContent() {
    return
        `
            &lt;!DOCTYPE html&gt;
            &lt;html lang=&quot;en&quot;&gt;
            &lt;head&gt;
                &lt;meta charset=&quot;UTF-8&quot;&gt;
                &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
                &lt;title&gt;Cat Coding&lt;/title&gt;
            &lt;/head&gt;
            &lt;body&gt;
                &lt;img src=&quot;https://media.giphy.com/media/JIX9t2j0ZTN9S/giphy.gif&quot; width=&quot;300&quot; /&gt;
                &lt;h1 id=&quot;lines-of-code-counter&quot;&gt;0&lt;/h1&gt;

                &lt;script&gt;
                    (function() {
                        const vscode = acquireVsCodeApi();
                        const counter = document.getElementById('lines-of-code-counter');

                        let count = 0;
                        setInterval(() =&gt; {
                            counter.textContent = count++;

                            // Alert the extension when our cat introduces a bug
                            if (Math.random() &lt; 0.001 * count) {
                                vscode.postMessage({
                                    command: 'alert',
                                    text: '🐛  on line ' + count
                                })
                            }
                        }, 100);
                    }())
                &lt;/script&gt;
            &lt;/body&gt;
            &lt;/html&gt;
        `;
}
</code></pre>
<p><img src="https://media.githubusercontent.com/media/Microsoft/vscode-docs/master/api/extension-guides/images/webview/scripts-webview_to_extension.gif" alt="从webview向插件传递信息" /></p>
<p>出于安全性考虑，你必须保证VS Code API的私有性，也不会泄露到全局状态中去。</p>
<h2 id="安全性"><a class="header" href="#安全性">安全性</a></h2>
<hr />
<p>每一个你创建的webview都必须遵循这些基础的安全性最佳实践。</p>
<h3 id="限制能力"><a class="header" href="#限制能力">限制能力</a></h3>
<p>webview应该留有它所需的最小功能集合即可。例如：如果你的webview不需要运行脚本，就不要设置<code>enableScripts: true</code>。如果你的webview不需要加载用户工作区的资源，就把<code>localResourceRoots</code>设置为<code>[vscode.Uri.file(extensionContext.extensionPath)]</code>或者<code>[]</code>以便禁止访问任何本地资源。</p>
<h3 id="内容安全策略"><a class="header" href="#内容安全策略">内容安全策略</a></h3>
<p><a href="https://developers.google.com/web/fundamentals/security/csp/">内容安全策略</a>可以进一步限制webview可以加载和执行的内容。例如：内容安全策略强制可以运行在webview中的脚本白名单，或者告诉webview只加载带<code>https</code>协议的图片。</p>
<p>要想加上内容安全策略，将<code>&lt;meta http-equiv=&quot;Content-Security-Policy&quot;&gt;</code>指令放到webview的<code>&lt;head&gt;</code>中</p>
<pre><code class="language-typescript">function getWebviewContent() {
    return
        `
            &lt;!DOCTYPE html&gt;
            &lt;html lang=&quot;en&quot;&gt;
            &lt;head&gt;
                &lt;meta charset=&quot;UTF-8&quot;&gt;

                &lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;default-src 'none';&quot;&gt;

                &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;

                &lt;title&gt;Cat Coding&lt;/title&gt;
            &lt;/head&gt;
            &lt;body&gt;
                ...
            &lt;/body&gt;
            &lt;/html&gt;
        `;
}
</code></pre>
<p><code>default-src 'none';</code>策略直接禁止了所有内容。我们可以按插件需要的最少内容修改这个指令，如只允许通过<code>https</code>加载本地脚本、样式和图片：</p>
<pre><code class="language-html">&lt;meta
    http-equiv=&quot;Content-Security-Policy&quot;
    content=&quot;default-src 'none'; img-src vscode-resource: https:; script-src vscode-resource:; style-src vscode-resource:;&quot;
&gt;
</code></pre>
<p>上述策略也隐式地禁用了内联脚本和样式。把内联样式和脚本提取到外部文件中是一个非常好的实践，也不会与内容安全策略冲突。</p>
<h3 id="只通过https加载内容"><a class="header" href="#只通过https加载内容">只通过https加载内容</a></h3>
<p>如果你的webview允许加载外部资源，我们强烈建议你只允许通过<code>https</code>加载而不要使用http，上面的例子已经用内容安全策略展示了使用<code>https</code>的方式。</p>
<h3 id="审查用户输入"><a class="header" href="#审查用户输入">审查用户输入</a></h3>
<p>就像构建普通HTML页面一样，你也同样需要在webview中审查用户输入的内容。
没有审查输入内容可能会导致内容注入，也就意味着将用户置于了危险之中。</p>
<p>可能需要审查的值：</p>
<ul>
<li>文件内容</li>
<li>文件和文件夹路径</li>
<li>用户工作区设置</li>
</ul>
<p>可以考虑用一个辅助库去构建HTML模板，或者确保所有来自用户工作区的内容都通过了审查</p>
<p>只依赖审查内容的安全性是不够的，你也要遵循其他<a href="#%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E7%AD%96%E7%95%A5">安全性的最佳实践</a>，尽可能减少潜在的内容注入。</p>
<h2 id="持久性"><a class="header" href="#持久性">持久性</a></h2>
<hr />
<p>在webview的标准<a href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">生命周期</a>中，<code>createWebviewPanel</code>负责创建和销毁（用户关闭或者调用<code>.dispose()</code>方法）webview。而webview的内容再是在webview可见时创建的，在webview处于非激活状态时销毁。webview处于非激活标签中时，任何webview中的保留的状态都会丢失。</p>
<p>所以最好减少webview中的状态，取而代之用<a href="#%E5%B0%86webview%E7%9A%84%E4%BF%A1%E6%81%AF%E4%BC%A0%E9%80%92%E5%88%B0%E6%8F%92%E4%BB%B6%E4%B8%AD">消息传递</a>储存状态。</p>
<h3 id="getstate和setstate"><a class="header" href="#getstate和setstate">getState和setState</a></h3>
<p>运行在webview中的脚本可以使用<code>getState</code>和<code>setState</code>方法保存和恢复JSON序列化的状态对象。这个状态可以一直保留，即使webview面板已经被隐藏，只有当它销毁时，状态则会一起销毁。</p>
<pre><code class="language-typescript">// webview中的脚本
const vscode = acquireVsCodeApi();

const counter = document.getElementById('lines-of-code-counter');

// 检查是否需要恢复状态
const previousState = vscode.getState();
let count = previousState ? previousState.count : 0;
counter.textContent = count;

setInterval(() =&gt; {
    counter.textContent = count++;
    // 更新已经保存的状态
    vscode.setState({ count })
}, 100);
</code></pre>
<p><code>getState</code>和<code>setState</code>是用来保存状态的比较好的办法，因为他们的性能消耗要远低于<code>retainContextWhenHidden</code>。</p>
<h3 id="序列化"><a class="header" href="#序列化">序列化</a></h3>
<p>使用<code>WebviewPanelSerializer</code>之后，你的webview可以在VS Code关闭后自动恢复。序列化构建于<code>getState</code>和<code>setState</code>之上，只有你的插件注册了<code>WebviewPanelSerializer</code>，这个功能才会生效。</p>
<p>给插件的<code>package.json</code>添加一个<code>onWebviewPanel</code>激活事件，然后我们的代码喵就能在VS Code重启后继续工作了：</p>
<pre><code class="language-json">&quot;activationEvents&quot;: [
    ...,
    &quot;onWebviewPanel:catCoding&quot;
]
</code></pre>
<p>这个激活事件确保我们的插件不论VS Code何时恢复<code>catCoding</code>webview时都会启动。</p>
<p>然后在我们插件的<code>activate</code>方法中调用<code>registerWebviewPanelSerializer</code>注册一个新的<code>WebviewPanelSerializer</code>，这个函数负责恢复webview之前保存的内容。其中的state就是webview用<code>setState</code>设置的JSON格式的状态。</p>
<pre><code class="language-typescript">export function activate(context: vscode.ExtensionContext) {
    // 常见设置...

    // 确保我们注册了一个序列化器
    vscode.window.registerWebviewPanelSerializer('catCoding', new CatCodingSerializer());
}

class CatCodingSerializer implements vscode.WebviewPanelSerializer {
    async deserializeWebviewPanel(webviewPanel: vscode.WebviewPanel, state: any) {
        // `state`是webview内调用`setState`保留住的
        console.log(`Got state: ${state}`);

        // 恢复我们的webview内容
        //
        // 确保我们将`webviewPanel`传递到了这里
        // 然后用事件侦听器恢复我们的内容
        webviewPanel.webview.html = getWebviewContent();
    }
}
</code></pre>
<p>在VS Code中打开一个喵喵打代码的面板，关闭后重启就能看到这个面板恢复到了之前的状态和位置。</p>
<h3 id="隐藏时保留上下文"><a class="header" href="#隐藏时保留上下文">隐藏时保留上下文</a></h3>
<p>如果webview的视图非常复杂，或者状态不能很快地保存和恢复，你则可以用<code>retainContextWhenHidden</code>选项，这个选项在不可见的状态中保存了webview的内容，即使webview本身不处于激活状态。</p>
<p>虽然<strong>Cat Coding</strong>说不上有很复杂的状态，不过我们可以打开<code>retainContextWhenHidden</code>看看webview的行为会发生什么变化：</p>
<pre><code class="language-typescript">import * as vscode from 'vscode';

export function activate(context: vscode.ExtensionContext) {
  context.subscriptions.push(
    vscode.commands.registerCommand('catCoding.start', () =&gt; {
      const panel = vscode.window.createWebviewPanel(
        'catCoding',
        'Cat Coding',
        vscode.ViewColumn.One,
        {
          enableScripts: true,
          retainContextWhenHidden: true
        }
      );
      panel.webview.html = getWebviewContent();
    })
  );
}

function getWebviewContent() {
  return
    `
        &lt;!DOCTYPE html&gt;
        &lt;html lang=&quot;en&quot;&gt;
        &lt;head&gt;
            &lt;meta charset=&quot;UTF-8&quot;&gt;
            &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
            &lt;title&gt;Cat Coding&lt;/title&gt;
        &lt;/head&gt;
        &lt;body&gt;
            &lt;img src=&quot;https://media.giphy.com/media/JIX9t2j0ZTN9S/giphy.gif&quot; width=&quot;300&quot; /&gt;
            &lt;h1 id=&quot;lines-of-code-counter&quot;&gt;0&lt;/h1&gt;

            &lt;script&gt;
                const counter = document.getElementById('lines-of-code-counter');

                let count = 0;
                setInterval(() =&gt; {
                    counter.textContent = count++;
                }, 100);
            &lt;/script&gt;
        &lt;/body&gt;
        &lt;/html&gt;
    `;
}
</code></pre>
<p><img src="https://media.githubusercontent.com/media/Microsoft/vscode-docs/master/api/extension-guides/images/webview/persistence-retrain.gif" alt="持久化保留" /></p>
<p>我们可以注意到计数器没有重置，webview隐藏之后就恢复了。而且不需要多余的代码！<code>retainContextWhenHidden</code>的行为就像浏览器一样，脚本和其他内容被暂时挂起，但是一旦webview可见之后就会立即恢复。但是在webview隐藏状态下，你还是不能给它发送消息的。</p>
<p>虽然<code>retainContextWhenHidden</code>很吸引人，但是记住这个功能的内容占用很高，只有其他的持久化技术无能为力之时再选择这种方式。</p>
<h2 id="下一步"><a class="header" href="#下一步">下一步</a></h2>
<p>如果你想了解学习更多VS Code扩展性的内容，请查看下列主题：</p>
<ul>
<li><a href="/">插件API</a> - 所有的VS Code插件API</li>
<li><a href="/extension-capabilities/README">插件功能</a> - 其它拓展VS Code功能的方式</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../extension-guides/tree-view.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../extension-guides/notebook.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../extension-guides/tree-view.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../extension-guides/notebook.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
