<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>调试器插件 - VS Code 插件开发文档</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><li class="part-title">预备知识</li><li class="spacer"></li><li class="chapter-item expanded "><a href="../preknowledge/first-step.html"><strong aria-hidden="true">1.</strong> 非JS开发者的第一步</a></li><li class="chapter-item expanded "><a href="../preknowledge/variable-and-type.html"><strong aria-hidden="true">2.</strong> Typescript-变量和类型</a></li><li class="chapter-item expanded "><a href="../preknowledge/class.html"><strong aria-hidden="true">3.</strong> Typescript-类</a></li><li class="chapter-item expanded "><a href="../preknowledge/interface-and-namespace.html"><strong aria-hidden="true">4.</strong> Typescript-接口和命名空间</a></li><li class="chapter-item expanded "><a href="../preknowledge/generics.html"><strong aria-hidden="true">5.</strong> Typescript-泛型</a></li><li class="chapter-item expanded "><a href="../preknowledge/declaration-files.html"><strong aria-hidden="true">6.</strong> Typescript-声明文件</a></li><li class="chapter-item expanded affix "><li class="part-title">第一步</li><li class="spacer"></li><li class="chapter-item expanded "><a href="../get-started/your-first-extension.html"><strong aria-hidden="true">7.</strong> 你的第一个插件</a></li><li class="chapter-item expanded "><a href="../get-started/extension-anatomy.html"><strong aria-hidden="true">8.</strong> 解析插件结构</a></li><li class="chapter-item expanded "><a href="../get-started/wrapping-up.html"><strong aria-hidden="true">9.</strong> 小结</a></li><li class="chapter-item expanded affix "><li class="part-title">开发插件</li><li class="spacer"></li><li class="chapter-item expanded "><a href="../working-with-extensions/testing-extension.html"><strong aria-hidden="true">10.</strong> 测试插件</a></li><li class="chapter-item expanded "><a href="../working-with-extensions/publish-extension.html"><strong aria-hidden="true">11.</strong> 发布插件</a></li><li class="chapter-item expanded "><a href="../working-with-extensions/bundling-extension.html"><strong aria-hidden="true">12.</strong> 打包插件</a></li><li class="chapter-item expanded "><a href="../working-with-extensions/continuous-integration.html"><strong aria-hidden="true">13.</strong> 持集成</a></li><li class="chapter-item expanded affix "><li class="part-title">插件功能</li><li class="spacer"></li><li class="chapter-item expanded "><a href="../extension-capabilities/index.html"><strong aria-hidden="true">14.</strong> 概述</a></li><li class="chapter-item expanded "><a href="../extension-capabilities/common-capabilities.html"><strong aria-hidden="true">15.</strong> 常用功能</a></li><li class="chapter-item expanded "><a href="../extension-capabilities/theming.html"><strong aria-hidden="true">16.</strong> 主题</a></li><li class="chapter-item expanded "><a href="../extension-capabilities/extending-workbench.html"><strong aria-hidden="true">17.</strong> 扩展工作台</a></li><li class="chapter-item expanded affix "><li class="part-title">插件指南</li><li class="spacer"></li><li class="chapter-item expanded "><a href="../extension-guides/index.html"><strong aria-hidden="true">18.</strong> 概述</a></li><li class="chapter-item expanded "><a href="../extension-guides/command.html"><strong aria-hidden="true">19.</strong> 命令</a></li><li class="chapter-item expanded "><a href="../extension-guides/color-theme.html"><strong aria-hidden="true">20.</strong> 色彩主题</a></li><li class="chapter-item expanded "><a href="../extension-guides/file-icon-theme.html"><strong aria-hidden="true">21.</strong> 文件图标主题</a></li><li class="chapter-item expanded "><a href="../extension-guides/product-icon-theme.html"><strong aria-hidden="true">22.</strong> 产品图标主题</a></li><li class="chapter-item expanded "><a href="../extension-guides/tree-view.html"><strong aria-hidden="true">23.</strong> 树视图</a></li><li class="chapter-item expanded "><a href="../extension-guides/webview.html"><strong aria-hidden="true">24.</strong> Webview</a></li><li class="chapter-item expanded "><a href="../extension-guides/notebook.html"><strong aria-hidden="true">25.</strong> 笔记本</a></li><li class="chapter-item expanded "><a href="../extension-guides/virtual-documents.html"><strong aria-hidden="true">26.</strong> 虚拟文档</a></li><li class="chapter-item expanded "><a href="../extension-guides/task-provider.html"><strong aria-hidden="true">27.</strong> 任务</a></li><li class="chapter-item expanded "><a href="../extension-guides/scm-provider.html"><strong aria-hidden="true">28.</strong> 源控制</a></li><li class="chapter-item expanded "><a href="../extension-guides/debugger-extension.html" class="active"><strong aria-hidden="true">29.</strong> 调试器插件</a></li><li class="chapter-item expanded "><a href="../extension-guides/markdown-extension.html"><strong aria-hidden="true">30.</strong> Markdown插件</a></li><li class="chapter-item expanded "><a href="../extension-guides/custom-editors.html"><strong aria-hidden="true">31.</strong> 自定义编辑器</a></li><li class="chapter-item expanded "><a href="../extension-guides/custom-data-extension.html"><strong aria-hidden="true">32.</strong> 自定义数据插件</a></li><li class="chapter-item expanded affix "><li class="part-title">语言插件</li><li class="spacer"></li><li class="chapter-item expanded "><a href="../language-extensions/index.html"><strong aria-hidden="true">33.</strong> 概述</a></li><li class="chapter-item expanded "><a href="../language-extensions/syntax-highlight-guide.html"><strong aria-hidden="true">34.</strong> 语法高亮</a></li><li class="chapter-item expanded "><a href="../language-extensions/semantic-highlight-guide.html"><strong aria-hidden="true">35.</strong> 语义高亮</a></li><li class="chapter-item expanded "><a href="../language-extensions/snippet-guide.html"><strong aria-hidden="true">36.</strong> 代码片段</a></li><li class="chapter-item expanded "><a href="../language-extensions/language-configuration-guide.html"><strong aria-hidden="true">37.</strong> 语言配置</a></li><li class="chapter-item expanded "><a href="../language-extensions/programmatic-language-features.html"><strong aria-hidden="true">38.</strong> 程序性语言特性</a></li><li class="chapter-item expanded "><a href="../language-extensions/language-server-extension-guide.html"><strong aria-hidden="true">39.</strong> 语言服务器</a></li><li class="chapter-item expanded "><a href="../language-extensions/embedded-languages.html"><strong aria-hidden="true">40.</strong> 嵌入语言</a></li><li class="chapter-item expanded affix "><li class="part-title">进阶主题</li><li class="spacer"></li><li class="chapter-item expanded "><a href="../advanced-topics/extension-host.html"><strong aria-hidden="true">41.</strong> 插件主机</a></li><li class="chapter-item expanded "><a href="../advanced-topics/remote-extensions.html"><strong aria-hidden="true">42.</strong> 远程开发</a></li><li class="chapter-item expanded "><a href="../advanced-topics/using-proposed-api.html"><strong aria-hidden="true">43.</strong> 使用不稳定的API</a></li><li class="chapter-item expanded affix "><li class="part-title">️️参考</li><li class="spacer"></li><li class="chapter-item expanded "><a href="../references/vscode-api.html"><strong aria-hidden="true">44.</strong> VS Code API</a></li><li class="chapter-item expanded "><a href="../references/contribution-points.html"><strong aria-hidden="true">45.</strong> 发布内容配置</a></li><li class="chapter-item expanded "><a href="../references/activation-events.html"><strong aria-hidden="true">46.</strong> 激活事件</a></li><li class="chapter-item expanded "><a href="../references/extension-manifest.html"><strong aria-hidden="true">47.</strong> 插件清单</a></li><li class="chapter-item expanded "><a href="../references/commands.html"><strong aria-hidden="true">48.</strong> 命令</a></li><li class="chapter-item expanded "><a href="../references/when-clause-contexts.html"><strong aria-hidden="true">49.</strong> when 子句上下文</a></li><li class="chapter-item expanded "><a href="../references/theme-color.html"><strong aria-hidden="true">50.</strong> 主题色彩</a></li><li class="chapter-item expanded "><a href="../references/icons-in-labels.html"><strong aria-hidden="true">51.</strong> 标签中的图标</a></li><li class="chapter-item expanded "><a href="../references/document-selector.html"><strong aria-hidden="true">52.</strong> 文档选择器</a></li><li class="chapter-item expanded "><a href="../references/extension-guidelines.html"><strong aria-hidden="true">53.</strong> 插件开发准则</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">VS Code 插件开发文档</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="调试器插件"><a class="header" href="#调试器插件">调试器插件</a></h1>
<p>VS Code已经内置了一套通用的用户界面，插件作者能够通过VS Code的调试架构轻松将已有的调试器整合进来。</p>
<p>VS Code已经内置了一个<a href="https://nodejs.org/">Node.js</a>调试器插件，它将成为你学习VS Code调试器特性的绝佳搭档。</p>
<p><img src="https://media.githubusercontent.com/media/Microsoft/vscode-docs/master/api/extension-guides/images/debugger-extension/debug-features.png" alt="VS Code调试功能" /></p>
<p>上面的截图展示了以下调试功能：</p>
<ol>
<li>管理调试器配置</li>
<li>开始、停止、步进等调试操作</li>
<li>源、函数、条件断点、行断点和记录点</li>
<li>支持多线程和多进程的调用栈</li>
<li>在<em>视图</em>中浏览复杂的数据，鼠标悬停在数据上可以看到更多信息</li>
<li>鼠标悬停在源代码中可以看到变量的值</li>
<li>管理watch表达式</li>
<li>调试控制台支持交互操作，如求值、自动补全等</li>
</ol>
<p>本节将帮你创建一个任意调试器都可以和VS Code协作的调试器插件。</p>
<h2 id="vs-code-中的调试架构"><a class="header" href="#vs-code-中的调试架构">VS Code 中的调试架构</a></h2>
<hr />
<p>VS Code基于抽象协议，实现了一个原生（非语言相关的）的调试器UI，它可以和任意后台调试程序通信。通常来讲，调试器不会实现这份协议，因此调试器中需要一些中间件去“适配”这个协议。这个中间件一般而言是一个独立和调试器通信的进程。</p>
<p><img src="https://media.githubusercontent.com/media/Microsoft/vscode-docs/master/api/extension-guides/images/debugger-extension/debug-arch1.png" alt="VS Code的调试架构" /></p>
<p>我们将这个中间件称为<strong>调试适配器（Debug Adapter）</strong>（简写为<strong>DA</strong>），在VS Code和DA之间通信的抽象协议称之为<strong>调试适配器协议(Debug Adapter Protocol)</strong> (简写<strong>DAP</strong>)。调试适配器协议独立于VS Code，它有自己的<a href="https://microsoft.github.io/debug-adapter-protocol/">网站</a>，你在上面可以找到相关的<a href="https://microsoft.github.io/debug-adapter-protocol/overview">介绍和概述</a>，以及详细的<a href="https://microsoft.github.io/debug-adapter-protocol/specification">说明书</a>，上面还列出了一些<a href="https://microsoft.github.io/debug-adapter-protocol/implementors/adapters/">已知实现和支持工具</a>，这份努力背后的故事和动机，我们都记录在了<a href="https://code.visualstudio.com/blogs/2018/08/07/debug-adapter-protocol-website#_why-the-need-for-decoupling-with-protocols">博客</a>中。</p>
<p>因为调试适配器独立于VSCode，所以它可用在<a href="https://microsoft.github.io/debug-adapter-protocol/implementors/tools/">其他开发工具</a>中，它们无需匹配VS Code的插件架构，而只需基于插件和<em>发布内容配置</em>即可。</p>
<p>出于这个原因，VS Code提供了一个配置点<code>debuggers</code>，调试适配器在这里可以配置特定的调试类型（例如：Node.js调试器使用<code>node</code>）。用户只要启动了这个类型的调试适配器会话，VS Code就能加载注册好的调试适配器。</p>
<p>因此调试适配器的最小形式就是声明一个配置，对应调试适配器的实现，这个插件就是调试适配器的装载容器，而且不需要任何多余的代码。</p>
<p><img src="https://media.githubusercontent.com/media/Microsoft/vscode-docs/master/api/extension-guides/images/debugger-extension/debug-arch2.png" alt="VS Code调试架构-2" /></p>
<p>一个更贴近现实的调试器插件往往会添加很多配置，如下面的：</p>
<ul>
<li>调试器支持的语言。VS Code会为这些语言启用UI界面的断点功能</li>
<li>由调试器引入的JSON格式的调试配置属性。VS Code会使用这个格式校验launch.json中的配置，并提供补全功能</li>
<li>首次加载调试时，VS Code自动生成初始launch.json文件</li>
<li>用户可以给launch.json添加的调试配置片段</li>
<li>声明调试配置中可以使用的变量</li>
</ul>
<p>想要了解更多相关内容，请查看<a href="/extensibility-reference/contribution-points#contributesbreakpoints">contributes.breakpoints</a>和<a href="/extensibility-reference/contribution-points#contributesdebuggers">contributes.debuggers</a>。</p>
<h2 id="模拟调试插件"><a class="header" href="#模拟调试插件">模拟调试插件</a></h2>
<hr />
<p>由于从头开始创建一个调试适配器太繁琐了，所以我们将从简单的DA(我们已经创建过的<strong>入门级调试适配器</strong>)开始。因为它不与真正的调试器进行通信，所以就叫它——<em>模拟调试</em>吧。</p>
<p><em>模拟调试</em>模拟了调试器功能，支持：</p>
<ul>
<li>单步调试</li>
<li>跳到下一个断点</li>
<li>断点</li>
<li>异常</li>
<li>访问变量</li>
</ul>
<p>在深入了解开发中的<em>模拟调试</em>之前，我们先去VS Code插件市场安装个<a href="https://marketplace.visualstudio.com/items?itemName=andreweinand.mock-debug">预构建版本</a>玩一玩，就像下面这样：</p>
<ul>
<li>打开VS Code的插件面板，输入&quot;mock&quot;并找到<strong>Mock Debug</strong>插件</li>
<li><strong>安装</strong>并<strong>重启</strong></li>
</ul>
<p>通过如下流程来启动<em>模拟调试</em>：</p>
<ul>
<li>新建一个空的文件夹<code>mock test</code>并在VS Code中打开</li>
<li>创建一个<code>readme.md</code>，在里面随便写点什么东西</li>
<li>切换到<strong>调试</strong>视图，点一下<strong>齿轮图标</strong></li>
<li>VS Code会让你选择一个&quot;环境&quot;，并将其作为默认的启动配置。这里选择&quot;Mock Debug&quot;。</li>
<li>点击绿色的<strong>开始</strong>按钮，然后开始调试</li>
</ul>
<p>至此，一个调试会话就开始了，你可以在<code>readme.md</code>文件中进行单步调试、打断点。如果某一行出现异常则会跳进该异常。</p>
<p><img src="https://media.githubusercontent.com/media/Microsoft/vscode-docs/master/api/extension-guides/images/debugger-extension/mock-debug.gif" alt="模拟运行调试工具" /></p>
<p>在使用<em>模拟调试</em>之前，我们建议你卸载掉<a href="https://marketplace.visualstudio.com/items?itemName=andreweinand.mock-debug">预构建版本</a>：</p>
<ul>
<li>切换到Extensions视图，然后单击<em>模拟调试</em>插件的齿轮图标</li>
<li>卸载该插件并重启VS Code</li>
</ul>
<h2 id="开发环境配置模拟调试"><a class="header" href="#开发环境配置模拟调试">开发环境配置模拟调试</a></h2>
<hr />
<p>现在让我们下载Mock Debug的源码，然后用VS Code进行开发吧：</p>
<pre><code class="language-bash">git clone https://github.com/Microsoft/vscode-mock-debug.git
cd vscode-mock-debug
npm install
</code></pre>
<p>用VS Code打开<code>vscode-mock-debug</code>项目</p>
<p>我们的项目里面有什么呢？</p>
<ul>
<li><code>package.json</code>是mock-debug插件的配置清单：
<ul>
<li>里面是mock-debug插件的<em>发布内容配置</em>清单</li>
<li><code>compile</code>和<code>watch</code>脚本会将Typescript源码编译到<code>out</code>文件夹中，然后<code>watch</code>脚本会追踪源码每个细微的修改</li>
<li><code>vscode-debugprotocol</code>，<code>vscode-debugadapter</code>和<code>vscode-debugadapter-testsupport</code>npm依赖包简化了基于node的调试适配器开发工作</li>
</ul>
</li>
<li><code>src/mockRuntime.ts</code>是一个<strong>模拟的</strong>运行时，仅仅包含一些简单的调试API</li>
<li><code>src/mockDebug.ts</code>是我们的主要代码，是它将<em>运行时</em>适配到<strong>调试适配器</strong>上。你可以在里面找到各种处理DAP请求的方式。</li>
<li>调试插件实现于调试适配器，所以你可以完全不使用创建普通插件的代码（比如：原来插件的代码运行在扩展主机环境中），但是mock-debug还是有个小小的<code>src/extension.ts</code>，这份代码里面阐释了调试器插件中<em>插件</em>部分的代码可以做些什么。</li>
</ul>
<p>现在构建项目，然后加载Mock Debug插件。选择<strong>调试侧边栏</strong>，加载 <strong>Extension</strong> 配置，然后按下<code>F5</code>。接下来，会启动插件的Typescript编译工作，将转换后的代码输出到<code>out</code>文件夹中，然后进行全量编译，再接着，<em>watcher</em>任务会启动以便侦听你的改动。</p>
<p>代码编译完成后，带有&quot;[Extension Development Host]&quot;（中文环境下是&quot;[扩展开发主机]&quot;）VS Code新窗口会自动打开，Mock Debug插件就运行在调试模式中了。在这个窗口中，打开<code>mock test</code>项目，打开里面的<code>readme.md</code>，然后直接按下<kbd>F5</kbd>启动调试会话，现在你就可以调试了！</p>
<p><img src="https://media.githubusercontent.com/media/Microsoft/vscode-docs/master/api/extension-guides/images/debugger-extension/debug-mock-session.png" alt="模拟调试会话" /></p>
<p>因为的你插件运行在 <em>调试模式</em> 中，所以你能在<code>src/extension.ts</code>里面打断点，不过就如上文所说，这个插件关于<em>插件</em>本身的代码是没有多少的，最有意思的代码运行在调试适配器里，它是一个独立的进程。</p>
<p>要想调试调试适配器本身，我们需要把它运行在调试模式里。最简单的办法就是将调试适配器以<em>服务器模式</em>运行，然后配置VS Code去连接它。在你的vscode-mock-debug项目中，重新在打开的调试侧边栏的配置下拉菜单中选择<em>Server</em>配置，按下旁边的绿色开始按钮。</p>
<p>因为我们已经启动了一个调试会话，所以VS Code 调试器UI现在会进入 <em>多会话</em> 模式，在**调用栈（CALL STACK）**视图中你现在可以看到2个调试会话—— <strong>Extension</strong> 和 <strong>Server</strong> 。</p>
<p><img src="https://media.githubusercontent.com/media/Microsoft/vscode-docs/master/api/extension-guides/images/debugger-extension/debugger-extension-server.png" alt="调试插件和服务器" /></p>
<p>现在我们可以同时调试插件和DA（调试适配器）了。到我们目前这一步还有个更快的方式，启动调试时选择<strong>Extension + Server</strong>配置就会自动加载这两个会话。</p>
<p>另外，调试插件和调试适配器更简单的方式会在<a href="#%E5%BC%80%E5%8F%91%E8%B0%83%E8%AF%95%E5%99%A8%E6%8F%92%E4%BB%B6%E7%9A%84%E5%85%B6%E4%BB%96%E6%96%B9%E5%BC%8F">下面</a>说明。</p>
<p>在<code>src/mockDebug.ts</code>中的<code>launchRequest(...)</code>最开始的地方打上断点，然后最后一步则是在你的mock test启动配置中添加<code>debugServer</code>属性和对应的端口值<code>4711</code>就完成了调试器和调试适配器的连接。</p>
<pre><code class="language-json">{
	&quot;version&quot;: &quot;0.2.0&quot;,
	&quot;configurations&quot;: [
		{
			&quot;type&quot;: &quot;mock&quot;,
			&quot;request&quot;: &quot;launch&quot;,
			&quot;name&quot;: &quot;mock test&quot;,
			&quot;program&quot;: &quot;${workspaceFolder}/readme.md&quot;,
			&quot;stopOnEntry&quot;: true,
			&quot;debugServer&quot;: 4711
		}
	]
}
</code></pre>
<p>如果你现在就加载这个调试配置，调试适配器不会以分离的进程启动，而是直接连接到已经存在的本地服务器端口4711上。现在你可以在<code>launchRequest</code>打断点了。</p>
<p>经过这样一连串的配置，你终于可以轻松地编辑、编译和调试Mock Debug插件了。</p>
<p>但是好戏才刚刚开始：你需要替换<code>src/mockDebug.ts</code>和<code>src/mockRuntime.ts</code>的中的调试适配器代码，让它可以和“真正的”调试器或者运行时通信。这项工作涉及到理解和实现调试适配器协议。</p>
<p>更多内容请查看<a href="https://microsoft.github.io/debug-adapter-protocol/overview#How_it_works">这里</a>。</p>
<h2 id="剖析调试器插件的packagejson"><a class="header" href="#剖析调试器插件的packagejson">剖析调试器插件的package.json</a></h2>
<hr />
<p>除了提供调试适配的特定实现之外，调试器插件还需要一个配置各种各样和调试相关的<code>package.json</code>。</p>
<p>所以下面我们进一步看看Mock Debug的<code>package.json</code>.</p>
<p>就像一般的VS Code插件，<code>package.json</code>声明了一些基础信息，如插件的<strong>name</strong> ，<strong>publisher</strong>，<strong>version</strong>等。其中配置<strong>categories</strong>字段可以让你的插件更容易在插件市场中被其他人发现。</p>
<pre><code class="language-json">{
	&quot;name&quot;: &quot;mock-debug&quot;,
	&quot;displayName&quot;: &quot;Mock Debug&quot;,
	&quot;version&quot;: &quot;0.24.0&quot;,
	&quot;publisher&quot;: &quot;...&quot;,
	&quot;description&quot;: &quot;Starter extension for developing debug adapters for VS Code.&quot;,
	&quot;author&quot;: {
		&quot;name&quot;: &quot;...&quot;,
		&quot;email&quot;: &quot;...&quot;
	},
	&quot;engines&quot;: {
		&quot;vscode&quot;: &quot;^1.17.0&quot;,
		&quot;node&quot;: &quot;^7.9.0&quot;
	},
	&quot;icon&quot;: &quot;images/mock-debug-icon.png&quot;,
	&quot;categories&quot;: [&quot;Debuggers&quot;],

	&quot;contributes&quot;: {
		&quot;breakpoints&quot;: [{ &quot;language&quot;: &quot;markdown&quot; }],
		&quot;debuggers&quot;: [
			{
				&quot;type&quot;: &quot;mock&quot;,
				&quot;label&quot;: &quot;Mock Debug&quot;,

				&quot;program&quot;: &quot;./out/mockDebug.js&quot;,
				&quot;runtime&quot;: &quot;node&quot;,

				&quot;configurationAttributes&quot;: {
					&quot;launch&quot;: {
						&quot;required&quot;: [&quot;program&quot;],
						&quot;properties&quot;: {
							&quot;program&quot;: {
								&quot;type&quot;: &quot;string&quot;,
								&quot;description&quot;: &quot;Absolute path to a text file.&quot;,
								&quot;default&quot;: &quot;${workspaceFolder}/${command:AskForProgramName}&quot;
							},
							&quot;stopOnEntry&quot;: {
								&quot;type&quot;: &quot;boolean&quot;,
								&quot;description&quot;: &quot;Automatically stop after launch.&quot;,
								&quot;default&quot;: true
							}
						}
					}
				},

				&quot;initialConfigurations&quot;: [
					{
						&quot;type&quot;: &quot;mock&quot;,
						&quot;request&quot;: &quot;launch&quot;,
						&quot;name&quot;: &quot;Ask for file name&quot;,
						&quot;program&quot;: &quot;${workspaceFolder}/${command:AskForProgramName}&quot;,
						&quot;stopOnEntry&quot;: true
					}
				],

				&quot;configurationSnippets&quot;: [
					{
						&quot;label&quot;: &quot;Mock Debug: Launch&quot;,
						&quot;description&quot;: &quot;A new configuration for launching a mock debug program&quot;,
						&quot;body&quot;: {
							&quot;type&quot;: &quot;mock&quot;,
							&quot;request&quot;: &quot;launch&quot;,
							&quot;name&quot;: &quot;${2:Launch Program}&quot;,
							&quot;program&quot;: &quot;^\&quot;\\${workspaceFolder}/${1:Program}\&quot;&quot;
						}
					}
				],

				&quot;variables&quot;: {
					&quot;AskForProgramName&quot;: &quot;extension.mock-debug.getProgramName&quot;
				}
			}
		]
	},

	&quot;activationEvents&quot;: [&quot;onDebug&quot;, &quot;onCommand:extension.mock-debug.getProgramName&quot;]
}
</code></pre>
<p>现在我们来看看调试器插件中的<code>contributes</code>部分。</p>
<p>首先，<strong>breakpoints</strong>配置部分列出了可以使用断点的语言列表，没有这个配置的话，就不可能在 Markdown文件中设置断点了。</p>
<p>接下来是<strong>debuggers</strong>部分，这里引入了一个类型是<code>mock</code>的调试器，用户可以在调试器加载配置中引用这个类型。可选属性<strong>label</strong>是这个调试器的名字，它会显示在UI上。</p>
<p>因为调试器插件使用了调试适配器，所以它的的关联路径得通过<strong>program</strong>属性配置。为了保证插件的自包含性（self-contained），这个应用必须在我们的插件文件夹中。按惯例，我们将这个应用放在<code>out</code>或者<code>bin</code>中，当然你也可以使用其他名称的文件夹存放。</p>
<p>因为VS Code运行在不同的平台上，我们需要确保DA程序也能够支持不同的平台。对于这点，我们提供了下列选项：</p>
<ol>
<li>如果程序在平台上的实现都是各自独立的，比如：这个程序的运行时支持所有平台，你可以在<strong>runtime</strong>属性中指明。
到目前为止，VS Code支持<code>node</code>和<code>moni</code>运行时，我们的Mock Debug就使用了这个方式。</li>
<li>如果你的DA在不同的平台上对应着不同的可执行程序，那么你可以这样使用<strong>program</strong>属性：</li>
</ol>
<pre><code class="language-json">&quot;debuggers&quot;: [{
    &quot;type&quot;: &quot;gdb&quot;,
    &quot;windows&quot;: {
        &quot;program&quot;: &quot;./bin/gdbDebug.exe&quot;,
    },
    &quot;osx&quot;: {
        &quot;program&quot;: &quot;./bin/gdbDebug.sh&quot;,
    },
    &quot;linux&quot;: {
        &quot;program&quot;: &quot;./bin/gdbDebug.sh&quot;,
    }
}]
</code></pre>
<ol start="3">
<li>组合上面两种方式也是可以的。下面的例子实现了在macOS和Linux上使用同一个mono应用，但是Windows上就不是。</li>
</ol>
<pre><code class="language-json">&quot;debuggers&quot;: [{
    &quot;type&quot;: &quot;mono&quot;,
    &quot;program&quot;: &quot;./bin/monoDebug.exe&quot;,
    &quot;osx&quot;: {
        &quot;runtime&quot;: &quot;mono&quot;
    },
    &quot;linux&quot;: {
        &quot;runtime&quot;: &quot;mono&quot;
    }
}]
</code></pre>
<p><strong>configurationAttributes</strong>声明了这个调试器的<code>launch.json</code>中的属性可以使用的协议。这个协议用于校验<code>launch.json</code>，同时支持编辑加载配置时的智能补全和悬停帮助。</p>
<p><strong>initialConfigurations</strong>定义了这个调试器的初始<code>launch.json</code>。当一个项目没有<code>launch.json</code>，然后用户打开了调试会话时，就会使用这个启动配置。然后VS Code会让用户选择一个调试环境，接着再创建对应的<code>launch.json</code>：</p>
<p><img src="https://media.githubusercontent.com/media/Microsoft/vscode-docs/master/api/extension-guides/images/debugger-extension/debug-init-config.png" alt="调试速选框" /></p>
<p>除了在<code>package.json</code>中静态定义<code>launch.json</code>的初始内容，你还可以使用<code>DebugConfigurationProvider</code>动态注入初始配置内容（详情见下<a href="#%E4%BD%BF%E7%94%A8DebugConfigurationProvider">使用DebugConfigurationProvider</a>）。</p>
<p><strong>configurationSnippets</strong>定义了编辑<code>launch.json</code>会为用户呈现的代码补全提示。同样，按约定<code>label</code>属性定义了调试环境的名称，所以当大量补全提示出现的时候，用户才能一眼认出自己想要的那个。</p>
<p><strong>variables</strong>配置，将“变量”绑定到了“命令”上。这些变量会出现在加载配置（launch.json）中，用法是**${command:xyz}**，调试会话启动后，其中的值会被命令中的返回值替换。</p>
<p><em>命令</em>实现在插件（而不是调试适配器）中，它可以由一句简单的表达式实现，也可以复杂到基于插件API和UI特性实现。Mock Debug将变量<code>AskForProgramName</code>绑定到了命令<code>extension.mock-debug.getProgramName</code>，这个命令的<a href="https://github.com/Microsoft/vscode-mock-debug/blob/606454ff3bd669867a38d9b2dc7b348d324a3f6b/src/extension.ts#L21-L26">实现</a>在<code>src/extension.ts</code>中，代码中的<code>showInputBox</code>允许用户为程序命名：</p>
<pre><code class="language-typescript">vscode.commands.registerCommand('extension.mock-debug.getProgramName', config =&gt; {
	return vscode.window.showInputBox({
		placeHolder: 'Please enter the name of a markdown file in the workspace folder',
		value: 'readme.md'
	});
});
</code></pre>
<p>现在加载配置（launch.json）中可以使用**${command:AskForProgramName}**中的值（文本类型）了。</p>
<h2 id="使用debugconfigurationprovider"><a class="header" href="#使用debugconfigurationprovider">使用DebugConfigurationProvider</a></h2>
<hr />
<p>如果你觉得<code>package.json</code>中和调试相关的发布内容配置不够你用，<code>DebugConfigurationProvider</code>可以动态控制调试插件下列方面的内容：</p>
<ul>
<li>动态生成launch.json中的配置。比如：根据工作区的信息生成一些配置。</li>
<li>在启动新的调试会话前，解析（或修改）加载配置。有了这个功能，你可以根据工作区的不同填入对应的配置默认值。</li>
</ul>
<p><code>src/extension.ts</code>中的<code>MockConfigurationProvider</code>实现了<code>resolveDebugConfiguration</code>，它会检测调试会话启动时是不是还没有launch.json文件，而且Markdown文件已经打开了。这种场景非常常见，用户已经打开了文件，他想要立刻启动调试而且不想要搞任何配置。</p>
<p>通过<code>vscode.debug.registerDebugConfigurationProvider</code>注册<em>调试配置供应器函数</em>，它一般在插件的<code>active</code>函数中。<code>DebugConfigurationProvider</code>需要尽早注册，一旦调试功能被使用到了，插件就应该启动。我们通过<code>package.json</code>中的<code>onDebug</code>事件轻松搞定这个需求：</p>
<pre><code class="language-json">&quot;activationEvents&quot;: [
    &quot;onDebug&quot;,
    // ...
],
</code></pre>
<p>在低开销的插件启动时（启动时不会花太多时间），这个机制会如预期工作。但是如果插件的启动开销较大（比如启动一个语言服务器），那么<code>onDebug</code>事件可能会对其他调试插件产生副作用，因为<code>onDebug</code>事件已经激活了其他插件，但是其他插件因为阻塞还来不及接收到具体的调试类型。</p>
<p>对于高开销的调试插件来说，更好的方法就是使用粒度更细的 激活事件：</p>
<ul>
<li><code>onDebugInitialConfigurations</code>会在<code>DebugConfigurationProvider</code>的<code>provideDebugConfigurations</code>调用前触发</li>
<li><code>onDebugResolve:type</code>会在<code>DebugConfigurationProvider</code>的<code>resolveDebugConfiguration</code>取得具体的调试类型前触发</li>
</ul>
<p>!&gt; **首要原则：**如果调试插件的开销很小，就用<code>onDebug</code>，根据<code>DebugConfigurationProvider</code>是否实现了<code>provideDebugConfigurations</code>或<code>resolveDebugConfiguration</code>，然后在对应的<code>onDebugInitialConfigurations</code>或者<code>onDebugResolve</code>中处理。</p>
<h2 id="发布调试器插件"><a class="header" href="#发布调试器插件">发布调试器插件</a></h2>
<hr />
<p>通过下面的步骤将你的调试适配器发布到市场上：</p>
<ul>
<li>更新<code>package.json</code>中的发布配置内容表明你调试适配器的功能和目标</li>
<li>参考<a href="/working-with-extensions/publish-extension">发布插件</a>部分然后将你的插件上传到市场上</li>
</ul>
<h2 id="开发调试器插件的其他方式"><a class="header" href="#开发调试器插件的其他方式">开发调试器插件的其他方式</a></h2>
<hr />
<p>如我们所见，开发一个调试插件涉及到<em>一个普通插件</em>再加上一个调试适配器，它们分别运行在不同的会话中。VS Code支持这样的实现，但是简单的办法是还是把<em>插件</em>和调试适配器用一个程序实现，这样你就可以在一个调试会话中同时调试了。</p>
<p>实际上，只要你的调试适配器是基于Typescript/Javascript实现的，这个方法就都是可行的。基本的思路是把调试适配器实现为一个服务器，让<em>插件</em>去启动这个服务，再让VS Code连接上去，这样你就不用每个调试会话都启动一个新的调试适配器了。</p>
<p>Mock Debug的例子阐述了一个<a href="https://github.com/Microsoft/vscode-mock-debug/blob/6a2ef01b95bb22cdf55683f4d616cad501051510/src/extension.ts#L74-L98">DebugAdapterDescriptorFactory</a>可以怎样创建和<a href="https://github.com/Microsoft/vscode-mock-debug/blob/6a2ef01b95bb22cdf55683f4d616cad501051510/src/extension.ts#L32-L36">注册</a>一个基于服务器的调试适配器。通过将编译时的<a href="https://github.com/Microsoft/vscode-mock-debug/blob/6a2ef01b95bb22cdf55683f4d616cad501051510/src/extension.ts#L17"><code>EMBED_DEBUG_ADAPTER</code></a>配置设置为true启用这个特性。现在如果你用<strong>F5</strong>启动调试，你就不仅仅是在插件开发主机中打了断点，你也同时在调试适配器中打了同样的断点。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../extension-guides/scm-provider.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../extension-guides/markdown-extension.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../extension-guides/scm-provider.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../extension-guides/markdown-extension.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
