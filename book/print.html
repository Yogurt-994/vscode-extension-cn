<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>VS Code 插件开发文档</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><li class="part-title">预备知识</li><li class="spacer"></li><li class="chapter-item expanded "><a href="preknowledge/first-step.html"><strong aria-hidden="true">1.</strong> 非JS开发者的第一步</a></li><li class="chapter-item expanded "><a href="preknowledge/variable-and-type.html"><strong aria-hidden="true">2.</strong> Typescript-变量和类型</a></li><li class="chapter-item expanded "><a href="preknowledge/class.html"><strong aria-hidden="true">3.</strong> Typescript-类</a></li><li class="chapter-item expanded "><a href="preknowledge/interface-and-namespace.html"><strong aria-hidden="true">4.</strong> Typescript-接口和命名空间</a></li><li class="chapter-item expanded "><a href="preknowledge/generics.html"><strong aria-hidden="true">5.</strong> Typescript-泛型</a></li><li class="chapter-item expanded "><a href="preknowledge/declaration-files.html"><strong aria-hidden="true">6.</strong> Typescript-声明文件</a></li><li class="chapter-item expanded affix "><li class="part-title">第一步</li><li class="spacer"></li><li class="chapter-item expanded "><a href="get-started/your-first-extension.html"><strong aria-hidden="true">7.</strong> 你的第一个插件</a></li><li class="chapter-item expanded "><a href="get-started/extension-anatomy.html"><strong aria-hidden="true">8.</strong> 解析插件结构</a></li><li class="chapter-item expanded "><a href="get-started/wrapping-up.html"><strong aria-hidden="true">9.</strong> 小结</a></li><li class="chapter-item expanded affix "><li class="part-title">开发插件</li><li class="spacer"></li><li class="chapter-item expanded "><a href="working-with-extensions/testing-extension.html"><strong aria-hidden="true">10.</strong> 测试插件</a></li><li class="chapter-item expanded "><a href="working-with-extensions/publish-extension.html"><strong aria-hidden="true">11.</strong> 发布插件</a></li><li class="chapter-item expanded "><a href="working-with-extensions/bundling-extension.html"><strong aria-hidden="true">12.</strong> 打包插件</a></li><li class="chapter-item expanded "><a href="working-with-extensions/continuous-integration.html"><strong aria-hidden="true">13.</strong> 持集成</a></li><li class="chapter-item expanded affix "><li class="part-title">插件功能</li><li class="spacer"></li><li class="chapter-item expanded "><a href="extension-capabilities/index.html"><strong aria-hidden="true">14.</strong> 概述</a></li><li class="chapter-item expanded "><a href="extension-capabilities/common-capabilities.html"><strong aria-hidden="true">15.</strong> 常用功能</a></li><li class="chapter-item expanded "><a href="extension-capabilities/theming.html"><strong aria-hidden="true">16.</strong> 主题</a></li><li class="chapter-item expanded "><a href="extension-capabilities/extending-workbench.html"><strong aria-hidden="true">17.</strong> 扩展工作台</a></li><li class="chapter-item expanded affix "><li class="part-title">插件指南</li><li class="spacer"></li><li class="chapter-item expanded "><a href="extension-guides/index.html"><strong aria-hidden="true">18.</strong> 概述</a></li><li class="chapter-item expanded "><a href="extension-guides/command.html"><strong aria-hidden="true">19.</strong> 命令</a></li><li class="chapter-item expanded "><a href="extension-guides/color-theme.html"><strong aria-hidden="true">20.</strong> 色彩主题</a></li><li class="chapter-item expanded "><a href="extension-guides/file-icon-theme.html"><strong aria-hidden="true">21.</strong> 文件图标主题</a></li><li class="chapter-item expanded "><a href="extension-guides/product-icon-theme.html"><strong aria-hidden="true">22.</strong> 产品图标主题</a></li><li class="chapter-item expanded "><a href="extension-guides/tree-view.html"><strong aria-hidden="true">23.</strong> 树视图</a></li><li class="chapter-item expanded "><a href="extension-guides/webview.html"><strong aria-hidden="true">24.</strong> Webview</a></li><li class="chapter-item expanded "><a href="extension-guides/notebook.html"><strong aria-hidden="true">25.</strong> 笔记本</a></li><li class="chapter-item expanded "><a href="extension-guides/virtual-documents.html"><strong aria-hidden="true">26.</strong> 虚拟文档</a></li><li class="chapter-item expanded "><a href="extension-guides/task-provider.html"><strong aria-hidden="true">27.</strong> 任务</a></li><li class="chapter-item expanded "><a href="extension-guides/scm-provider.html"><strong aria-hidden="true">28.</strong> 源控制</a></li><li class="chapter-item expanded "><a href="extension-guides/debugger-extension.html"><strong aria-hidden="true">29.</strong> 调试器插件</a></li><li class="chapter-item expanded "><a href="extension-guides/markdown-extension.html"><strong aria-hidden="true">30.</strong> Markdown插件</a></li><li class="chapter-item expanded "><a href="extension-guides/custom-editors.html"><strong aria-hidden="true">31.</strong> 自定义编辑器</a></li><li class="chapter-item expanded "><a href="extension-guides/custom-data-extension.html"><strong aria-hidden="true">32.</strong> 自定义数据插件</a></li><li class="chapter-item expanded affix "><li class="part-title">语言插件</li><li class="spacer"></li><li class="chapter-item expanded "><a href="language-extensions/index.html"><strong aria-hidden="true">33.</strong> 概述</a></li><li class="chapter-item expanded "><a href="language-extensions/syntax-highlight-guide.html"><strong aria-hidden="true">34.</strong> 语法高亮</a></li><li class="chapter-item expanded "><a href="language-extensions/semantic-highlight-guide.html"><strong aria-hidden="true">35.</strong> 语义高亮</a></li><li class="chapter-item expanded "><a href="language-extensions/snippet-guide.html"><strong aria-hidden="true">36.</strong> 代码片段</a></li><li class="chapter-item expanded "><a href="language-extensions/language-configuration-guide.html"><strong aria-hidden="true">37.</strong> 语言配置</a></li><li class="chapter-item expanded "><a href="language-extensions/programmatic-language-features.html"><strong aria-hidden="true">38.</strong> 程序性语言特性</a></li><li class="chapter-item expanded "><a href="language-extensions/language-server-extension-guide.html"><strong aria-hidden="true">39.</strong> 语言服务器</a></li><li class="chapter-item expanded "><a href="language-extensions/embedded-languages.html"><strong aria-hidden="true">40.</strong> 嵌入语言</a></li><li class="chapter-item expanded affix "><li class="part-title">进阶主题</li><li class="spacer"></li><li class="chapter-item expanded "><a href="advanced-topics/extension-host.html"><strong aria-hidden="true">41.</strong> 插件主机</a></li><li class="chapter-item expanded "><a href="advanced-topics/remote-extensions.html"><strong aria-hidden="true">42.</strong> 远程开发</a></li><li class="chapter-item expanded "><a href="advanced-topics/using-proposed-api.html"><strong aria-hidden="true">43.</strong> 使用不稳定的API</a></li><li class="chapter-item expanded affix "><li class="part-title">️️参考</li><li class="spacer"></li><li class="chapter-item expanded "><a href="references/vscode-api.html"><strong aria-hidden="true">44.</strong> VS Code API</a></li><li class="chapter-item expanded "><a href="references/contribution-points.html"><strong aria-hidden="true">45.</strong> 发布内容配置</a></li><li class="chapter-item expanded "><a href="references/activation-events.html"><strong aria-hidden="true">46.</strong> 激活事件</a></li><li class="chapter-item expanded "><a href="references/extension-manifest.html"><strong aria-hidden="true">47.</strong> 插件清单</a></li><li class="chapter-item expanded "><a href="references/commands.html"><strong aria-hidden="true">48.</strong> 命令</a></li><li class="chapter-item expanded "><a href="references/when-clause-contexts.html"><strong aria-hidden="true">49.</strong> when 子句上下文</a></li><li class="chapter-item expanded "><a href="references/theme-color.html"><strong aria-hidden="true">50.</strong> 主题色彩</a></li><li class="chapter-item expanded "><a href="references/icons-in-labels.html"><strong aria-hidden="true">51.</strong> 标签中的图标</a></li><li class="chapter-item expanded "><a href="references/document-selector.html"><strong aria-hidden="true">52.</strong> 文档选择器</a></li><li class="chapter-item expanded "><a href="references/extension-guidelines.html"><strong aria-hidden="true">53.</strong> 插件开发准则</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">VS Code 插件开发文档</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="非js开发者的第一步"><a class="header" href="#非js开发者的第一步">非JS开发者的第一步</a></h1>
<p>本章节并不是官方教程的一部分，作为读者的你可能擅长于C++，Python，Java等其他主流语言，而并不了解基于现代前端技术构建的VS Code和他的插件开发语言和模式。本章参考了官方文档模式，循序渐进地带你了解制作插件的一些编程基础，以免你在阅读文档时晕头转向，本章结束之后，你应该能比较顺利地阅读文档中出现的所有TypeScript代码，没有障碍地学习VS Code插件基础，但是如果你希望达到一定程度的TypeScript编程水平，请参考<a href="https://www.tslang.cn/">汉化版文档</a>。当然，<strong>本章并不是所有读者必须阅读的，你可以按照自己的喜好或者需要，查询对应的小节，如果你有足够的经验也完全可以跳过本章</strong>。</p>
<h2 id="前端和客户端技术"><a class="header" href="#前端和客户端技术">前端和客户端技术</a></h2>
<hr />
<p>众所周知，客户端界面技术已是一门非常“老古董”的技术了，从图形系统诞生至今，各类客户端开发技术和模式你方唱罢我登场，淘汰了一批又一批。而Web前端技术，在浏览器和网络技术的依托之下还在不断发展，在这期间浏览器对编译器孜孜不倦的优化，终于将JavaScript语言提升到了一个新的高度，使JavaScript语言进入了传统客户端领域，但是作为开发者必须意识到，即使是在TypeScript的加持下，JavaScript也并没有变成一门真正的静态类型语言，<strong>因此你在使用TypeScript的时候依旧需要谨慎行事并遵守社区的最佳实践</strong>。</p>
<p>我们教程学习的对象VS Code，便是建立在浏览器开源项目Chromium演化而来——名为Electron的客户端技术之上，它使用了性能极高的JS编译器和浏览器界面技术，<strong>将前端的三大编程基础JavaScript，HTML，CSS无缝地衔接进来，并融合了系统层级的编程接口</strong>。而VS Code在此之上进一步封装和优化，将编辑器进程和插件进程独立开来，同时高度封装DOM（文档对象模型）接口，禁止用户直接修改界面，我们只能通过VS Code提供的模式去开发符合规范的插件，虽然这些规定限制了开发者的手脚，但是更带来了安全、稳健、性能上的优势。</p>
<h2 id="typescript和vs-code"><a class="header" href="#typescript和vs-code">TypeScript和VS Code</a></h2>
<hr />
<p>TypeScript起初是微软开发的以JavaScript为基础的编程语言，他兼容JavaScript的所有特性，并扩展了JS的类型系统，使得用户在大型系统开发中更加游刃有余，VS Code天然支持TypeScript，帮助开发者写出更加稳定、安全的代码。因此所有文档的示例，包括插件本身，绝大部分都是使用TypeScript开发的，俗话说“不积跬步无以至千里”，当你足够了插件的基础之后，阅读文档才会更加顺利。</p>
<p>由于VS Code已经禁用了CSS和HTML，因此本章不会介绍这些内容，有兴趣的读者可参阅<a href="https://developer.mozilla.org/zh-CN/docs/Web">MDN文档</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="认识typescript-变量和类型"><a class="header" href="#认识typescript-变量和类型">认识TypeScript-变量和类型</a></h1>
<p>本节将介绍基础的TypeScript变量以及它的类型系统，它本质上和JavaScript是一样的，不过东西会更多一点，对于非js开发者来说，你可能会遇到熟悉的“枚举”、“元组”类型，了解了这点，或许能让你安心并更快地掌握TS，但是这并不意味着你就可以高枕无忧了，虽然TS扩展了JS的类型能力，但它本质上依旧是一门弱类型语言，请在书写代码时遵循社区的最佳实践并保持谨慎。</p>
<p>?&gt; 本文参考社区翻译文档，详见<a href="https://www.tslang.cn/docs/handbook/basic-types.html">https://www.tslang.cn/docs/handbook/basic-types.html</a></p>
<h2 id="类型"><a class="header" href="#类型">类型</a></h2>
<hr />
<p>变量声明的基础规则请自行参考JavaScript，JavaScript支持加分号和不加分号两种风格，方便起见，本章的所有示例代码都不会刻意添加分号，有关分号风格，请参阅<a href="https://developer.mozilla.org/zh-CN/docs/Learn/Getting_started_with_the_web/JavaScript_basics#%E5%8F%98%E9%87%8F%EF%BC%88variable%EF%BC%89">MDN</a>。</p>
<h3 id="类型注解"><a class="header" href="#类型注解">类型注解</a></h3>
<p>TS扩展了JS的语法格式，规则：在变量、声明的后面立即加上冒号<code>:</code>，如：</p>
<pre><code class="language-typescript">// 字符串注解
const XXX: string = 'string type'
// 布尔值注解
let true_or_false: boolean = false
// 函数参数类型注解
function params (value: string) {
    console.log(value) // 返回string类型
}
// 函数返回值类型注解
function returnValue (): string {
    return 'value is stirng'
}
</code></pre>
<p>请注意，类型注释应使用小写，而不是使用首字母大写的JavaScript的衍生类型（应使用<code>string</code>，而不是<code>String</code>）</p>
<h4 id="布尔值"><a class="header" href="#布尔值">布尔值</a></h4>
<p>最基本的数据类型就是简单的true/false值，在JavaScript和TypeScript里叫做boolean（其它语言中也一样）。</p>
<pre><code class="language-typescript">let isDone: boolean = false;
</code></pre>
<h4 id="数字"><a class="header" href="#数字">数字</a></h4>
<p>和JavaScript一样，TypeScript里的所有数字都是浮点数。 这些浮点数的类型是 number。 除了支持十进制和十六进制字面量，TypeScript还支持ECMAScript 2015中引入的二进制和八进制字面量。非JS开发者需要注意的是，TS和JS一样，没有区分数字类型（如Int，Long），如果你需要整数，需使用<code>Number.parseInt()</code>方法。</p>
<pre><code class="language-typescript">let decLiteral: number = 6;
let hexLiteral: number = 0xf00d;
let binaryLiteral: number = 0b1010;
let octalLiteral: number = 0o744;
</code></pre>
<h4 id="字符串"><a class="header" href="#字符串">字符串</a></h4>
<p>JavaScript程序的另一项基本操作是处理网页或服务器端的文本数据。 像其它语言里一样，我们使用 string表示文本数据类型。 和JavaScript一样，可以使用双引号（ &quot;）或单引号（'）表示字符串。</p>
<pre><code class="language-typescript">let name: string = &quot;bob&quot;;
name = &quot;smith&quot;;
</code></pre>
<p>你还可以使用模版字符串，它可以定义多行文本和内嵌表达式。 这种字符串是被反引号包围（ `），并且以<code>${ expr }</code>这种形式嵌入表达式</p>
<pre><code class="language-typescript">let name: string = `Gene`;
let age: number = 37;
let sentence: string = `Hello, my name is ${ name }.
I'll be ${ age + 1 } years old next month.`;
</code></pre>
<p>这与下面定义<code>sentence</code>的方式效果相同：</p>
<pre><code class="language-typescript">let sentence: string = &quot;Hello, my name is &quot; + name + &quot;.\n\t&quot; +
    &quot;I'll be &quot; + (age + 1) + &quot; years old next month.&quot;;
</code></pre>
<h4 id="数组"><a class="header" href="#数组">数组</a></h4>
<p>TypeScript像JavaScript一样可以操作数组元素。 有两种方式可以定义数组。 第一种，可以在元素类型后面接上 []，表示由此类型元素组成的一个数组：</p>
<pre><code class="language-typescript">let list: number[] = [1, 2, 3];
</code></pre>
<p>第二种方式是使用数组泛型，Array&lt;元素类型&gt;：</p>
<pre><code class="language-typescript">let list: Array&lt;number&gt; = [1, 2, 3];
</code></pre>
<h4 id="元组-tuple"><a class="header" href="#元组-tuple">元组 Tuple</a></h4>
<p>元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。 比如，你可以定义一对值分别为 string和number类型的元组。</p>
<pre><code class="language-typescript">// 声明一个元组
let x: [string, number];
// 将其初始化
x = ['hello', 10]; // OK
// 将其错误地初始化
x = [10, 'hello']; // Error
当访问一个已知索引的元素，会得到正确的类型：

console.log(x[0].substr(1)); // OK
console.log(x[1].substr(1)); // Error, 'number'类型没有'substr'方法
</code></pre>
<h4 id="枚举"><a class="header" href="#枚举">枚举</a></h4>
<p>enum类型是对JavaScript标准数据类型的一个补充。 像C#等其它语言一样，使用枚举类型可以为一组数值赋予友好的名字。</p>
<pre><code class="language-typescript">enum Color {Red, Green, Blue}
let c: Color = Color.Green;
</code></pre>
<p>默认情况下，从0开始为元素编号。 你也可以手动的指定成员的数值。 例如，我们将上面的例子改成从 1开始编号：</p>
<pre><code class="language-typescript">enum Color {Red = 1, Green, Blue}
let c: Color = Color.Green;
</code></pre>
<p>或者，全部都采用手动赋值：</p>
<pre><code class="language-typescript">enum Color {Red = 1, Green = 2, Blue = 4}
let c: Color = Color.Green;
</code></pre>
<p>枚举类型提供的一个便利是你可以由枚举的值得到它的名字。 例如，我们知道数值为2，但是不确定它映射到Color里的哪个名字，我们可以查找相应的名字：</p>
<pre><code class="language-typescript">enum Color {Red = 1, Green, Blue}
let colorName: string = Color[2];

console.log(colorName);  // 显示'Green'因为上面代码里它的值是2
</code></pre>
<h4 id="any"><a class="header" href="#any">Any</a></h4>
<p>有时候，我们会想要为那些在编写阶段还不清楚类型的变量指定一个类型。 这些值可能来自于动态的内容，比如来自用户输入或第三方代码库。 这种情况下，我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查。 那么我们可以使用 any类型来标记这些变量：</p>
<pre><code class="language-typescript">let notSure: any = 4;
notSure = &quot;maybe a string instead&quot;;
notSure = false; // 合法, 定义了一个布尔值
</code></pre>
<p>当你只知道一部分数据的类型时，any类型也是有用的。 比如，你有一个数组，它包含了不同的类型的数据：</p>
<pre><code class="language-typescript">let list: any[] = [1, true, &quot;free&quot;];

list[1] = 100;
</code></pre>
<h4 id="void"><a class="header" href="#void">Void</a></h4>
<p>某种程度上来说，void类型像是与any类型相反，它表示没有任何类型。 当一个函数没有返回值时，你通常会见到其返回值类型是 void：</p>
<pre><code class="language-typescript">function warnUser(): void {
    console.log(&quot;This is my warning message&quot;);
}
</code></pre>
<p>声明一个void类型的变量没有什么大用，因为你只能为它赋予undefined和null：</p>
<pre><code class="language-typescript">let unusable: void = undefined;
</code></pre>
<h4 id="object"><a class="header" href="#object">Object</a></h4>
<p>object表示非原始类型，也就是除number，string，boolean，symbol，null或undefined之外的类型。</p>
<p>使用object类型，就可以更好的表示像<code>Object.create</code>这样的API。例如：</p>
<pre><code class="language-typescript">declare function create(o: object | null): void;

create({ prop: 0 }); // OK
create(null); // OK

create(42); // Error
create(&quot;string&quot;); // Error
create(false); // Error
create(undefined); // Error
</code></pre>
<h2 id="typescript类型表"><a class="header" href="#typescript类型表">TypeScript类型表</a></h2>
<hr />
<div class="table-wrapper"><table><thead><tr><th>类型</th><th>例子</th></tr></thead><tbody>
<tr><td><strong>基本类型</strong></td><td></td></tr>
<tr><td>boolean</td><td><code>x: boolean = false</code></td></tr>
<tr><td>number</td><td><code>x: number = 10</code></td></tr>
<tr><td>string</td><td><code>x: string = '10'</code></td></tr>
<tr><td>undefined</td><td><code>x: undefined = undefined</code></td></tr>
<tr><td>null</td><td><code>x: null = null</code></td></tr>
<tr><td><strong>引用类型以及其他类型</strong></td><td></td></tr>
<tr><td>object</td><td><code>x: object = { age: '14', name: 'John' }</code></td></tr>
<tr><td>array</td><td><code>x: array = [1, '2', 3.0]</code></td></tr>
<tr><td>function</td><td><code>x: function = (args) =&gt; { console.log(args) }</code></td></tr>
<tr><td>symbol</td><td><code>x: symbol = Symbol('id')</code></td></tr>
<tr><td><strong>TypeScript 补充类型</strong></td><td></td></tr>
<tr><td>any</td><td><code>x: any = null</code></td></tr>
<tr><td>never</td><td><code>function error (msg): never =&gt; { throw new Error(msg) }</code></td></tr>
<tr><td>enum</td><td><code>enum Color {Red = 1, Green, Blue}</code></td></tr>
<tr><td>tuple</td><td><code>x: [string, number] = ['name', 12]</code></td></tr>
</tbody></table>
</div>
<h2 id="类型断言"><a class="header" href="#类型断言">类型断言</a></h2>
<hr />
<p>有时候你会遇到这样的情况，你比TypeScript更了解某个值的具体信息。</p>
<p>通过<em>类型断言</em>这种方式可以告诉编译器，“相信我，我知道自己在干什么”。 类型断言好比其它语言里的类型转换，但是不进行特殊的数据检查和解构。它没有运行时的影响，只是在编译阶段起作用。TypeScript会假设你——程序员——已经进行了必须的检查。</p>
<p>类型断言有两种形式。 其一是“尖括号”语法：</p>
<pre><code class="language-typescript">let someValue: any = &quot;this is a string&quot;;

let strLength: number = (&lt;string&gt;someValue).length;
</code></pre>
<p>另一个为as语法：</p>
<pre><code class="language-typescript">let someValue: any = &quot;this is a string&quot;;

let strLength: number = (someValue as string).length;
</code></pre>
<p>!&gt; 注意：本章全部采用了let，const关键字，以及你接下来可以见到的所有例子中，都不再使用var声明变量，为了避免var带来的副作用和影响，我们更提倡使用新的关键字。</p>
<h2 id="变量声明"><a class="header" href="#变量声明">变量声明</a></h2>
<hr />
<h3 id="let声明"><a class="header" href="#let声明">let声明</a></h3>
<p>由于本章侧重于帮助读者流畅地阅读文档中出现的TS代码，因此本节不再赘述var和新关键字之间的区别，读者如有兴趣可自行参考<a href="https://www.tslang.cn/">TypeScript文档</a>。</p>
<p>let的声明格式</p>
<pre><code class="language-typescript">let hello = &quot;Hello!&quot;;
</code></pre>
<h5 id="块作用域"><a class="header" href="#块作用域">块作用域</a></h5>
<p>当用let声明一个变量，它使用的是词法作用域或块作用域。 不同于使用 var声明的变量那样可以在包含它们的函数外访问，块作用域变量在包含它们的块或for循环之外是不能访问的。</p>
<pre><code class="language-typescript">function f(input: boolean) {
    let a = 100;

    if (input) {
        // 你在这里还可以访问到a
        let b = a + 1;
        return b;
    }

    // 错误: 'b'不存在
    return b;
}
</code></pre>
<p>这里我们定义了2个变量<code>a</code>和<code>b</code>。 <code>a</code>的作用域在<code>f</code>函数体内，而<code>b</code>的作用域只在<code>if</code>语句块里。</p>
<p>拥有块级作用域的变量的另一个特点是，它们不能在被声明之前读或写。 虽然这些变量始终“存在”于它们的作用域里，但在直到声明它的代码之前的区域都属于 <em>暂时性死区</em>。 它只是用来说明我们不能在 let语句之前访问它们，幸运的是TypeScript可以告诉我们这些信息。</p>
<pre><code class="language-typescript">a++; // illegal to use 'a' before it's declared;
let a;
</code></pre>
<p>注意一点，我们仍然可以在一个拥有块作用域变量被声明前获取它。 只是我们不能在变量声明前去调用那个函数。 如果生成代码目标为ES2015，运行时会抛出一个错误；然而，目前TypeScript是不会报错的。</p>
<pre><code class="language-typescript">function foo() {
    // okay to capture 'a'
    return a;
}

// 不能在'a'被声明前调用'foo'
// 运行时会抛出错误
foo();

let a;

</code></pre>
<h4 id="重定义及屏蔽"><a class="header" href="#重定义及屏蔽">重定义及屏蔽</a></h4>
<p>你不可以重复定义同一个变量，在使用<code>var</code>时，这是被允许的。</p>
<pre><code class="language-typescript">let x = 10;
let x = 20; // 错误，不能在1个作用域里多次声明`x`
</code></pre>
<p>以下情况，TypeScript均会报错</p>
<pre><code class="language-typescript">function f(x) {
    let x = 100; // error: interferes with parameter declaration
}

function g() {
    let x = 100;
    var x = 100; // error: can't have both declarations of 'x'
}
</code></pre>
<p>注意函数作用域和块作用域不同，你可以在函数作用域里嵌套块作用域，作用域之间的变量声明互不影响，同时，块作用域是允许嵌套的。</p>
<p>在一个嵌套作用域里引入一个新名字的行为称做<strong>屏蔽</strong>。 它是一把双刃剑，它可能会不小心地引入新问题，还可能会遮蔽掉一些错误。</p>
<pre><code class="language-typescript">function f(condition, x) {
    if (condition) {
        let x = 100;
        return x;
    }

    return x;
}

f(false, 0); // returns 0
f(true, 0);  // returns 100
</code></pre>
<h3 id="const声明"><a class="header" href="#const声明">const声明</a></h3>
<p><code>const</code>声明是声明变量的另一种方式。它们与let声明相似，但是就像它的名字所表达的，它们被赋值后不能再改变。 换句话说，它们拥有与 let相同的作用域规则，但是不能对它们重新赋值。</p>
<p>这很好理解，它们引用的值是不可变的。</p>
<pre><code class="language-typescript">const numLivesForCat = 9;
const kitty = {
    name: &quot;Aurora&quot;,
    numLives: numLivesForCat,
}

// Error
kitty = {
    name: &quot;Danielle&quot;,
    numLives: numLivesForCat
};

// all &quot;okay&quot;
kitty.name = &quot;Rory&quot;;
kitty.name = &quot;Kitty&quot;;
kitty.name = &quot;Cat&quot;;
kitty.numLives--;
</code></pre>
<p>除非你使用特殊的方法去避免，实际上const变量的内部状态是可修改的。</p>
<h2 id="访问设置对象的属性和方法"><a class="header" href="#访问设置对象的属性和方法">访问/设置对象的属性和方法</a></h2>
<hr />
<p>我们在前面已经看过很多对象的例子了，而且JavaScript的各种衍生类型都是基于Object构造出来的，所以本小节介绍的内容也同时适用数组、元组等数据类型。</p>
<h4 id="点表示法"><a class="header" href="#点表示法">点表示法</a></h4>
<p>对象的名字表现为一个命名空间(namespace)，它必须写在第一位——当你想访问对象内部的属性或方法时，然后是一个点<code>.</code>，紧接着是你想要访问的项目，标识可以是简单属性的名字(name)，或者是数组属性的一个子元素，又或者是对象的方法调用。</p>
<pre><code class="language-typescript">person.age
person.interests[1]
person.bio()
</code></pre>
<p>创建一个对象在TypeScript中非常简单，在赋值语句右侧使用形如<code>{}</code>的方式就能创建对象</p>
<pre><code class="language-typescript">const name = {
  first : 'Bob',
  last : 'Smith'
}
</code></pre>
<p>用点表示法访问对象属性</p>
<pre><code class="language-typescript">name.first
name.last
</code></pre>
<h4 id="中括号表示法"><a class="header" href="#中括号表示法">中括号表示法</a></h4>
<p>另外一种访问属性的方式是使用括号表示法(bracket notation)，替代这样的代码</p>
<pre><code class="language-typescript">person.age
person.name.first
</code></pre>
<pre><code class="language-typescript">person['age']
person['name']['first']
</code></pre>
<p>同样，创建一个数组也非常容易</p>
<pre><code class="language-typescript">const name = ['Bob', 'Smith']
</code></pre>
<p>用中括号表示法访问数组元素</p>
<pre><code class="language-typescript">name[0]
name[1]

// 数组或类数组格式的数据只能用括号表示法访问元素，不可以使用`name.0`方式访问
</code></pre>
<h4 id="设置对象成员"><a class="header" href="#设置对象成员">设置对象成员</a></h4>
<p>分别用点表示法和中括号表示法设置对象成员的值</p>
<pre><code class="language-typescript">person.age = 45
person['name']['last'] = 'Cratchit'
</code></pre>
<p>设置成员并不意味着你只能更新已经存在的属性的值，你完全可以创建新的成员，尝试以下代码：</p>
<pre><code class="language-typescript">person['eyes'] = 'hazel'
person.farewell = function() { alert(&quot;Bye everybody!&quot;) }
</code></pre>
<p>现在你可以测试你新创建的成员</p>
<pre><code class="language-typescript">person['eyes']
person.farewell()
</code></pre>
<h2 id="变量解构"><a class="header" href="#变量解构">变量解构</a></h2>
<hr />
<p>ES2015的变量解构参照了名为<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions">模式匹配</a>的设计模式，本质来说是一种便利的语法糖</p>
<h3 id="解构数组"><a class="header" href="#解构数组">解构数组</a></h3>
<p>最简单的解构莫过于数组的解构赋值了：</p>
<pre><code class="language-typescript">let input = [1, 2];
let [first, second] = input;
console.log(first); // outputs 1
console.log(second); // outputs 2
</code></pre>
<p>上面的例子等价于</p>
<pre><code class="language-typescript">first = input[0];
second = input[1];
</code></pre>
<p>作用于函数参数：</p>
<pre><code class="language-typescript">function f([first, second]: [number, number]) { // 注意后面部分[number, number]是typescript的类型注解
    console.log(first);
    console.log(second);
}

const input = [12, 44]

f(input);
</code></pre>
<p>你可以在数组里使用<code>...</code>语法创建剩余变量：</p>
<pre><code class="language-typescript">let [first, ...rest] = [1, 2, 3, 4];
console.log(first); // outputs 1
console.log(rest); // outputs [ 2, 3, 4 ]
</code></pre>
<p>当然，由于是JavaScript, 你可以忽略你不关心的尾随元素：</p>
<pre><code class="language-typescript">let [first] = [1, 2, 3, 4];
console.log(first); // outputs 1
</code></pre>
<p>或其它元素：</p>
<pre><code class="language-typescript">let [, second, , fourth] = [1, 2, 3, 4];
</code></pre>
<h3 id="对象解构"><a class="header" href="#对象解构">对象解构</a></h3>
<p>你也可以解构对象：</p>
<pre><code class="language-typescript">let o = {
    a: &quot;foo&quot;,
    b: 12,
    c: &quot;bar&quot;
};
let { a, b } = o;
</code></pre>
<p>你可以在对象里使用<code>...</code>语法创建剩余变量：</p>
<pre><code class="language-typescript">let { a, ...passthrough } = o;
let total = passthrough.b + passthrough.c.length;
</code></pre>
<p>你也可以给属性以不同的名字：</p>
<pre><code class="language-typescript">let { a: newName1, b: newName2 } = o;
</code></pre>
<p>这里的语法开始有些混乱。 你可以将 <code>a: newName1</code> 读做讲 &quot;a&quot; 取出作为 &quot;newName1&quot;。 方向是从左到右，好像你写成了以下样子：</p>
<pre><code class="language-typescript">let newName1 = o.a;
let newName2 = o.b;
</code></pre>
<p>令你困惑的可能是=这里的冒号不是指示类型的，我们前面说，以冒号后跟的是<em>类型注解</em>。 如果你想指定它的类型，仍然需要在其后写上完整的模式。</p>
<pre><code class="language-typescript">// 正确
let {a, b}: {a: string, b: number} = o;
// 错误
let {a: n1, b: n2}: {n1: string, n2: number} = o;
</code></pre>
<h3 id="默认值"><a class="header" href="#默认值">默认值</a></h3>
<p>默认值可以让你在属性为 undefined 时使用缺省值：</p>
<pre><code class="language-typescript">function keepWholeObject(wholeObject: { a: string, b?: number }) {
    let { a, b = 1001 } = wholeObject;
}
</code></pre>
<p>现在，即使 <code>b</code> 为 <code>undefined</code> ， keepWholeObject 函数的变量 <code>wholeObject</code> 的属性 a 和 b 都会有值。</p>
<h3 id="函数声明"><a class="header" href="#函数声明">函数声明</a></h3>
<p>解构也能用于函数声明。 看以下简单的情况：</p>
<pre><code class="language-typescript">
type C = { a: string, b?: number }
// 普通写法
function f(C) {
    // ...
}
// 解构
function f({ a, b }: C): void {
    // ...
}
</code></pre>
<h3 id="变量展开"><a class="header" href="#变量展开">变量展开</a></h3>
<p>展开操作符正与解构相反。 它允许你将一个数组展开为另一个数组，或将一个对象展开为另一个对象。 例如：</p>
<pre><code class="language-typescript">let first = [1, 2];
let second = [3, 4];
let bothPlus = [0, ...first, ...second, 5];
</code></pre>
<p>这会令bothPlus的值为<code>[0, 1, 2, 3, 4, 5]</code>。 展开操作创建了 first和second的一份<strong>浅拷贝</strong>。 它们不会被展开操作所改变。</p>
<p>你还可以展开对象：</p>
<pre><code class="language-typescript">let defaults = { food: &quot;spicy&quot;, price: &quot;$$&quot;, ambiance: &quot;noisy&quot; };
let search = { ...defaults, food: &quot;rich&quot; };
</code></pre>
<p>search的值为<code>{ food: &quot;rich&quot;, price: &quot;$$&quot;, ambiance: &quot;noisy&quot; }</code>。 对象的展开比数组的展开要复杂的多。 像数组展开一样，它是从左至右进行处理，但结果仍为对象。 这就意味着出现在<strong>展开对象后面的属性会覆盖前面的属性</strong>。 因此，如果我们修改上面的例子，在结尾处进行展开的话：</p>
<pre><code class="language-typescript">let defaults = { food: &quot;spicy&quot;, price: &quot;$$&quot;, ambiance: &quot;noisy&quot; };
let search = { food: &quot;rich&quot;, ...defaults };
</code></pre>
<p>那么，defaults里的food属性会重写<code>food: &quot;rich&quot;</code>，在这里这并不是我们想要的结果。</p>
<h2 id="下一步"><a class="header" href="#下一步">下一步</a></h2>
<ul>
<li><a href="preknowledge//preknowledge/class.html">类</a> - 进一步了解TypeScript所规定的类</li>
<li><a href="preknowledge//preknowledge/generics-and-modules.html">泛型和命名空间</a> - 进一步了解TypeScript所规定的语法</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="类"><a class="header" href="#类">类</a></h1>
<p>传统的JavaScript程序使用<strong>函数</strong>和基于<strong>原型</strong>的继承来创建可重用的组件。Typescript则在此基础上加入了语法糖<strong>类</strong>。</p>
<p>了解Javascript的基础内容请参考<a href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Objects/Object_prototypes">对象原型</a>。</p>
<h2 id="声明类"><a class="header" href="#声明类">声明类</a></h2>
<p>我们首先来看一个例子</p>
<pre><code class="language-typescript">class Greeter {
    greeting: string;
    constructor(message: string) {
        this.greeting = message;
    }
    greet() {
        return &quot;Hello, &quot; + this.greeting;
    }
}

let greeter = new Greeter(&quot;world&quot;);
</code></pre>
<p>如果你使用过C#或Java，你会对这种语法非常熟悉。 我们声明一个 Greeter类。这个类有3个成员：一个叫做 greeting的属性，一个构造函数和一个 greet方法。</p>
<p>你会注意到，我们在引用任何一个类成员的时候都用了 this。 它表示我们访问的是类的成员。</p>
<p>最后一行，我们使用 new构造了 Greeter类的一个实例。 它会调用之前定义的构造函数，创建一个 Greeter类型的新对象，并执行构造函数初始化它。</p>
<h2 id="继承"><a class="header" href="#继承">继承</a></h2>
<p>在TypeScript里，我们可以使用常用的面向对象模式。 基于类的程序设计中一种最基本的模式是允许使用继承来扩展现有的类。</p>
<p>看下面的例子：</p>
<pre><code class="language-typescript">class Animal {
    move(distance: number = 0) {
        console.log(`Animal moved ${distance}m.`);
    }
}

class Dog extends Animal {
    bark() {
        console.log('Woof! Woof!');
    }
}

const dog = new Dog();
dog.bark();
dog.move(10);
dog.bark();
</code></pre>
<p>这个例子展示了最基本的继承：类从基类中继承了属性和方法。这里，<code>Dog</code>是一个 <em>派生类</em>，通过 <code>extends</code>关键字使它从 <code>Animal</code> 基类中派生出来。 派生类通常被称作 子类，基类通常被称作 超类或父类。</p>
<p>因为 Dog继承了 Animal的功能，因此我们可以创建一个 Dog的实例，它能够 bark()和 move()。</p>
<p>下面我们来看个更加复杂的例子。</p>
<pre><code class="language-typescript">class Animal {
    name: string;
    constructor(theName: string) { this.name = theName; }

    move(distance: number = 0) {
        console.log(`${this.name} moved ${distance}m.`);
    }
}

class Snake extends Animal {
    constructor(name: string) { super(name); }

    move(distance = 5) {
        console.log(&quot;Slithering...&quot;);
        super.move(distance);
    }
}

class Horse extends Animal {
    constructor(name: string) { super(name); }

    move(distance = 45) {
        console.log(&quot;Galloping...&quot;);
        super.move(distance);
    }
}

let sam = new Snake(&quot;Sammy the Python&quot;);
let tom: Animal = new Horse(&quot;Tommy the Palomino&quot;);

sam.move();
tom.move(34);
</code></pre>
<p>与前一个例子的不同点是，这次两个派生类包含了一个构造函数，它<strong>必须调用 <code>super()</code></strong>，它会执行基类的构造函数。 而且，在构造函数里访问 this的属性之前，我们 <strong>必须</strong>要调用 super()，这个是TypeScript强制规定的。</p>
<h2 id="修饰符"><a class="header" href="#修饰符">修饰符</a></h2>
<h4 id="public"><a class="header" href="#public">public</a></h4>
<p>如果你对其它语言中的类比较了解，就会注意到我们在之前的代码里并没有使用 <code>public</code>来做修饰；例如，C#要求必须明确地使用 <code>public</code>指定成员是可见的。 在TypeScript里，成员都默认为 <code>public</code>。在上面的例子里，我们可以自由的访问程序里定义的成员。</p>
<h4 id="private"><a class="header" href="#private">private</a></h4>
<p>当成员被标记成 <code>private</code>时，它就不能在声明它的类的外部访问。比如</p>
<pre><code class="language-typescript">class Animal {
    private name: string;
    constructor(theName: string) { this.name = theName; }
}

new Animal(&quot;Cat&quot;).name; // 错误: 'name' 是私有的.
</code></pre>
<h4 id="protected"><a class="header" href="#protected">protected</a></h4>
<p>protected修饰符与 private修饰符的行为很相似，但有一点不同， protected成员在派生类中仍然可以访问。</p>
<pre><code class="language-typescript">class Person {
    protected name: string;
    constructor(name: string) { this.name = name; }
}

class Employee extends Person {
    private department: string;

    constructor(name: string, department: string) {
        super(name)
        this.department = department;
    }

    public getElevatorPitch() {
        return `Hello, my name is ${this.name} and I work in ${this.department}.`;
    }
}

let howard = new Employee(&quot;Howard&quot;, &quot;Sales&quot;);
console.log(howard.getElevatorPitch());
console.log(howard.name); // 错误
</code></pre>
<p>注意，我们不能在 <code>Person</code>类外使用 <code>name</code>，但是我们仍然可以通过 <code>Employee</code>类的<strong>实例方法</strong>访问，因为 <code>Employee</code>是由 <code>Person</code>派生而来的。</p>
<h4 id="readonly"><a class="header" href="#readonly">readonly</a></h4>
<p>你可以使用 <code>readonly</code>关键字将属性设置为只读的。 只读属性必须在声明时或构造函数里被初始化。</p>
<pre><code class="language-typescript">class Octopus {
    readonly name: string;
    readonly numberOfLegs: number = 8;
    constructor (theName: string) {
        this.name = theName;
    }
}
let dad = new Octopus(&quot;Man with the 8 strong legs&quot;);
dad.name = &quot;Man with the 3-piece suit&quot;; // 错误! name 是只读的.
</code></pre>
<h4 id="getset"><a class="header" href="#getset">get/set</a></h4>
<p>TypeScript支持通过<code>getters/setters</code>来截取对对象成员的访问。 它能帮助你有效的控制对对象成员的访问。</p>
<p>下面来看如何把一个简单的类改写成使用 <code>get</code>和 <code>set</code>。 首先，我们从一个没有使用存取器的例子开始。</p>
<pre><code class="language-typescript">class Employee {
    fullName: string;
}

let employee = new Employee();
employee.fullName = &quot;Bob Smith&quot;;
if (employee.fullName) {
    console.log(employee.fullName);
}
</code></pre>
<p>下面这个版本里，我们先检查用户密码是否正确，然后再允许其修改员工信息。 我们把对 <code>fullName</code>的直接访问改成了可以检查密码的 set方法。 我们也加了一个 get方法，让上面的例子仍然可以工作。</p>
<pre><code class="language-typescript">let passcode = &quot;secret passcode&quot;;

class Employee {
    private _fullName: string;

    get fullName(): string {
        return this._fullName;
    }

    set fullName(newName: string) {
        if (passcode &amp;&amp; passcode == &quot;secret passcode&quot;) {
            this._fullName = newName;
        }
        else {
            console.log(&quot;Error: Unauthorized update of employee!&quot;);
        }
    }
}

let employee = new Employee();
employee.fullName = &quot;Bob Smith&quot;;
if (employee.fullName) {
    alert(employee.fullName);
}
</code></pre>
<h4 id="static"><a class="header" href="#static">static</a></h4>
<p>到目前为止，我们只讨论了类的实例成员，那些仅当类被实例化的时候才会被初始化的属性。 我们也可以创建类的静态成员，这些属性存在于类本身上面而不是类的实例上。</p>
<pre><code class="language-typescript">class Router {
    static baseRoute = '/basePath';
    calculateRoute(path: string) {
        return Router.baseRoute + this.commonPrefix  + path;
    }
    constructor (public commonPrefix: string) { }
}

let route1 = new Router('/api');  // 一级路径为/api
let route2 = new Router('/page');  // 一级路径为/page

console.log(route1.calculateRoute('/main'));  // 最终路径/basePath/api/main
console.log(route2.calculateRoute('/user'));  // 最终路径/basePath/page/user
</code></pre>
<h4 id="abstract"><a class="header" href="#abstract">abstract</a></h4>
<p>抽象类做为其它派生类的基类使用。 它们一般不会直接被实例化。 不同于接口，抽象类可以包含成员的实现细节。 <code>abstract</code>关键字是用于定义抽象类和在抽象类内部定义抽象方法。</p>
<pre><code class="language-typescript">abstract class Animal {
    abstract makeSound(): void;
    move(): void {
        console.log('roaming the earch...');
    }
}
</code></pre>
<h2 id="下一步-1"><a class="header" href="#下一步-1">下一步</a></h2>
<ul>
<li><a href="preknowledge//preknowledge/interface-and-namespace">接口和命名空间</a> -  进一步了解Typescript所规定的语法</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="认识typescript-类型接口和命名空间"><a class="header" href="#认识typescript-类型接口和命名空间">认识TypeScript-类型接口和命名空间</a></h1>
<p>TypeScript的核心原则之一是对数据的结构进行类型检查。 它有时被称做“鸭式辨型法”或“结构性子类型化”。 在TypeScript里，<strong>接口</strong>的作用就是为这些类型命名和为你的代码或第三方代码定义<strong>契约</strong>。</p>
<h2 id="接口"><a class="header" href="#接口">接口</a></h2>
<hr />
<h3 id="接口初探"><a class="header" href="#接口初探">接口初探</a></h3>
<p>下面通过一个简单示例来观察接口是如何工作的：</p>
<pre><code class="language-typescript">function printLabel(labelledObj: { label: string }) {
  console.log(labelledObj.label);
}

let myObj = { size: 10, label: &quot;Size 10 Object&quot; };
printLabel(myObj);
</code></pre>
<p>类型检查器会检查<code>printLabel</code>的调用。 <code>printLabel</code>有一个参数，并要求这个对象参数有一个名为<code>label</code>类型为<code>string</code>的属性。 需要注意的是，我们传入的对象参数实际上会包含很多属性，但是编译器只会检查那些必需的属性是否存在，并且其类型是否匹配。 然而，有些时候TypeScript却并不会这么宽松，我们下面会稍做讲解。</p>
<p>下面我们重写上面的例子，这次使用接口来描述：必须包含一个<code>label</code>属性且类型为<code>string</code>：</p>
<pre><code class="language-typescript">interface LabelledValue {
  label: string;
}

function printLabel(labelledObj: LabelledValue) {
  console.log(labelledObj.label);
}

let myObj = {size: 10, label: &quot;Size 10 Object&quot;};
printLabel(myObj);
</code></pre>
<p><code>LabelledValue</code>接口就好比一个名字，用来描述上面例子里的要求。 它代表了有一个 <code>label</code>属性且类型为<code>string</code>的对象。 需要注意的是，我们在这里并不能像在其它语言里一样，说传给 <code>printLabel</code>的对象实现了这个接口。我们只会去关注值的外形。 只要传入的对象满足上面提到的必要条件，那么它就是被允许的。</p>
<p>还有一点值得提的是，类型检查器不会去检查属性的顺序，只要相应的属性存在并且类型也是对的就可以。</p>
<h3 id="可选属性"><a class="header" href="#可选属性">可选属性</a></h3>
<p>接口里的属性不全都是必需的。 有些是只在某些条件下存在，或者根本不存在。 可选属性在应用“option bags”模式时很常用，即给函数传入的参数对象中只有部分属性赋值了。</p>
<p>下面是应用了“option bags”的例子：</p>
<pre><code class="language-typescript">interface SquareConfig {
  color?: string;
  width?: number;
}

function createSquare(config: SquareConfig): {color: string; area: number} {
  let newSquare = {color: &quot;white&quot;, area: 100};
  if (config.color) {
    newSquare.color = config.color;
  }
  if (config.width) {
    newSquare.area = config.width * config.width;
  }
  return newSquare;
}

let mySquare = createSquare({color: &quot;black&quot;});
</code></pre>
<p>带有可选属性的接口与普通的接口定义差不多，只是在可选属性名字定义的后面加一个<code>?</code>符号。</p>
<p>可选属性的好处之一是可以对可能存在的属性进行预定义，好处之二是可以捕获引用了不存在的属性时的错误。 比如，我们故意将 createSquare里的color属性名拼错，就会得到一个错误提示：</p>
<pre><code class="language-typescript">interface SquareConfig {
  color?: string;
  width?: number;
}

function createSquare(config: SquareConfig): { color: string; area: number } {
  let newSquare = {color: &quot;white&quot;, area: 100};
  if (config.clor) {
    // Error: Property 'clor' does not exist on type 'SquareConfig'
    newSquare.color = config.clor;
  }
  if (config.width) {
    newSquare.area = config.width * config.width;
  }
  return newSquare;
}

let mySquare = createSquare({color: &quot;black&quot;});
</code></pre>
<h3 id="只读属性"><a class="header" href="#只读属性">只读属性</a></h3>
<p>一些对象属性只能在对象刚刚创建的时候修改其值。 你可以在属性名前用 readonly来指定只读属性:</p>
<pre><code class="language-typescript">interface Point {
    readonly x: number;
    readonly y: number;
}
</code></pre>
<p>你可以通过赋值一个对象字面量来构造一个Point。 赋值后， x和y再也不能被改变了。</p>
<pre><code class="language-typescript">let p1: Point = { x: 10, y: 20 };
p1.x = 5; // error!
</code></pre>
<p>TypeScript具有<code>ReadonlyArray&lt;T&gt;</code>类型，它与<code>Array&lt;T&gt;</code>相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改：</p>
<pre><code class="language-typescript">let a: number[] = [1, 2, 3, 4];
let ro: ReadonlyArray&lt;number&gt; = a;
ro[0] = 12; // error!
ro.push(5); // error!
ro.length = 100; // error!
a = ro; // error!
</code></pre>
<p>上面代码的最后一行，可以看到就算把整个ReadonlyArray赋值到一个普通数组也是不可以的。 但是你可以用类型断言重写：</p>
<pre><code class="language-typescript">a = ro as number[];
</code></pre>
<h4 id="readonly-vs-const"><a class="header" href="#readonly-vs-const">readonly vs const</a></h4>
<p>最简单判断该用<strong>readonly</strong>还是<strong>const</strong>的方法是看要把它做为变量使用还是做为一个属性。 做为变量使用的话用 const，若做为属性则使用readonly。</p>
<h3 id="额外的属性检查"><a class="header" href="#额外的属性检查">额外的属性检查</a></h3>
<p>我们在第一个例子里使用了接口，TypeScript让我们传入<code>{ size: number; label: string; }</code>到仅期望得到<code>{ label: string; }</code>的函数里。 我们已经学过了可选属性，并且知道他们在“option bags”模式里很有用。</p>
<p>然而，天真地将这两者结合的话就会像在JavaScript里那样搬起石头砸自己的脚。 比如，拿<code>createSquare</code>例子来说：</p>
<pre><code class="language-typescript">interface SquareConfig {
    color?: string;
    width?: number;
}

function createSquare(config: SquareConfig): { color: string; area: number } {
    // ...
}

let mySquare = createSquare({ colour: &quot;red&quot;, width: 100 });
</code></pre>
<p>注意传入<code>createSquare</code>的参数拼写为<code>colour</code>而不是<code>color</code>。 在JavaScript里，这会导致静默失败。</p>
<p>你可能会争辩这个程序已经正确地类型化了，因为width属性是兼容的，不存在<code>color</code>属性，而且额外的<code>colour</code>属性是无意义的。</p>
<p>然而，TypeScript会认为这段代码可能存在bug。 对象字面量会被特殊对待而且会经过 额外属性检查，当将它们赋值给变量或作为参数传递的时候。 如果一个对象字面量存在任何“目标类型”不包含的属性时，你会得到一个错误。</p>
<pre><code class="language-typescript">// error: 'colour' not expected in type 'SquareConfig'
let mySquare = createSquare({ colour: &quot;red&quot;, width: 100 });
</code></pre>
<p>绕开这些检查非常简单。 最简便的方法是使用类型断言：</p>
<pre><code class="language-typescript">let mySquare = createSquare({ width: 100, opacity: 0.5 } as SquareConfig);
</code></pre>
<p>然而，最佳的方式是能够添加一个字符串索引签名，前提是你能够确定这个对象可能具有某些做为特殊用途使用的额外属性。 如果 <code>SquareConfig</code>带有上面定义的类型的<code>color</code>和<code>width</code>属性，并且还会带有任意数量的其它属性，那么我们可以这样定义它：</p>
<pre><code class="language-typescript">interface SquareConfig {
    color?: string;
    width?: number;
    [propName: string]: any;
}
</code></pre>
<p>我们稍后会讲到索引签名，但在这我们要表示的是<code>SquareConfig</code>可以有任意数量的属性，并且只要它们不是<code>color</code>和<code>width</code>，那么就无所谓它们的类型是什么。</p>
<p>还有最后一种跳过这些检查的方式，这可能会让你感到惊讶，它就是将这个对象赋值给一个另一个变量： 因为 <code>squareOptions</code>不会经过额外属性检查，所以编译器不会报错。</p>
<pre><code class="language-typescript">let squareOptions = { colour: &quot;red&quot;, width: 100 };
let mySquare = createSquare(squareOptions);
</code></pre>
<p>要留意，在像上面一样的简单代码里，你可能不应该去绕开这些检查。 对于包含方法和内部状态的复杂对象字面量来讲，你可能需要使用这些技巧，但是大部额外属性检查错误是真正的bug。 就是说你遇到了额外类型检查出的错误，比如“option bags”，你应该去审查一下你的类型声明。 在这里，如果支持传入 <code>color</code>或<code>colour</code>属性到<code>createSquare</code>，你应该修改<code>SquareConfig</code>定义来体现出这一点。</p>
<h3 id="函数类型"><a class="header" href="#函数类型">函数类型</a></h3>
<p>接口能够描述JavaScript中对象拥有的各种各样的外形。 除了描述带有属性的普通对象外，接口也可以描述函数类型。</p>
<p>为了使用接口表示函数类型，我们需要给接口定义一个调用签名。 它就像是一个只有参数列表和返回值类型的函数定义。参数列表里的每个参数都需要名字和类型。</p>
<pre><code class="language-typescript">interface SearchFunc {
  (source: string, subString: string): boolean;
}
</code></pre>
<p>这样定义后，我们可以像使用其它接口一样使用这个函数类型的接口。下例展示了如何创建一个函数类型的变量，并将一个同类型的函数赋值给这个变量。</p>
<pre><code class="language-typescript">let mySearch: SearchFunc;
mySearch = function(source: string, subString: string) {
  let result = source.search(subString);
  return result &gt; -1;
}
</code></pre>
<p>对于函数类型的类型检查来说，函数的参数名不需要与接口里定义的名字相匹配。 比如，我们使用下面的代码重写上面的例子：</p>
<pre><code class="language-typescript">let mySearch: SearchFunc;
mySearch = function(src: string, sub: string): boolean {
  let result = src.search(sub);
  return result &gt; -1;
}
</code></pre>
<p>函数的参数会<strong>逐个进行检查</strong>，要求<strong>对应位置上的参数类型是兼容的</strong>。 如果你不想指定类型，TypeScript的类型系统会推断出参数类型，因为函数直接赋值给了 <code>SearchFunc</code>类型变量。 函数的返回值类型是通过其返回值推断出来的（此例是 false和true）。 如果让这个函数返回数字或字符串，类型检查器会警告我们函数的返回值类型与 <code>SearchFunc</code>接口中的定义不匹配。</p>
<pre><code class="language-typescript">let mySearch: SearchFunc;
mySearch = function(src, sub) {
    let result = src.search(sub);
    return result &gt; -1;
}
</code></pre>
<h3 id="可索引的类型"><a class="header" href="#可索引的类型">可索引的类型</a></h3>
<p>与使用接口描述函数类型差不多，我们也可以描述那些能够“通过索引得到”的类型，比如<code>a[10]</code>或<code>ageMap[&quot;daniel&quot;]</code>。 可索引类型具有一个 <em>索引签名</em>，它描述了对象索引的类型，还有相应的索引返回值类型。 让我们看一个例子：</p>
<pre><code class="language-typescript">interface StringArray {
  [index: number]: string;
}

let myArray: StringArray;
myArray = [&quot;Bob&quot;, &quot;Fred&quot;];

let myStr: string = myArray[0];
</code></pre>
<p>上面例子里，我们定义了<code>StringArray</code>接口，它具有索引签名。 这个索引签名表示了当用 <code>number</code>去索引<code>StringArray</code>时会得到<code>string</code>类型的返回值。</p>
<p>TypeScript支持两种索引签名：字符串和数字。 可以同时使用两种类型的索引，但是数字索引的返回值必须是字符串索引返回值类型的子类型。 这是因为当使用 <code>number</code>来索引时，JavaScript会将它转换成<code>string</code>然后再去索引对象。 也就是说用 100（一个<code>number</code>）去索引等同于使用&quot;100&quot;（一个<code>string</code>）去索引，因此两者需要保持一致。</p>
<pre><code class="language-typescript">class Animal {
    name: string;
}
class Dog extends Animal {
    breed: string;
}

// 错误：使用数值型的字符串索引，有时会得到完全不同的Animal!
interface NotOkay {
    [x: number]: Animal;
    [x: string]: Dog;
}
</code></pre>
<p>字符串索引签名能够很好的描述dictionary模式，并且它们也会确保所有属性与其返回值类型相匹配。 因为字符串索引声明了 <code>obj.property</code>和<code>obj[&quot;property&quot;]</code>两种形式都可以。 下面的例子里， name的类型与字符串索引类型不匹配，所以类型检查器给出一个错误提示：</p>
<pre><code class="language-typescript">interface NumberDictionary {
  [index: string]: number;
  length: number;    // 可以，length是number类型
  name: string       // 错误，`name`的类型与索引类型返回值的类型不匹配
}
</code></pre>
<p>最后，你可以将索引签名设置为只读，这样就防止了给索引赋值：</p>
<pre><code class="language-typescript">interface ReadonlyStringArray {
    readonly [index: number]: string;
}
let myArray: ReadonlyStringArray = [&quot;Alice&quot;, &quot;Bob&quot;];
myArray[2] = &quot;Mallory&quot;; // error!
</code></pre>
<p>你不能设置<code>myArray[2]</code>，因为索引签名是只读的。</p>
<h3 id="类类型"><a class="header" href="#类类型">类类型</a></h3>
<p>与C#或Java里接口的基本作用一样，TypeScript也能够用它来明确或强制一个类去符合某种契约。</p>
<pre><code class="language-typescript">interface ClockInterface {
    currentTime: Date;
}

class Clock implements ClockInterface {
    currentTime: Date;
    constructor(h: number, m: number) { }
}
</code></pre>
<p>你也可以在接口中描述一个方法，在类里实现它，如同下面的<code>setTime</code>方法一样：</p>
<pre><code class="language-typescript">interface ClockInterface {
    currentTime: Date;
    setTime(d: Date);
}

class Clock implements ClockInterface {
    currentTime: Date;
    setTime(d: Date) {
        this.currentTime = d;
    }
    constructor(h: number, m: number) { }
}
</code></pre>
<p>接口描述了类的公共部分，而不是公共和私有两部分。 它不会帮你检查类是否具有某些私有成员。</p>
<h3 id="类的静态部分和实例部分"><a class="header" href="#类的静态部分和实例部分">类的静态部分和实例部分</a></h3>
<p>当你在类上面使用接口时，你需要注意一个<strong>类</strong>是由两部分构成的：类的静态部分和实例部分。如果你的接口上面声明了构造器签名，然后将这个接口应用在类上，你会看到报错：</p>
<pre><code class="language-typescript">interface ClockConstructor {
    new (hour: number, minute: number);
}

class Clock implements ClockConstructor {
    currentTime: Date;
    constructor(h: number, m: number) { }
}
</code></pre>
<p>这是因为一个类实现某个接口时，接口只检查<strong>类</strong>的实例部分，而<code>constructor</code>构造器方法是类的静态部分，因此它不包含在类型检查之内。</p>
<p>所以，我们其实只要直接操作类的静态部分就可以了。在下述例子中，我们定义2个接口，一个<code>ClockConstructor</code>给构造器使用，一个<code>ClockInterface</code>供实例方法使用。方便起见，我们再定义一个构造器函数<code>createClock</code>：</p>
<pre><code class="language-typescript">interface ClockConstructor {
    new (hour: number, minute: number): ClockInterface;
}
interface ClockInterface {
    tick(): void;
}

function createClock(ctor: ClockConstructor, hour: number, minute: number): ClockInterface {
    return new ctor(hour, minute);
}

class DigitalClock implements ClockInterface {
    constructor(h: number, m: number) { }
    tick() {
        console.log(&quot;beep beep&quot;);
    }
}
class AnalogClock implements ClockInterface {
    constructor(h: number, m: number) { }
    tick() {
        console.log(&quot;tick tock&quot;);
    }
}

</code></pre>
<p>因为<code>createClock</code>的第一个参数是<code>ClockConstructor</code>类型，在<code>createClock(AnalogClock, 7, 32)</code>里，会检查<code>AnalogClock</code>是否符合构造函数签名。</p>
<h3 id="接口继承"><a class="header" href="#接口继承">接口继承</a></h3>
<p>和类一样，接口也可以相互继承。 这让我们能够从一个接口里复制成员到另一个接口里，可以更灵活地将接口分割到可重用的模块里。</p>
<pre><code class="language-typescript">interface Shape {
    color: string;
}

interface Square extends Shape {
    sideLength: number;
}

let square = &lt;Square&gt;{};
square.color = &quot;blue&quot;;
square.sideLength = 10;
</code></pre>
<p>一个接口可以继承多个接口，创建出多个接口的合成接口。</p>
<pre><code class="language-typescript">interface Shape {
    color: string;
}

interface PenStroke {
    penWidth: number;
}

interface Square extends Shape, PenStroke {
    sideLength: number;
}

let square = &lt;Square&gt;{};
square.color = &quot;blue&quot;;
square.sideLength = 10;
square.penWidth = 5.0;
</code></pre>
<h3 id="混合类型"><a class="header" href="#混合类型">混合类型</a></h3>
<p>先前我们提过，接口能够描述JavaScript里丰富的类型。 因为JavaScript其动态灵活的特点，有时你会希望一个对象可以同时具有上面提到的多种类型。</p>
<p>一个例子就是，一个对象可以同时做为函数和对象使用，并带有额外的属性。</p>
<pre><code class="language-typescript">interface Counter {
    (start: number): string;
    interval: number;
    reset(): void;
}

function getCounter(): Counter {
    let counter = &lt;Counter&gt;function (start: number) { };
    counter.interval = 123;
    counter.reset = function () { };
    return counter;
}

let c = getCounter();
c(10);
c.reset();
c.interval = 5.0;
</code></pre>
<h2 id="命名空间"><a class="header" href="#命名空间">命名空间</a></h2>
<hr />
<h3 id="第一步"><a class="header" href="#第一步">第一步</a></h3>
<p>我们先来写一段程序并将在整篇文章中都使用这个例子。 我们定义几个简单的字符串验证器，假设你会使用它们来验证表单里的用户输入或验证外部数据。</p>
<p>所有的验证器都放在一个文件里：</p>
<pre><code class="language-typescript">interface StringValidator {
    isAcceptable(s: string): boolean;
}

let lettersRegexp = /^[A-Za-z]+$/;
let numberRegexp = /^[0-9]+$/;

class LettersOnlyValidator implements StringValidator {
    isAcceptable(s: string) {
        return lettersRegexp.test(s);
    }
}

class ZipCodeValidator implements StringValidator {
    isAcceptable(s: string) {
        return s.length === 5 &amp;&amp; numberRegexp.test(s);
    }
}

// 一个使用例子
let strings = [&quot;Hello&quot;, &quot;98052&quot;, &quot;101&quot;];

// 可以使用的校验器
let validators: { [s: string]: StringValidator; } = {};
validators[&quot;ZIP code&quot;] = new ZipCodeValidator();
validators[&quot;Letters only&quot;] = new LettersOnlyValidator();

// 每个strings是否都能找到对应的校验器
for (let s of strings) {
    for (let name in validators) {
        let isMatch = validators[name].isAcceptable(s);
        console.log(`'${ s }' ${ isMatch ? &quot;matches&quot; : &quot;does not match&quot; } '${ name }'.`);
    }
}
</code></pre>
<h3 id="命名空间-1"><a class="header" href="#命名空间-1">命名空间</a></h3>
<p>随着更多验证器的加入，我们需要一种手段来组织代码，以便于在记录它们类型的同时还不用担心与其它对象产生命名冲突。 因此，我们把验证器包裹到一个命名空间内，而不是把它们放在全局命名空间下。</p>
<p>下面的例子里，把所有与验证器相关的类型都放到一个叫做<code>Validation</code>的命名空间里。 因为我们想让这些接口和类在命名空间之外也是可访问的，所以需要使用<code>export</code>。 相反的，变量 <code>lettersRegexp</code>和<code>numberRegexp</code>是实现的细节，不需要导出，因此它们在命名空间外是不能访问的。 在文件末尾的测试代码里，由于是在命名空间之外访问，因此需要限定类型的名称，比如 <code>Validation.LettersOnlyValidator</code>。</p>
<p>使用命名空间的验证器:</p>
<pre><code class="language-typescript">namespace Validation {
    export interface StringValidator {
        isAcceptable(s: string): boolean;
    }

    const lettersRegexp = /^[A-Za-z]+$/;
    const numberRegexp = /^[0-9]+$/;

    export class LettersOnlyValidator implements StringValidator {
        isAcceptable(s: string) {
            return lettersRegexp.test(s);
        }
    }

    export class ZipCodeValidator implements StringValidator {
        isAcceptable(s: string) {
            return s.length === 5 &amp;&amp; numberRegexp.test(s);
        }
    }
}

// 一个例子
let strings = [&quot;Hello&quot;, &quot;98052&quot;, &quot;101&quot;];

let validators: { [s: string]: Validation.StringValidator; } = {};
validators[&quot;ZIP code&quot;] = new Validation.ZipCodeValidator();
validators[&quot;Letters only&quot;] = new Validation.LettersOnlyValidator();

for (let s of strings) {
    for (let name in validators) {
        console.log(`&quot;${ s }&quot; - ${ validators[name].isAcceptable(s) ? &quot;matches&quot; : &quot;does not match&quot; } ${ name }`);
    }
}
</code></pre>
<h3 id="分离文件"><a class="header" href="#分离文件">分离文件</a></h3>
<p>当应用变得越来越大时，我们需要将代码分离到不同的文件中以便于维护。</p>
<p>现在，我们把<code>Validation</code>命名空间分割成多个文件。 尽管是不同的文件，它们仍是同一个命名空间，并且在使用的时候就如同它们在一个文件中定义的一样。 因为不同文件之间存在依赖关系，所以我们加入了引用标签来告诉编译器文件之间的关联。 我们的测试代码保持不变。</p>
<p><code>Validation.ts</code></p>
<pre><code class="language-typescript">namespace Validation {
    export interface StringValidator {
        isAcceptable(s: string): boolean;
    }
}
</code></pre>
<p><code>LettersOnlyValidator.ts</code></p>
<pre><code class="language-typescript">/// &lt;reference path=&quot;Validation.ts&quot; /&gt;
namespace Validation {
    const lettersRegexp = /^[A-Za-z]+$/;
    export class LettersOnlyValidator implements StringValidator {
        isAcceptable(s: string) {
            return lettersRegexp.test(s);
        }
    }
}
</code></pre>
<p><code>ZipCodeValidator.ts</code></p>
<pre><code class="language-typescript">/// &lt;reference path=&quot;Validation.ts&quot; /&gt;
namespace Validation {
    const numberRegexp = /^[0-9]+$/;
    export class ZipCodeValidator implements StringValidator {
        isAcceptable(s: string) {
            return s.length === 5 &amp;&amp; numberRegexp.test(s);
        }
    }
}
</code></pre>
<p><code>Test.ts</code></p>
<pre><code class="language-typescript">/// &lt;reference path=&quot;Validation.ts&quot; /&gt;
/// &lt;reference path=&quot;LettersOnlyValidator.ts&quot; /&gt;
/// &lt;reference path=&quot;ZipCodeValidator.ts&quot; /&gt;

// Some samples to try
let strings = [&quot;Hello&quot;, &quot;98052&quot;, &quot;101&quot;];

// Validators to use
let validators: { [s: string]: Validation.StringValidator; } = {};
validators[&quot;ZIP code&quot;] = new Validation.ZipCodeValidator();
validators[&quot;Letters only&quot;] = new Validation.LettersOnlyValidator();

// Show whether each string passed each validator
for (let s of strings) {
    for (let name in validators) {
        console.log(`&quot;${ s }&quot; - ${ validators[name].isAcceptable(s) ? &quot;matches&quot; : &quot;does not match&quot; } ${ name }`);
    }
}
</code></pre>
<p>当涉及到多文件时，我们必须确保所有编译后的代码都被加载了。 我们有两种方式。</p>
<p>第一种方式，把所有的输入文件编译为一个输出文件，需要使用--outFile标记：</p>
<pre><code class="language-bash">tsc --outFile sample.js Test.ts
</code></pre>
<p>编译器会根据源码里的引用标签自动地对输出进行排序。你也可以单独地指定每个文件。</p>
<pre><code>tsc --outFile sample.js Validation.ts LettersOnlyValidator.ts ZipCodeValidator.ts Test.ts
</code></pre>
<p>第二种方式，我们可以编译每一个文件（默认方式），那么每个源文件都会对应生成一个JavaScript文件。 然后，在页面上通过 <code>&lt;script&gt;</code>标签把所有生成的JavaScript文件按正确的顺序引进来，比如：</p>
<pre><code class="language-html">&lt;script src=&quot;Validation.js&quot; type=&quot;text/javascript&quot; /&gt;
&lt;script src=&quot;LettersOnlyValidator.js&quot; type=&quot;text/javascript&quot; /&gt;
&lt;script src=&quot;ZipCodeValidator.js&quot; type=&quot;text/javascript&quot; /&gt;
&lt;script src=&quot;Test.js&quot; type=&quot;text/javascript&quot; /&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="认识typescript-泛型"><a class="header" href="#认识typescript-泛型">认识Typescript-泛型</a></h1>
<p>软件工程中，我们不仅要创建一致的定义良好的API，同时也要考虑可重用性。 组件不仅能够支持当前的数据类型，同时也能支持未来的数据类型，这在创建大型系统时为你提供了十分灵活的功能。</p>
<p>在像C#和Java这样的语言中，可以使用<strong>泛型</strong>来创建可重用的组件，一个组件可以支持多种类型的数据。 这样用户就可以以自己的数据类型来使用组件。</p>
<h2 id="泛型之hello-world"><a class="header" href="#泛型之hello-world">泛型之Hello World</a></h2>
<hr />
<p>下面来创建第一个使用泛型的例子：identity函数。 这个函数会返回任何传入它的值。 你可以把这个函数当成是 <code>echo</code>命令。</p>
<p>不用泛型的话，这个函数可能是下面这样：</p>
<pre><code class="language-typescript">function identity(arg: number): number {
    return arg;
}
</code></pre>
<p>或者，我们使用any类型来定义函数：</p>
<pre><code class="language-typescript">function identity(arg: any): any {
    return arg;
}
</code></pre>
<p>使用<code>any</code>类型会导致这个函数可以接收任何类型的arg参数，这样就丢失了一些信息：传入的类型与返回的类型应该是相同的。如果我们传入一个数字，我们只知道任何类型的值都有可能被返回。</p>
<p>因此，我们需要一种方法使返回值的类型与传入参数的类型是相同的。 这里，我们使用了<strong>类型变量</strong>，它是一种特殊的变量，<em>只用于表示类型而不是值</em>。</p>
<pre><code class="language-typescript">function identity&lt;T&gt;(arg: T): T {
    return arg;
}
</code></pre>
<p>我们给identity添加了类型变量<code>T</code>。 <code>T</code>帮助我们捕获用户传入的类型（比如：<code>number</code>），之后我们就可以使用这个类型。 之后我们再次使用了<code>T</code>当做返回值类型。现在我们可以知道参数类型与返回值类型是相同的了。 这允许我们跟踪函数里使用的类型的信息。</p>
<p>我们把这个版本的<code>identity</code>函数叫做泛型，因为它可以适用于多个类型。 不同于使用<code>any</code>，它不会丢失信息，像第一个例子那像保持准确性，传入数值类型并返回数值类型。</p>
<p>我们定义了泛型函数后，可以用两种方法使用。 第一种是，传入所有的参数，包含类型参数：</p>
<pre><code class="language-typescript">let output = identity&lt;string&gt;(&quot;myString&quot;);  // type of output will be 'string'
</code></pre>
<p>这里我们明确的指定了<code>T</code>是<code>string</code>类型，并做为一个参数传给函数，使用了<code>&lt;&gt;</code>括起来而不是<code>()</code>。</p>
<p>第二种方法更普遍。利用了<em>类型推论</em> -- 即编译器会根据传入的参数自动地帮助我们确定T的类型：</p>
<pre><code class="language-typescript">let output = identity(&quot;myString&quot;);  // type of output will be 'string'
</code></pre>
<p>注意我们没必要使用尖括号（<code>&lt;&gt;</code>）来明确地传入类型；编译器可以查看<code>myString</code>的值，然后把<code>T</code>设置为它的类型。 类型推论帮助我们保持代码精简和高可读性。如果编译器不能够自动地推断出类型的话，只能像上面那样明确的传入<code>T</code>的类型，在一些复杂的情况下，这是可能出现的。</p>
<h2 id="使用泛型变量"><a class="header" href="#使用泛型变量">使用泛型变量</a></h2>
<hr />
<p>使用泛型创建像<code>identity</code>这样的泛型函数时，编译器要求你在函数体必须正确的使用这个通用的类型。 换句话说，你必须把这些参数当做是任意或所有类型。</p>
<p>看下之前identity例子：</p>
<pre><code class="language-typescript">function identity&lt;T&gt;(arg: T): T {
    return arg;
}
</code></pre>
<p>如果我们想同时打印出arg的长度。 我们很可能会这样做：</p>
<pre><code class="language-typescript">function loggingIdentity&lt;T&gt;(arg: T): T {
    console.log(arg.length);  // Error: T doesn't have .length
    return arg;
}
</code></pre>
<p>如果这么做，编译器会报错说我们使用了<code>arg</code>的<code>.length</code>属性，但是没有地方指明<code>arg</code>具有这个属性。 记住，这些类型变量代表的是任意类型，所以使用这个函数的人可能传入的是个数字，而数字是没有 <code>.length</code>属性的。</p>
<p>现在假设我们想操作T类型的数组而不直接是T。由于我们操作的是数组，所以<code>.length</code>属性是应该存在的。 我们可以像创建其它数组一样创建这个数组：</p>
<pre><code class="language-typescript">function loggingIdentity&lt;T&gt;(arg: T[]): T[] {
    console.log(arg.length);  // Array has a .length, so no more error
    return arg;
}
</code></pre>
<p>你可以这样理解<code>loggingIdentity</code>的类型：泛型函数<code>loggingIdentity</code>，接收类型参数<code>T</code>和参数<code>arg</code>，它是个元素类型是<code>T</code>的数组，并返回元素类型是<code>T</code>的数组。 如果我们传入数字数组，将返回一个数字数组，因为此时 <code>T</code>的的类型为number。 这可以让我们把泛型变量<code>T</code>当做类型的一部分使用，而不是整个类型，增加了灵活性。</p>
<p>我们也可以这样实现上面的例子：</p>
<pre><code class="language-typescript">function loggingIdentity&lt;T&gt;(arg: Array&lt;T&gt;): Array&lt;T&gt; {
    console.log(arg.length);  // Array has a .length, so no more error
    return arg;
}
</code></pre>
<p>使用过其它语言的话，你可能对这种语法已经很熟悉了。 在下一节，会介绍如何创建自定义泛型像 Array<T>一样。</p>
<h2 id="泛型类型"><a class="header" href="#泛型类型">泛型类型</a></h2>
<hr />
<p>上一节，我们创建了identity通用函数，可以适用于不同的类型。 在这节，我们研究一下函数本身的类型，以及如何创建泛型接口。</p>
<p>泛型函数的类型与非泛型函数的类型没什么不同，只是有一个类型参数在最前面，像函数声明一样：</p>
<pre><code class="language-typescript">function identity&lt;T&gt;(arg: T): T {
    return arg;
}

let myIdentity: &lt;T&gt;(arg: T) =&gt; T = identity;
</code></pre>
<p>我们也可以使用不同的泛型参数名，只要在数量上和使用方式上能对应上就可以。</p>
<pre><code class="language-typescript">function identity&lt;T&gt;(arg: T): T {
    return arg;
}

let myIdentity: &lt;U&gt;(arg: U) =&gt; U = identity;
</code></pre>
<p>我们还可以使用带有调用签名的对象字面量来定义泛型函数：</p>
<pre><code class="language-typescript">function identity&lt;T&gt;(arg: T): T {
    return arg;
}

let myIdentity: {&lt;T&gt;(arg: T): T} = identity;
</code></pre>
<p>这引导我们去写第一个泛型接口了。 我们把上面例子里的对象字面量拿出来做为一个接口：</p>
<pre><code class="language-typescript">interface GenericIdentityFn {
    &lt;T&gt;(arg: T): T;
}

function identity&lt;T&gt;(arg: T): T {
    return arg;
}

let myIdentity: GenericIdentityFn = identity;
</code></pre>
<p>一个相似的例子，我们可能想把泛型参数当作整个接口的一个参数。 这样我们就能清楚的知道使用的具体是哪个泛型类型（比如： <code>Dictionary&lt;string&gt;而不只是Dictionary</code>）。 这样接口里的其它成员也能知道这个参数的类型了。</p>
<pre><code class="language-typescript">interface GenericIdentityFn&lt;T&gt; {
    (arg: T): T;
}

function identity&lt;T&gt;(arg: T): T {
    return arg;
}

let myIdentity: GenericIdentityFn&lt;number&gt; = identity;
</code></pre>
<p>注意，我们的示例做了少许改动。 不再描述泛型函数，而是把非泛型函数签名作为泛型类型一部分。 当我们使用 <code>GenericIdentityFn</code> 的时候，还得传入一个类型参数来指定泛型类型（这里是：<code>number</code>），锁定了之后代码里使用的类型。 对于描述哪部分类型属于泛型部分来说，理解何时把参数放在调用签名里和何时放在接口上是很有帮助的。</p>
<p>除了泛型接口，我们还可以创建泛型类。 注意，无法创建泛型枚举和泛型命名空间。</p>
<h2 id="泛型类"><a class="header" href="#泛型类">泛型类</a></h2>
<hr />
<pre><code class="language-typescript">class GenericNumber&lt;T&gt; {
    zeroValue: T;
    add: (x: T, y: T) =&gt; T;
}

let myGenericNumber = new GenericNumber&lt;number&gt;();
myGenericNumber.zeroValue = 0;
myGenericNumber.add = function(x, y) { return x + y; };
</code></pre>
<p>GenericNumber类的使用是十分直观的，并且你可能已经注意到了，没有什么去限制它只能使用number类型。 也可以使用字符串或其它更复杂的类型。</p>
<pre><code class="language-typescript">let stringNumeric = new GenericNumber&lt;string&gt;();
stringNumeric.zeroValue = &quot;&quot;;
stringNumeric.add = function(x, y) { return x + y; };

console.log(stringNumeric.add(stringNumeric.zeroValue, &quot;test&quot;));
</code></pre>
<p>与接口一样，直接把泛型类型放在类后面，可以帮助我们确认类的所有属性都在使用相同的类型。</p>
<h2 id="泛型约束"><a class="header" href="#泛型约束">泛型约束</a></h2>
<hr />
<p>你应该会记得之前的一个例子，我们有时候想操作某类型的一组值，并且我们知道这组值具有什么样的属性。 在 <code>loggingIdentity</code> 例子中，我们想访问<code>arg</code>的<code>length</code>属性，但是编译器并不能证明每种类型都有<code>length</code>属性，所以就报错了。</p>
<pre><code class="language-typescript">function loggingIdentity&lt;T&gt;(arg: T): T {
    console.log(arg.length);  // Error: T doesn't have .length
    return arg;
}
</code></pre>
<p>相比于操作any所有类型，我们想要限制函数去处理任意带有<code>.length</code>属性的所有类型。 只要传入的类型有这个属性，我们就允许，就是说至少包含这一属性。 为此，我们需要列出对于T的约束要求。</p>
<p>为此，我们定义一个接口来描述约束条件。 创建一个包含 <code>.length</code>属性的接口，使用这个接口和extends关键字来实现约束：</p>
<pre><code class="language-typescript">interface Lengthwise {
    length: number;
}

function loggingIdentity&lt;T extends Lengthwise&gt;(arg: T): T {
    console.log(arg.length);  // Now we know it has a .length property, so no more error
    return arg;
}
</code></pre>
<p>现在这个泛型函数被定义了约束，因此它不再是适用于任意类型：</p>
<pre><code class="language-typescript">loggingIdentity(3);  // Error, number doesn't have a .length property
</code></pre>
<p>我们需要传入符合约束类型的值，必须包含必须的属性：</p>
<pre><code class="language-typescript">loggingIdentity({length: 10, value: 3});
</code></pre>
<h3 id="在泛型约束中使用类型参数"><a class="header" href="#在泛型约束中使用类型参数">在泛型约束中使用类型参数</a></h3>
<p>你可以声明一个类型参数，且它被另一个类型参数所约束。 比如，现在我们想要用属性名从对象里获取这个属性。 并且我们想要确保这个属性存在于对象 obj上，因此我们需要在这两个类型之间使用约束。</p>
<pre><code class="language-typescript">function getProperty(obj: T, key: K) {
    return obj[key];
}

let x = { a: 1, b: 2, c: 3, d: 4 };

getProperty(x, &quot;a&quot;); // okay
getProperty(x, &quot;m&quot;); // error: Argument of type 'm' isn't assignable to 'a' | 'b' | 'c' | 'd'.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="声明文件"><a class="header" href="#声明文件">声明文件</a></h1>
<p>当你在使用VS Code编写TypeScript文件时，你不太可能在每个文件上都标明<code>interface</code>字样的接口，一旦某个文件的方法或者变量比较多，你的代码可能就会被非常多的类型注解占据，在大型项目或者是你生成的库文件中为了保持代码的整洁，你就可能需要<strong>声明文件</strong>的帮助。</p>
<h2 id="创建一个声明文件"><a class="header" href="#创建一个声明文件">创建一个声明文件</a></h2>
<hr />
<p>声明文件以<code>.d.ts</code>结尾，与TypeScript文件<code>.ts</code>稍有区别。当你的项目目录中出现了<code>.d.ts</code>结尾的文件时，所有与之关联的规则都会自动应用。声明文件支持我们前面介绍的各类语法，但是你得在语法前面加上<code>declare</code>。</p>
<h2 id="例子"><a class="header" href="#例子">例子</a></h2>
<hr />
<h3 id="全局变量"><a class="header" href="#全局变量">全局变量</a></h3>
<p><strong>文档</strong></p>
<blockquote>
<p>全局变量foo包含了存在组件总数。</p>
</blockquote>
<p><strong>代码</strong></p>
<pre><code class="language-typescript">console.log(&quot;Half the number of widgets is &quot; + (foo / 2));
</code></pre>
<p><strong>声明</strong></p>
<p>使用declare var声明变量。 如果变量是只读的，那么可以使用 declare const。 你还可以使用 declare let如果变量拥有块级作用域。</p>
<pre><code class="language-typescript">/** 组件总数 */
declare var foo: number;
</code></pre>
<h3 id="全局函数"><a class="header" href="#全局函数">全局函数</a></h3>
<p><strong>文档</strong></p>
<blockquote>
<p>用一个字符串参数调用greet函数向用户显示一条欢迎信息。</p>
</blockquote>
<p><strong>代码</strong></p>
<pre><code class="language-typescript">greet(&quot;hello, world&quot;);
</code></pre>
<p><strong>声明</strong></p>
<p>使用declare function声明函数。</p>
<pre><code class="language-typescript">declare function greet(greeting: string): void;
</code></pre>
<h3 id="带属性的对象"><a class="header" href="#带属性的对象">带属性的对象</a></h3>
<p><strong>文档</strong></p>
<blockquote>
<p>全局变量myLib包含一个makeGreeting函数， 还有一个属性 numberOfGreetings指示目前为止欢迎数量。</p>
</blockquote>
<p><strong>代码</strong></p>
<pre><code class="language-typescript">let result = myLib.makeGreeting(&quot;hello, world&quot;);
console.log(&quot;The computed greeting is:&quot; + result);

let count = myLib.numberOfGreetings;
</code></pre>
<p><strong>声明</strong></p>
<p>使用declare namespace描述用点表示法访问的类型或值。</p>
<pre><code class="language-typescript">declare namespace myLib {
    function makeGreeting(s: string): string;
    let numberOfGreetings: number;
}
</code></pre>
<h3 id="函数重载"><a class="header" href="#函数重载">函数重载</a></h3>
<p><strong>文档</strong></p>
<p>getWidget函数接收一个数字，返回一个组件，或接收一个字符串并返回一个组件数组。</p>
<p><strong>代码</strong></p>
<pre><code class="language-typescript">let x: Widget = getWidget(43);

let arr: Widget[] = getWidget(&quot;all of them&quot;);
</code></pre>
<p><strong>声明</strong></p>
<pre><code class="language-typescript">declare function getWidget(n: number): Widget;
declare function getWidget(s: string): Widget[];
</code></pre>
<h3 id="可重用类型接口"><a class="header" href="#可重用类型接口">可重用类型（接口）</a></h3>
<p><strong>文档</strong></p>
<blockquote>
<p>当指定一个欢迎词时，你必须传入一个GreetingSettings对象。 这个对象具有以下几个属性：</p>
<p>1- greeting：必需的字符串</p>
<p>2- duration: 可选的时长（毫秒表示）</p>
<p>3- color: 可选字符串，比如‘#ff00ff’</p>
</blockquote>
<p><strong>代码</strong></p>
<pre><code class="language-typescript">greet({
  greeting: &quot;hello world&quot;,
  duration: 4000
});
</code></pre>
<p><strong>声明</strong></p>
<p>使用interface定义一个带有属性的类型。</p>
<pre><code class="language-typescript">interface GreetingSettings {
  greeting: string;
  duration?: number;
  color?: string;
}

declare function greet(setting: GreetingSettings): void;
</code></pre>
<h3 id="可重用类型类型别名"><a class="header" href="#可重用类型类型别名">可重用类型（类型别名）</a></h3>
<p><strong>文档</strong></p>
<blockquote>
<p>在任何需要欢迎词的地方，你可以提供一个string，一个返回string的函数或一个Greeter实例。</p>
</blockquote>
<p><strong>代码</strong></p>
<pre><code class="language-typescript">function getGreeting() {
    return &quot;howdy&quot;;
}
class MyGreeter extends Greeter { }

greet(&quot;hello&quot;);
greet(getGreeting);
greet(new MyGreeter());
</code></pre>
<p><strong>声明</strong></p>
<p>你可以使用类型别名来定义类型的短名：</p>
<pre><code class="language-typescript">type GreetingLike = string | (() =&gt; string) | MyGreeter;

declare function greet(g: GreetingLike): void;
</code></pre>
<h3 id="组织类型"><a class="header" href="#组织类型">组织类型</a></h3>
<p><strong>文档</strong></p>
<blockquote>
<p>greeter对象能够记录到文件或显示一个警告。 你可以为 .log(...)提供LogOptions和为.alert(...)提供选项。</p>
</blockquote>
<p><strong>代码</strong></p>
<pre><code class="language-typescript">const g = new Greeter(&quot;Hello&quot;);
g.log({ verbose: true });
g.alert({ modal: false, title: &quot;Current Greeting&quot; });
</code></pre>
<p><strong>声明</strong></p>
<p>使用命名空间组织类型。</p>
<pre><code class="language-typescript">declare namespace GreetingLib {
    interface LogOptions {
        verbose?: boolean;
    }
    interface AlertOptions {
        modal: boolean;
        title?: string;
        color?: string;
    }
}
</code></pre>
<p>你也可以在一个声明中创建嵌套的命名空间：</p>
<pre><code class="language-typescript">declare namespace GreetingLib.Options {
    // Refer to via GreetingLib.Options.Log
    interface Log {
        verbose?: boolean;
    }
    interface Alert {
        modal: boolean;
        title?: string;
        color?: string;
    }
}
</code></pre>
<h3 id="类-1"><a class="header" href="#类-1">类</a></h3>
<p><strong>文档</strong></p>
<blockquote>
<p>你可以通过实例化Greeter对象来创建欢迎词，或者继承Greeter对象来自定义欢迎词。</p>
</blockquote>
<p><strong>代码</strong></p>
<pre><code class="language-typescript">const myGreeter = new Greeter(&quot;hello, world&quot;);
myGreeter.greeting = &quot;howdy&quot;;
myGreeter.showGreeting();

class SpecialGreeter extends Greeter {
    constructor() {
        super(&quot;Very special greetings&quot;);
    }
}
</code></pre>
<p><strong>声明</strong></p>
<p>使用declare class描述一个类或像类一样的对象。 类可以有属性和方法，就和构造函数一样。</p>
<pre><code class="language-typescript">declare class Greeter {
    constructor(greeting: string);

    greeting: string;
    showGreeting(): void;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="你的第一个插件"><a class="header" href="#你的第一个插件">你的第一个插件</a></h1>
<p>在本小节中，我们会教你一些基础概念，请先安装好<a href="https://nodejs.org/en/">Node.js</a>和<a href="https://git-scm.com/">Git</a>，然后安装<a href="http://yeoman.io/">Yeoman</a>和<a href="https://www.npmjs.com/package/generator-code">VS Code Extension Generator</a>：</p>
<pre><code class="language-bash">npm install -g yo generator-code
</code></pre>
<p>这个脚手架会生成一个可以立马开发的项目。运行生成器，然后填好下列字段：</p>
<pre><code class="language-bash">yo code

# ? What type of extension do you want to create? New Extension (TypeScript)
# ? What's the name of your extension? HelloWorld
### Press &lt;Enter&gt; to choose default for all options below ###

# ? What's the identifier of your extension? helloworld
# ? What's the description of your extension? LEAVE BLANK
# ? Enable stricter TypeScript checking in 'tsconfig.json'? Yes
# ? Setup linting using 'tslint'? Yes
# ? Initialize a git repository? Yes
# ? Which package manager to use? npm

code ./helloworld
</code></pre>
<p>完成后进入 VS Code，按下<code>F5</code>，你会立即看到一个<strong>插件发开主机</strong>窗口，其中就运行着插件。</p>
<p>在命令面板(<code>Ctrl+Shift+P</code>)中输入<code>Hello World</code>命令。</p>
<video loop muted playsinline controls>
  <source src="https://code.visualstudio.com/api/get-started/your-first-extension/launch.mp4" type="video/mp4">
</video>
<p>如果你看到了<code>Hello World</code>提示弹窗，恭喜你成功了！</p>
<h2 id="开发插件"><a class="header" href="#开发插件">开发插件</a></h2>
<hr />
<p>现在让我们稍稍改动一下弹窗显示的内容：</p>
<ul>
<li>将项目文件<code>extension.ts</code>中的<code>Hello World</code>改为<code>Hello VS Code</code></li>
<li>重新加载开发窗口</li>
<li>再次运行<code>Hello World</code>命令</li>
</ul>
<p>你应该就能看到显示的消息更新了：</p>
<video loop muted playsinline controls>
  <source src="https://code.visualstudio.com/api/get-started/your-first-extension/reload.mp4" type="video/mp4">
</video>
<p>请浏览你的项目目录和代码，然后进行下面的小练习：</p>
<ul>
<li>为命令面板中的<code>Hello World</code>换一个名字</li>
<li><a href="get-started//references/contribution-points.html">配置</a>一个新的命令：打开一个提示弹窗，显示当前时间</li>
<li>用显示警告信息的<a href="get-started//references/vscode-api.html">VS Code API</a>替换原本的<code>vscode.window.showInformationMessage</code></li>
</ul>
<h2 id="调试插件"><a class="header" href="#调试插件">调试插件</a></h2>
<hr />
<p>VS Code 内置的调试功能已经非常方便了，在代码序号的左侧空白处点击一下，VS Code 就会设下断点，进入调试模式后将鼠标悬停于变量上显示变量值，或是在调试侧边栏中检查变量值，此时，你还可以用<strong>调试控制台</strong>直接对表达式求值。</p>
<video loop muted playsinline controls>
  <source src="https://code.visualstudio.com/api/get-started/your-first-extension/debug.mp4" type="video/mp4">
</video>
<p>有关 Node.js 调试的部分，请参考<a href="https://code.visualstudio.com/docs/nodejs/nodejs-debugging">Node.js 调试</a>部分。</p>
<h2 id="下一步-2"><a class="header" href="#下一步-2">下一步</a></h2>
<p>在下个主题<a href="get-started//get-started/extension-anatomy.html">解析插件结构</a>中，我们会大致看一下<code>Hello World</code>示例的源码，然后解释一些关键的概念。</p>
<p>本节教程的源码可参考<a href="https://github.com/Microsoft/vscode-extension-samples/tree/master/helloworld-sample">https://github.com/Microsoft/vscode-extension-samples/tree/master/helloworld-sample</a>。
此外，<a href="get-started//extension-guides/README.html">插件指引</a>章节还包含其他示例代码，每个例子都对应着不同的 VS Code Api 和发布内容配置。</p>
<h4 id="使用-javascript"><a class="header" href="#使用-javascript">使用 Javascript</a></h4>
<p>在本指南中，我们主要使用 TypeScript 开发 VS Code 插件，因为我们认为 TS 是开发插件的最佳实践。如果你想使用 JS，我们也同样提供了源码<a href="https://github.com/Microsoft/vscode-extension-samples/tree/master/helloworld-minimal-sample">helloworld-minimal-sample</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="解析插件结构"><a class="header" href="#解析插件结构">解析插件结构</a></h1>
<p>上一节中，你已经能够自己创建一个基础的插件了，但是在面纱之下，它究竟是怎么运作的呢？</p>
<p><code>Hello World</code>插件包含了3个部分：</p>
<ul>
<li>注册<a href="get-started//references/activation-events.html#onCommand"><code>onCommand</code></a> <a href="get-started//references/activation-events.html"><strong>激活事件</strong></a>: <code>onCommand:extension.helloWorld</code>，所以用户可以在输入<code>Hello World</code>命令后激活插件。</li>
<li>使用<a href="get-started//references/contribution-points.html#contributescommands"><code>contributes.commands</code></a> <a href="get-started//references/contribution-points.html"><strong>发布内容配置</strong></a>，绑定一个命令ID <code>extension.helloWorld</code>，然后 <code>Hello World</code>命令就可以在命令面板中使用了。</li>
<li>使用<a href="get-started//references/vscode-api#commandsregisterCommand"><code>commands.registerCommand</code></a> <a href="get-started//references/vscode-api.html"><strong>VS Code API</strong></a> 将一个函数绑定到你注册的命令ID<code>extension.helloWorld</code>上。</li>
</ul>
<p>理解下面三个关键概念你才能作出一个基本的插件：</p>
<ul>
<li><a href="get-started/references/activation-events.html"><strong>激活事件</strong></a>: 插件激活的时机。</li>
<li><a href="get-started/references/contribution-points.html"><strong>发布内容配置</strong></a>: VS Code扩展了 <code>package.json</code> <a href="get-started//get-started/extension-anatomy?id=%E6%8F%92%E4%BB%B6%E6%B8%85%E5%8D%95">插件清单</a>的字段以便于开发插件。</li>
<li><a href="get-started/references/vscode-api.html"><strong>VS Code API</strong></a>: 你的插件代码中需要调用的一系列JavaScript API。</li>
</ul>
<p>大体上，你的插件就是通过组合发布内容配置和VS Code API扩展VS Code的功能。你能在<a href="get-started//extension-capabilities/README.html">插件功能概述</a>主题中找到合适你插件的配置点和VS Code API。</p>
<p>好了，现在让我们自己瞧一瞧<code>Hello World</code>示例的源码部分，以及我们上面提到的3个概念是如何应用其中的。</p>
<h2 id="插件目录结构"><a class="header" href="#插件目录结构">插件目录结构</a></h2>
<hr />
<pre><code>.
├── .vscode
│   ├── launch.json     // 插件加载和调试的配置
│   └── tasks.json      // 配置TypeScript编译任务
├── .gitignore          // 忽略构建输出和node_modules文件
├── README.md           // 一个友好的插件文档
├── src
│   └── extension.ts    // 插件源代码
├── package.json        // 插件配置清单
├── tsconfig.json       // TypeScript配置
</code></pre>
<p>下面的几个文件超出了本节讨论的范围，你可以自行前往相应的章节挖掘详细内容：</p>
<ul>
<li><code>launch.json</code> 用于配置VS Code <a href="https://code.visualstudio.com/docs/editor/debugging">调试</a></li>
<li><code>tasks.json</code> 用于定义VS Code <a href="https://code.visualstudio.com/docs/editor/tasks">任务</a></li>
<li><code>tsconfig.json</code> 参阅TypeScript <a href="https://www.typescriptlang.org/docs/handbook/tsconfig-json.html">Handbook</a></li>
</ul>
<p>现在，让我们把精力集中在这个插件的关键部分——<code>package.json</code>和<code>extensions.ts</code>。</p>
<h4 id="插件清单"><a class="header" href="#插件清单">插件清单</a></h4>
<p>每个VS Code插件都必须包含一个<code>package.json</code>，它就是插件的<a href="get-started//references/extension-manifest.html">配置清单</a>。<code>package.json</code>混合了Node.js字段，如：<code>scripts</code>、<code>dependencies</code>，还加入了一些VS Code独有的字段，如：<code>publisher</code>、<code>activationEvents</code>、<code>contributes</code>等。关于这些VS Code字段说明都在<a href="get-started/">插件清单参考</a>中可以找到。我们在本节介绍一些非常重要的字段：</p>
<ul>
<li><code>name</code> 和 <code>publisher</code>: VS Code 使用<code>&lt;publisher&gt;.&lt;name&gt;</code>作为一个插件的ID。你可以这么理解，Hello World 例子的 ID 就是<code>vscode-samples.helloworld-sample</code>。VS Code 使用 ID 来区分各个不同的插件。</li>
<li><code>main</code>: 插件的主入口。</li>
<li><code>activationEvents</code> 和 <code>contributes</code>: <a href="get-started//references/activation-events.html">激活事件</a> and <a href="get-started//references/contribution-points.html">发布内容配置</a>。</li>
<li><code>engines.vscode</code>: 描述了这个插件依赖的最低VS Code API版本。</li>
<li><code>postinstall</code> 脚本: 如果你的<code>engines.vscode</code>声明的是1.25版的VS Code API，那它就会按照这个声明去安装目标版本。一旦<code>vscode.d.ts</code>文件存在于<code>node_modules/vscode/vscode.d.ts</code>，IntelliSense就会开始运作，你就可以对所有VS Code API进行定义跳转或者语法检查了。</li>
</ul>
<pre><code class="language-json">{
	&quot;name&quot;: &quot;helloworld-sample&quot;,
	&quot;displayName&quot;: &quot;helloworld-sample&quot;,
	&quot;description&quot;: &quot;HelloWorld example for VS Code&quot;,
	&quot;version&quot;: &quot;0.0.1&quot;,
	&quot;publisher&quot;: &quot;vscode-samples&quot;,
	&quot;repository&quot;: &quot;https://github.com/Microsoft/vscode-extension-samples/helloworld-sample&quot;,
	&quot;engines&quot;: {
		&quot;vscode&quot;: &quot;^1.25.0&quot;
	},
	&quot;categories&quot;: [&quot;Other&quot;],
	&quot;activationEvents&quot;: [&quot;onCommand:extension.helloWorld&quot;],
	&quot;main&quot;: &quot;./out/extension.js&quot;,
	&quot;contributes&quot;: {
		&quot;commands&quot;: [
			{
				&quot;command&quot;: &quot;extension.helloWorld&quot;,
				&quot;title&quot;: &quot;Hello World&quot;
			}
		]
	},
	&quot;scripts&quot;: {
		&quot;vscode:prepublish&quot;: &quot;npm run compile&quot;,
		&quot;compile&quot;: &quot;tsc -p ./&quot;,
		&quot;watch&quot;: &quot;tsc -watch -p ./&quot;,
		&quot;postinstall&quot;: &quot;node ./node_modules/vscode/bin/install&quot;
	},
	&quot;devDependencies&quot;: {
		&quot;@types/node&quot;: &quot;^8.10.25&quot;,
		&quot;tslint&quot;: &quot;^5.11.0&quot;,
		&quot;typescript&quot;: &quot;^2.6.1&quot;,
		&quot;vscode&quot;: &quot;^1.1.22&quot;
	}
}
</code></pre>
<h2 id="插件入口文件"><a class="header" href="#插件入口文件">插件入口文件</a></h2>
<hr />
<p>插件入口文件会导出两个函数，<code>activate</code> 和 <code>deactivate</code>，你注册的<strong>激活事件</strong>被触发之时执行<code>activate</code>，<code>deactivate</code>则提供了插件关闭前执行清理工作的机会。</p>
<p><a href="https://www.npmjs.com/package/vscode"><code>vscode</code></a>模块包含了一个位于<code>node ./node_modules/vscode/bin/install</code>的脚本，这个脚本会拉取<code>package.json</code>中<code>engines.vscode</code>字段定义的VS Code API。这个脚本执行过后，你就得到了智能代码提示，定义跳转等TS特性了。</p>
<pre><code class="language-typescript">// 'vscode'模块包含了VS Code extensibility API
// 按下述方式导入这个模块
import * as vscode from 'vscode';

// 一旦你的插件激活，vscode会立刻调用下述方法
export function activate(context: vscode.ExtensionContext) {

    // 用console输出诊断信息(console.log)和错误(console.error)
    // 下面的代码只会在你的插件激活时执行一次
    console.log('Congratulations, your extension &quot;my-first-extension&quot; is now active!');

    // 入口命令已经在package.json文件中定义好了，现在调用registerCommand方法
    // registerCommand中的参数必须与package.json中的command保持一致
    let disposable = vscode.commands.registerCommand('extension.helloWorld', () =&gt; {
        // 把你的代码写在这里，每次命令执行时都会调用这里的代码
        // ...
        // 给用户显示一个消息提示
        vscode.window.showInformationMessage('Hello World!');
    });

    context.subscriptions.push(disposable);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="小结"><a class="header" href="#小结">小结</a></h1>
<p>在<a href="get-started//get-started/your-first-extension.html">你的第一个插件</a>中，你学会了如何创建，运行和调试插件。在<a href="get-started//get-started/extension-anatomy.html">解析插件结构</a>中，你学习了有关VS Code插件开发的基本概念。但是我们现在还只看到了冰山一角，下面我们提供了进一步打磨你开发插件能力的章节索引。</p>
<h2 id="开发插件-1"><a class="header" href="#开发插件-1">开发插件</a></h2>
<p>这一章内容将教你如何开发高质量VS Code插件。你将会学到：</p>
<ul>
<li>如何为你的插件提供<a href="get-started//working-with-extensions/testing-extension">集成测试</a></li>
<li>如何将你的插件发布到<a href="https://marketplace.visualstudio.com/">插件市场</a></li>
<li>如何为你的插件建立<a href="get-started//working-with-extensions/continuous-integration">持续集成</a></li>
</ul>
<h2 id="插件功能"><a class="header" href="#插件功能">插件功能</a></h2>
<p>在这一章中，我们把<a href="get-started//references/vscode-api">VS Code API</a>和<a href="get-started//references/contribution-points">发布内容配置</a>分成了不同类别，每个分类都是某一功能的简明教程。在这个章节你可以验证自己的插件灵感是否可行，或者从中找到新的创作想法。</p>
<h2 id="指南和示例"><a class="header" href="#指南和示例">指南和示例</a></h2>
<p>我们提供了大量示例插件，一些插件源码还包含了详细的指南，你可以在<a href="get-started//extension-guides/README.html">插件指南列表</a>找到全部的指南和示例，或者查看<a href="https://github.com/Microsoft/vscode-extension-samples">vscode-extension-samples</a>仓库。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="测试插件"><a class="header" href="#测试插件">测试插件</a></h1>
<p>VS Code 为你的插件提供了运行和调试的能力。测试会运行在一个特殊的 VS Code 实例中——<code>扩展开发环境</code>，这个特殊实例拥有访问 VS Code API 的全部权限。本篇侧重于 VS Code 的集成测试，至于单元测试，你可以使用任何流行的测试框架，如<a href="https://mochajs.org/">Mocha</a>或者<a href="https://jasmine.github.io/">Jasmine</a>。</p>
<h2 id="概述"><a class="header" href="#概述">概述</a></h2>
<hr />
<p><em>如果你原本使用<code>vscode</code>库进行测试，可以参考<a href="working-with-extensions/testing-extension.html#%E4%BB%8E-vscode-%E8%BF%81%E7%A7%BB">从<code>vscode</code>迁移</a>部分</em></p>
<p>如果你正在使用<a href="https://github.com/Microsoft/vscode-generator-code">yo code 生成器</a>，那么生成的项目中应该已经包含了一些测试示例和指引。</p>
<p>使用<code>npm run test</code>或者<code>yarn test</code>启动集成测试，测试工程随后会：</p>
<ul>
<li>下载并解压最新的 VS Code 版本</li>
<li>运行插件的<strong>测试脚本</strong>中所规定的<a href="https://mochajs.org/">Mocha</a>测试</li>
</ul>
<p>你可以在<a href="https://github.com/microsoft/vscode-extension-samples/tree/master/helloworld-test-sample">helloworld-test-sample</a>中找到本篇示例，本篇剩余部分将解释例子中的如下部分：</p>
<ul>
<li>测试入口（<a href="https://github.com/microsoft/vscode-extension-samples/blob/master/helloworld-test-sample/src/test/runTest.ts">src/test/runTest.ts</a>）</li>
<li>测试脚本(<a href="https://github.com/microsoft/vscode-extension-samples/blob/master/helloworld-test-sample/src/test/suite/index.ts">src/test/suite/index.ts</a>)</li>
</ul>
<h2 id="测试入口"><a class="header" href="#测试入口">测试入口</a></h2>
<hr />
<p>VS Code 提供了 2 个 CLI 参数来运行插件测试——<code>--extensionDevelopmentPath</code>和<code>--extensionTestsPath</code>。</p>
<p>例如：</p>
<pre><code class="language-bash"># - Launches VS Code Extension Host
# - Loads the extension at &lt;EXTENSION-ROOT-PATH&gt;
# - Executes the test runner script at &lt;TEST-RUNNER-SCRIPT-PATH&gt;
code \
--extensionDevelopmentPath=&lt;EXTENSION-ROOT-PATH&gt; \
--extensionTestsPath=&lt;TEST-RUNNER-SCRIPT-PATH&gt;
</code></pre>
<p><strong>测试入口</strong>（<a href="https://github.com/microsoft/vscode-extension-samples/blob/master/helloworld-test-sample/src/test/runTest.ts">src/test/runTest.ts</a>）使用了<code>vscode-test</code>API，简化了下载、解压、启动 VS Code 的测试流程：</p>
<pre><code class="language-typescript">import * as path from &quot;path&quot;;

import { runTests } from &quot;vscode-test&quot;;

async function main() {
  try {
    // The folder containing the Extension Manifest package.json
    // Passed to `--extensionDevelopmentPath`
    const extensionDevelopmentPath = path.resolve(__dirname, &quot;../../&quot;);

    // The path to the extension test runner script
    // Passed to --extensionTestsPath
    const extensionTestsPath = path.resolve(__dirname, &quot;./suite/index&quot;);

    // Download VS Code, unzip it and run the integration test
    await runTests({ extensionDevelopmentPath, extensionTestsPath });
  } catch (err) {
    console.error(&quot;Failed to run tests&quot;);
    process.exit(1);
  }
}

main();
</code></pre>
<p><code>vscode-test</code>还支持：</p>
<ul>
<li>启动 VS Code 时打开指定工作区</li>
<li>下载不同版本的 VS Code</li>
<li>使用其他 CLI 参数启动</li>
</ul>
<p>你可以在<a href="https://github.com/microsoft/vscode-test">microsoft/vscode-test</a>中找到更多用法。</p>
<h2 id="测试脚本"><a class="header" href="#测试脚本">测试脚本</a></h2>
<hr />
<p>当你运行插件的集成测试时，<code>--extensionTestsPath</code>会指向<strong>测试脚本</strong>(<a href="https://github.com/microsoft/vscode-extension-samples/blob/master/helloworld-test-sample/src/test/suite/index.ts">src/test/suite/index.ts</a>)，然后这个脚本会进一步运行测试套件。下面是<code>helloworld-test-sample</code>中的<a href="https://github.com/microsoft/vscode-extension-samples/blob/master/helloworld-test-sample/src/test/suite/index.ts">测试脚本</a>，它使用了 Mocha 运行测试套件。你可以把这个文件视为测试的起点，你可以用<a href="https://mochajs.org/api/mocha">Mocha 的 API</a>自定义启动时的配置，你也可以用其他任意喜欢的测试框架替代 Mocha。</p>
<pre><code class="language-typescript">import * as path from &quot;path&quot;;
import * as Mocha from &quot;mocha&quot;;
import * as glob from &quot;glob&quot;;

export function run(): Promise&lt;void&gt; {
  // Create the mocha test
  const mocha = new Mocha({
    ui: &quot;tdd&quot;
  });
  mocha.useColors(true);

  const testsRoot = path.resolve(__dirname, &quot;..&quot;);

  return new Promise((c, e) =&gt; {
    glob(&quot;**/**.test.js&quot;, { cwd: testsRoot }, (err, files) =&gt; {
      if (err) {
        return e(err);
      }

      // Add files to the test suite
      files.forEach(f =&gt; mocha.addFile(path.resolve(testsRoot, f)));

      try {
        // Run the mocha test
        mocha.run(failures =&gt; {
          if (failures &gt; 0) {
            e(new Error(`${failures} tests failed.`));
          } else {
            c();
          }
        });
      } catch (err) {
        e(err);
      }
    });
  });
}
</code></pre>
<p>所有测试脚本和<code>*.test.js</code>文件都有访问 VS Code API 的权限。
看看这个例子(<a href="https://github.com/microsoft/vscode-extension-samples/blob/master/helloworld-test-sample/src/test/suite/extension.test.ts">src/test/suite/extension.test.ts</a>)</p>
<pre><code class="language-typescript">import * as assert from &quot;assert&quot;;
import { after } from &quot;mocha&quot;;

// You can import and use all API from the 'vscode' module
// as well as import your extension to test it
import * as vscode from &quot;vscode&quot;;
// import * as myExtension from '../extension';

suite(&quot;Extension Test Suite&quot;, () =&gt; {
  after(() =&gt; {
    vscode.window.showInformationMessage(&quot;All tests done!&quot;);
  });

  test(&quot;Sample test&quot;, () =&gt; {
    assert.equal(-1, [1, 2, 3].indexOf(5));
    assert.equal(-1, [1, 2, 3].indexOf(0));
  });
});
</code></pre>
<h2 id="调试测试文件"><a class="header" href="#调试测试文件">调试测试文件</a></h2>
<hr />
<p>调试测试文件和调试插件是一样的，我们看一个<code>launch.json</code>调试器配置的例子：</p>
<pre><code class="language-json">{
  &quot;version&quot;: &quot;0.2.0&quot;,
  &quot;configurations&quot;: [
    {
      &quot;name&quot;: &quot;Extension Tests&quot;,
      &quot;type&quot;: &quot;extensionHost&quot;,
      &quot;request&quot;: &quot;launch&quot;,
      &quot;runtimeExecutable&quot;: &quot;${execPath}&quot;,
      &quot;args&quot;: [
        &quot;--extensionDevelopmentPath=${workspaceFolder}&quot;,
        &quot;--extensionTestsPath=${workspaceFolder}/out/test/suite/index&quot;
      ],
      &quot;outFiles&quot;: [&quot;${workspaceFolder}/out/test/**/*.js&quot;]
    }
  ]
}
</code></pre>
<video loop muted playsinline controls>
  <source src="https://code.visualstudio.com/api/working-with-extensions/testing-extension/debug.mp4" type="video/mp4">
</video>
<h2 id="提示"><a class="header" href="#提示">提示</a></h2>
<hr />
<h4 id="使用-insider-版本开发插件"><a class="header" href="#使用-insider-版本开发插件">使用 Insider 版本开发插件</a></h4>
<p>由于 VS Code 的限制，如果你使用 VS Code 稳定版来运行集成测试，它会报错：</p>
<pre><code>Running extension tests from the command line is currently only supported if no other instance of Code is running.
</code></pre>
<p>所以推荐你使用<a href="https://code.visualstudio.com/insiders/">VS Code Insiders</a>测试插件。</p>
<h4 id="调试时禁用其他插件"><a class="header" href="#调试时禁用其他插件">调试时禁用其他插件</a></h4>
<p>当你在 VS Code 中对测试进行调试时，VS Code 使用的是全局安装的 VS Code 实例，它会加载所有插件。你可以在<code>launch.json</code>中添加<code>--disable-extensions</code>或者在<code>runTests</code>的<code>launchArgs</code>选项中添加该项以禁用其他插件。</p>
<pre><code class="language-json">{
  &quot;version&quot;: &quot;0.2.0&quot;,
  &quot;configurations&quot;: [
    {
      &quot;name&quot;: &quot;Extension Tests&quot;,
      &quot;type&quot;: &quot;extensionHost&quot;,
      &quot;request&quot;: &quot;launch&quot;,
      &quot;runtimeExecutable&quot;: &quot;${execPath}&quot;,
      &quot;args&quot;: [
        &quot;--disable-extensions&quot;,
        &quot;--extensionDevelopmentPath=${workspaceFolder}&quot;,
        &quot;--extensionTestsPath=${workspaceFolder}/out/test/suite/index&quot;
      ],
      &quot;outFiles&quot;: [&quot;${workspaceFolder}/out/test/**/*.js&quot;]
    }
  ]
}
</code></pre>
<pre><code class="language-typescript">await runTests({
  extensionDevelopmentPath,
  extensionTestsPath,
  /**
   * A list of launch arguments passed to VS Code executable, in addition to `--extensionDevelopmentPath`
   * and `--extensionTestsPath` which are provided by `extensionDevelopmentPath` and `extensionTestsPath`
   * options.
   *
   * If the first argument is a path to a file/folder/workspace, the launched VS Code instance
   * will open it.
   *
   * See `code --help` for possible arguments.
   */
  launchArgs: [&quot;--disable-extensions&quot;]
});
</code></pre>
<h4 id="使用vscode-test自定义配置"><a class="header" href="#使用vscode-test自定义配置">使用<code>vscode-test</code>自定义配置</a></h4>
<p>你可能会需要自定义一些启动配置，比如启动测试前执行<code>code --install-extension</code>安装一些其他插件这样的场景。<code>vscode-test</code>提供粒度更细的 API 来操作这样的场景：</p>
<pre><code class="language-typescript">const cp = require(&quot;child_process&quot;);
const {
  downloadAndUnzipVSCode,
  resolveCliPathFromExecutablePath
} = require(&quot;vscode-test&quot;);
const vscodeExecutablePath = await downloadAndUnzipVSCode(&quot;1.34.0&quot;);
const cliPath = resolveCliPathFromExecutablePath(vscodeExecutablePath);

// Use cp.spawn / cp.exec for custom setup
cp.spawnSync(
  cliPath,
  [&quot;--install-extension&quot;, &quot;&lt;EXTENSION-ID-OR-PATH-TO-VSIX&gt;&quot;],
  {
    encoding: &quot;utf-8&quot;,
    stdio: &quot;inherit&quot;
  }
);

// Run the extension test
await runTests({
  // Use the specified `code` executable
  vscodeExecutablePath,
  extensionPath,
  testRunnerPath
});
</code></pre>
<h4 id="从-vscode-迁移"><a class="header" href="#从-vscode-迁移">从 vscode 迁移</a></h4>
<p><code>vscode</code>中的集成测试模块已迁移到<code>vscode-test</code>，你可以按下面的步骤进行迁移：</p>
<ul>
<li>
<p>移除<code>vscode</code>依赖</p>
</li>
<li>
<p>添加<code>vscode-test</code>依赖</p>
</li>
<li>
<p>由于旧的<code>vscode</code>模块会下载 VS Code 类型定义，所以你需要</p>
<ul>
<li>手动安装<code>@types/vscode</code>，这个版本需和你<code>package.json</code>的<code>engine.vscode</code>版本一致，比如你的<code>engine.vscode</code>版本是<code>1.30</code>，那么就安装<code>@types/vscode@1.30</code></li>
<li>删除<code>package.json</code>中的<code>&quot;postinstall&quot;: &quot;node ./node_modules/vscode/bin/install&quot;</code></li>
</ul>
</li>
<li>
<p>添加一个<a href="working-with-extensions/testing-extension.html#%E6%B5%8B%E8%AF%95%E5%85%A5%E5%8F%A3">测试入口</a>，你可以像我们的示例一样，用<code>runTest.ts</code>作为入口。</p>
</li>
<li>
<p>指定<code>package.json</code>中的<code>test</code>脚本，运行编译后的<code>runTest.ts</code>。</p>
</li>
<li>
<p>添加一个<a href="working-with-extensions/testing-extension.html#%E6%B5%8B%E8%AF%95%E8%84%9A%E6%9C%AC">测试脚本</a>，你可以用<a href="https://github.com/microsoft/vscode-extension-samples/blob/master/helloworld-test-sample/src/test/suite/index.ts">sample test runner script</a>作为入口。注意<code>vscode</code>过去依赖<code>mocha@4</code>和<code>glob</code>，现在你需要自己安装到<code>devDependency</code>里去。</p>
</li>
</ul>
<h2 id="下一步-3"><a class="header" href="#下一步-3">下一步</a></h2>
<ul>
<li><a href="working-with-extensions//working-with-extensions/continuous-integration.html">持续集成</a>：将你的插件运行在持续集成服务中，比如 Azure Devops。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="发布插件"><a class="header" href="#发布插件">发布插件</a></h1>
<h2 id="vsce--发布工具参阅"><a class="header" href="#vsce--发布工具参阅">vsce —— 发布工具参阅</a></h2>
<p><a href="https://github.com/Microsoft/vsce">vsce</a>是一个用于将插件发布到<a href="https://code.visualstudio.com/docs/editor/extension-gallery">市场</a>上的命令行工具。</p>
<h2 id="安装"><a class="header" href="#安装">安装</a></h2>
<hr />
<p>请确认本机已经安装了<a href="https://nodejs.org/">Node.js</a>，然后运行：</p>
<pre><code class="language-bash">npm install -g vsce
</code></pre>
<h2 id="使用"><a class="header" href="#使用">使用</a></h2>
<hr />
<p>然后你就可以在命令行里直接使用<code>vsce</code>了。下面是一个快速发布的示例（在你登录和打包好插件之后）:</p>
<pre><code class="language-bash">$ vsce publish
Publishing uuid@0.0.1...
Successfully published uuid@0.0.1!
</code></pre>
<p>更多可用的命令参数，请使用<code>vsce --help</code></p>
<h2 id="发布教程"><a class="header" href="#发布教程">发布教程</a></h2>
<hr />
<p>!&gt; <strong>注意：</strong> 出于安全考虑，<code>vsce</code>不会发布包含用户提供 SVG 图片的插件。</p>
<p>发布工具会检查以下内容：</p>
<ul>
<li><code>pacakge.json</code>文件中的 icon 不可以是 SVG。</li>
<li><code>pacakge.json</code>中的徽章不可以是 SVG，除非来自于<a href="working-with-extensions//extensibility-reference/extension-manifest.html#%E4%BD%BF%E7%94%A8%E8%AE%A4%E8%AF%81%E8%BF%87%E7%9A%84%E6%A0%87%E5%BF%97">可靠的图标来源</a></li>
<li><code>README.md</code>和<code>CHANGELOG.md</code>中的图片链接需要使用<code>https</code>协议</li>
<li><code>README.md</code>和<code>CHANGELOG.md</code>中的图片不可以是 SVG，除非来自<a href="working-with-extensions//extensibility-reference/extension-manifest.html#%E4%BD%BF%E7%94%A8%E8%AE%A4%E8%AF%81%E8%BF%87%E7%9A%84%E6%A0%87%E5%BF%97">可靠的图标来源</a></li>
</ul>
<hr />
<p>VS Code 插件市场的服务是<a href="https://visualstudio.microsoft.com/team-services">Visual Studio Team Services</a>提供的，因此验证、代理、管理插件都是由这个服务提供的。</p>
<p><code>vsce</code>只能用<a href="https://docs.microsoft.com/vsts/integrate/get-started/authentication/pats">Personal Access Tokens</a>发布插件，所以至少要创建一个 Token 以便发布插件。</p>
<h4 id="获取-personal-access-token"><a class="header" href="#获取-personal-access-token">获取 Personal Access Token</a></h4>
<p>首先，你得有一个<a href="https://docs.microsoft.com/azure/devops/organizations/accounts/create-organization-msa-or-work-student">Azure DevOps 组织</a>。</p>
<p>下面的例子里，我们假设组织名为<code>vscode</code>，从你的组织主页（例如：<code>https://dev.azure.com/vscode</code> ）进入**安全（Security）**页面：</p>
<p><img src="https://media.githubusercontent.com/media/Microsoft/vscode-docs/master/api/working-with-extensions/images/publishing-extension/token1.png" alt="publishers1" /></p>
<p>选择 Personal Access Token，点击<strong>New Token</strong>创建一个新的 Personal Access Token</p>
<p><img src="https://media.githubusercontent.com/media/Microsoft/vscode-docs/master/api/working-with-extensions/images/publishing-extension/token2.png" alt="publishers2" /></p>
<p>给 Personal Access Token 添加描述，过期时间等等，你最好把过期时间设置为 1 年，这样你接下就能方便很多，选择<strong>custom defined（用户自定义）<strong>范围，然后点击</strong>Show all scopes(显示全部)</strong></p>
<p><img src="https://media.githubusercontent.com/media/Microsoft/vscode-docs/master/api/working-with-extensions/images/publishing-extension/token3.png" alt="publishers3" /></p>
<p>最后，在这个列表中找到<strong>Marketplace</strong>，并勾选<strong>Acquire</strong>和<strong>Manage</strong></p>
<p><img src="https://media.githubusercontent.com/media/Microsoft/vscode-docs/master/api/working-with-extensions/images/publishing-extension/token4.png" alt="publishers4" /></p>
<p>点击<strong>Create</strong>，你就会看到新创建的 Personal Access Token 了，复制好，你接下来就会用到这个 token 来创建一个<em>发行方</em>了。</p>
<h4 id="创建一个发行方"><a class="header" href="#创建一个发行方">创建一个发行方</a></h4>
<p><strong>发行方</strong>是 VS Code 市场有权发布插件的唯一标识，每个插件的<a href="working-with-extensions//extensibility-reference/extension-manifest.html">package.json</a>文件都包含着<code>publisher</code>字段。</p>
<p>现在我们已经有了<a href="working-with-extensions/publish-extension.html#%E8%8E%B7%E5%8F%96Personal-Access-Token">Personal Access Token</a>，我们马上可以用<code>vsce</code>创建一个发行方：</p>
<pre><code class="language-bash">vsce create-publisher (publisher name)
</code></pre>
<p><code>vsce</code>会记住这个 Personal Access Token，日后你需要再次使用的时候会自动带上。</p>
<p>?&gt; 注意：另外，你也可以在市场的发行方<a href="https://marketplace.visualstudio.com/manage">管理页</a>中创建发行方，然后用这个账号登录<code>vsce</code>。</p>
<h4 id="发行方登录"><a class="header" href="#发行方登录">发行方登录</a></h4>
<p>如果你已经有发行方账号了：</p>
<pre><code class="language-bash">vsce login (publisher name)
</code></pre>
<p>和<code>create-publisher</code>命令类似地，<code>vsce</code>会要求输入你的 Personal Access Token。</p>
<p>你也可以用命令参数<code>-p &lt;token&gt;</code>直接登录然后立即发布插件：</p>
<pre><code class="language-bash">vsce publish -p &lt;token&gt;
</code></pre>
<h4 id="增量更新插件版本"><a class="header" href="#增量更新插件版本">增量更新插件版本</a></h4>
<p>用 SemVer 语义标识符：<code>major</code>，<code>minor</code>，<code>patch</code>增量更新插件版本号。</p>
<p>例如，你想把插件从 1.0.0 更新到 1.1.0，那么加上<code>minor</code>：</p>
<pre><code class="language-bash">vsce publish minor
</code></pre>
<p>插件<code>package.json</code>的 version 会先更新，然后才发布插件。</p>
<p>你也可以通过命令行指定版本号：</p>
<pre><code class="language-bash">vsce publish 2.0.1
</code></pre>
<h4 id="下架插件"><a class="header" href="#下架插件">下架插件</a></h4>
<p>通过指定插件 id<code>publisher.extension</code>下架插件：</p>
<pre><code>vsce unpublish (publisher name).(extension name)
</code></pre>
<p>!&gt; **注意：**当你下架插件的时候，市场会移除所有插件的历史统计数据，请在下架前再三考虑，最好还是更新插件吧。</p>
<h4 id="插件打包"><a class="header" href="#插件打包">插件打包</a></h4>
<p>你也可能只是想打包一下插件，而不是发布到商店里。用下列命令将插件打包到<code>.vsix</code>文件中：</p>
<pre><code>vsce package
</code></pre>
<p>这个命令会在当前目录生成一个<code>.vsix</code>文件，直接从<code>.vsix</code>安装插件是允许的，查看<a href="https://github.com/Microsoft/vscode-docs/blob/master/docs/editor/extension-gallery.md#install-from-a-vsix">从 VSIX 安装插件</a>了解更多内容。</p>
<h4 id="vs-code-版本兼容性"><a class="header" href="#vs-code-版本兼容性">VS Code 版本兼容性</a></h4>
<p>当你制作插件的时候，你需要描述插件对 VS Code 的版本兼容性——修改<code>package.json</code>中的<code>engines.vscode</code>：</p>
<pre><code class="language-json">{
  &quot;engines&quot;: {
    &quot;vscode&quot;: &quot;^1.8.0&quot;
  }
}
</code></pre>
<p><code>1.8.0</code>表示你的插件只能兼容<code>1.8.0</code>版本的 VS Code，<code>^1.8.0</code>则表示你的插件向上兼容，包括<code>1.8.1, 1.9.0</code>等等。</p>
<p>使用<code>engines.vscode</code>可以确保插件安装环境包含了插件依赖的 API。这个机制在稳定版和 Insider 版本都适用。</p>
<p>现在我们假设最新的稳定版 API 是<code>1.8.0</code>，而<code>1.9.0</code>引入了新的 API，所以你可以用<code>1.9.0-insider</code>标识插件在 Insider 版中也可正常使用。
如果你想使用这些刚刚引入的 API，则将依赖版本设置为<code>^1.9.0</code>，你的插件则只能安装在<code>&gt;=1.9.0</code>的 VS Code 上，也就意味着所有当前的 Insider 版本都可以用得上，而稳定版只有在更新到<code>1.9.0</code>才能使用你的插件。</p>
<h2 id="进阶用法"><a class="header" href="#进阶用法">进阶用法</a></h2>
<hr />
<h4 id="符合市场的插件"><a class="header" href="#符合市场的插件">符合市场的插件</a></h4>
<p>你可以自定义插件在市场中的外观，查看示例<a href="https://marketplace.visualstudio.com/items/ms-vscode.Go">GO 插件</a>。</p>
<p>下面是一些让你的插件在市场看起来更酷的小提示：</p>
<ul>
<li>
<p>插件根目录下面的<code>README.md</code>文件可以用来填充插件市场的页面内容。<code>vsce</code>会将 README 中的链接通过下面两种方式修改掉：</p>
<ul>
<li>如果你的<code>package.json</code>的<code>repository</code>字段是一个 Github 仓库，<code>vsce</code>会自动检测，然后相应地调整链接。</li>
<li>运行<code>vsce package</code>时，加上<code>--baseContentUrl</code>和<code>--baseImagesUrl</code>标识重载上述行为。</li>
</ul>
</li>
<li>
<p>插件根目录下的<code>LICENSE</code>会成为插件的 license。</p>
</li>
<li>
<p>同样的<code>CHANGELOG.md</code>文件会成为插件的发布日志。</p>
</li>
<li>
<p>通过设置<code>package.json</code>的<code>galleryBanner.color</code>hex 值，修改 banner 的背景色。</p>
</li>
<li>
<p>通过给<code>package.json</code>中的<code>icon</code>设置一个相对路径，可以将一个<code>128px</code>的 PNG 图标放进你的插件中。</p>
</li>
<li>
<p>参见<a href="https://github.com/Microsoft/vscode-docs/blob/master/docs/extensionAPI/extension-manifest.md#marketplace-presentation-tips">插件市场展现小提示</a></p>
</li>
</ul>
<h4 id="vscodeignore"><a class="header" href="#vscodeignore"><code>.vscodeignore</code></a></h4>
<p>创建一个<code>.vscodeignore</code>文件可以排除插件目录中的内容。这个文件支持<a href="https://github.com/isaacs/minimatch">glob</a>模式，每个表达式一行。</p>
<p>例如：</p>
<pre><code>**/*.ts
**/tsconfig.json
!file.ts
</code></pre>
<p>你应该忽略哪些不必在运行时用到的文件。例如：你的插件是用 Typescript 写的，那么你就应该忽略所有的<code>**/*.ts</code>文件。</p>
<p>?&gt; **注意：**在<code>devDependencies</code>列出的开发依赖会被自动忽略，你不必将他们加入到<code>.vscodeignore</code>中。</p>
<h5 id="预发布步骤"><a class="header" href="#预发布步骤">预发布步骤</a></h5>
<p>你是可以在清单文件中添加预发布步骤的，下面的命令会在插件每次打包时执行：</p>
<pre><code class="language-json">{
  &quot;name&quot;: &quot;uuid&quot;,
  &quot;version&quot;: &quot;0.0.1&quot;,
  &quot;publisher&quot;: &quot;joaomoreno&quot;,
  &quot;engines&quot;: {
    &quot;vscode&quot;: &quot;0.10.x&quot;
  },
  &quot;scripts&quot;: {
    &quot;vscode:prepublish&quot;: &quot;tsc&quot;
  }
}
</code></pre>
<p>上面的示例会在每次插件打包时调用 Typescript 编译器。</p>
<h2 id="faq"><a class="header" href="#faq">FAQ</a></h2>
<h5 id="问当我发布插件时遇到了-403-forbidden或-401-unauthorized错误"><a class="header" href="#问当我发布插件时遇到了-403-forbidden或-401-unauthorized错误">问：当我发布插件时遇到了 403 Forbidden（或 401 Unauthorized）错误？</a></h5>
<p>答：很有可能是你创建 PAT (Personal Access Token) 时没有选择<code>all accessible accounts</code>。你还需要将授权范围设置为<code>All scopes</code>，这样发布工具才能工作。</p>
<h5 id="问我没办法用vsce工具下架插件"><a class="header" href="#问我没办法用vsce工具下架插件">问：我没办法用<code>vsce</code>工具下架插件？</a></h5>
<p>答：你可能改变了插件 ID 或者发行方名称。不过你还可以在<a href="https://marketplace.visualstudio.com/manage">管理页面</a>发布或者下架插件。</p>
<h5 id="问为什么-vsce-不保留文件属性"><a class="header" href="#问为什么-vsce-不保留文件属性">问：为什么 vsce 不保留文件属性？</a></h5>
<p>答：请注意，当你在 Windows 平台构建和发布插件的时候，所有插件包内的文件会丢失 POSIX 文件属性，或称之为执行位（executable bit）的东西。一些基于这些属性的<code>node_modules</code>依赖则会调整工作方式。从 Linux 和 macOS 平台构建则会如预期执行。</p>
<h2 id="下一步-4"><a class="header" href="#下一步-4">下一步</a></h2>
<ul>
<li><a href="https://code.visualstudio.com/docs/editor/extension-gallery">插件市场</a> - 学习更多 VS Code 公共插件市场。</li>
<li><a href="working-with-extensions//working-with-extensions/testing-extension.html">测试插件</a> - 添加插件测试，提高插件质量。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="打包插件"><a class="header" href="#打包插件">打包插件</a></h1>
<p>VS Code 插件体积常常随着更新越来越大，它会产生很多文件，而且还依赖各种<a href="https://www.npmjs.com/">npm</a>包。
程序开发的最佳实践是抽象和重用，但过度拆分和庞大的代码结构产生的代价就是更大的插件体积和更慢的运行效率。加载 100 个小文件远比加载一个大文件来的慢，这就是我们更推荐打包插件的原因。
<em>打包</em>是将多个小的源文件打包成单个入口文件的过程。</p>
<p>对于 Javascript 而言，可选的构建工具非常多，比较流行的如<a href="https://rollupjs.org/">rollup.js</a>，<a href="https://parceljs.org/">parcel</a>和<a href="https://webpack.js.org/">webpack</a>。大部分构建工具的概念和功能都是相似的，本节主要使用<strong>webpack</strong>打包。</p>
<h2 id="使用-webpack"><a class="header" href="#使用-webpack">使用 webpack</a></h2>
<hr />
<p>webpack 这个开发工具可以在<a href="https://www.npmjs.com/">npm</a>里找到，为了获取 webpack 和它的命令行界面，打开终端然后输入：</p>
<pre><code class="language-bash">npm i --save-dev webpack webpack-cli
</code></pre>
<p>这行命令会先安装 webpack，然后更新你插件里的<code>package.json</code>中的<code>devDependencies</code>字段。Webpack 是一个 Javascrip 打包工具，但是大部分 VS Code 插件是用 Typescript 写的，所以你需要在 webpack 中配置<code>ts-loader</code>，它才能正确编译 Typescript。安装<code>ts-loader</code>：</p>
<pre><code class="language-bash">npm i --save-dev ts-loader
</code></pre>
<h2 id="配置-webpack"><a class="header" href="#配置-webpack">配置 webpack</a></h2>
<hr />
<p>既然所有的工具都安装好了，我们现在可以开始配置 webpack 了。通常来说，你的项目目录中需要创建一个<code>webpack.config.js</code>文件，webpack 才能知道按什么规则打包你的插件。下面的配置示例是 VS Code 插件专用的，让我们来开这个头吧：</p>
<pre><code class="language-javascript">/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

//@ts-check

&quot;use strict&quot;;

const path = require(&quot;path&quot;);

/**@type {import('webpack').Configuration}*/
const config = {
  target: &quot;node&quot;, // vscode插件运行在Node.js环境中 📖 -&gt; https://webpack.js.org/configuration/node/

  entry: &quot;./src/extension.ts&quot;, // 插件的入口文件 📖 -&gt; https://webpack.js.org/configuration/entry-context/
  output: {
    // 打包好的文件储存在'dist'文件夹中 (请参考package.json), 📖 -&gt; https://webpack.js.org/configuration/output/
    path: path.resolve(__dirname, &quot;dist&quot;),
    filename: &quot;extension.js&quot;,
    libraryTarget: &quot;commonjs2&quot;,
    devtoolModuleFilenameTemplate: &quot;../[resource-path]&quot;
  },
  devtool: &quot;source-map&quot;,
  externals: {
    vscode: &quot;commonjs vscode&quot; // vscode-module是热更新的临时目录，所以要排除掉。 在这里添加其他不应该被webpack打包的文件, 📖 -&gt; https://webpack.js.org/configuration/externals/
  },
  resolve: {
    // 支持读取TypeScript和JavaScript文件, 📖 -&gt; https://github.com/TypeStrong/ts-loader
    extensions: [&quot;.ts&quot;, &quot;.js&quot;]
  },
  module: {
    rules: [
      {
        test: /\.ts$/,
        exclude: /node_modules/,
        use: [
          {
            loader: &quot;ts-loader&quot;
          }
        ]
      }
    ]
  }
};
module.exports = config;
</code></pre>
<p>这份文件是<a href="https://github.com/Microsoft/vscode-extension-samples/blob/master/webpack-sample">webpack-extension</a>中的<a href="https://github.com/Microsoft/vscode-extension-samples/blob/master/webpack-sample/webpack.config.js">一部分</a>。webpack 配置最后输出的就是 JS 对象。</p>
<p>在上面的例子里，我们定义了如下内容：</p>
<ul>
<li><code>traget</code>：'node'，因为我们的插件运行在 Node.js 环境中。</li>
<li><code>entry</code>：webpack 使用的入口文件。这就像是<code>package.json</code>中的<code>main</code>属性，有点不一样的是你还需要给 webpack 提供&quot;source&quot;—— 一般就是<code>src/extension.ts</code>，小心不要配置在&quot;output&quot;里了。webpack 可以解析 Typescript，所以我们不需要再单独执行 Typescript 编译了。</li>
<li><code>output</code>配置告诉 webpack 应该把打包好的文件放在哪里，一般而言我们会放在<code>dist</code>文件夹里。在这个例子里，webpack 最后会产生一个<code>dist/extension.js</code>文件。</li>
<li>在<code>resolve</code>和<code>module/rules</code>中配置 Typescript 和 Javascript 的解析器。</li>
<li><code>externals</code>即排除配置，在这里可以配置打包文件不应包含的文件和模块。<code>vscode</code>不需要被打包是因为它并不储存在磁盘上，它是 VS Code 热更新生成的临时文件夹。根据插件依赖的具体 node 模块，你可能需要通过这个配置优化打包文件。</li>
</ul>
<h2 id="运行-webpack"><a class="header" href="#运行-webpack">运行 webpack</a></h2>
<hr />
<p><code>webpack.config.js</code>文件创建好之后，webpack 就可以正式开始工作了。你可以从命令行中运行 webpack，不过为了避免重复工作用 npm script 会更有效率。</p>
<p>将下列脚本复制到<code>package.json</code>的<code>scripts</code>中去：</p>
<pre><code class="language-json">&quot;scripts&quot;: {
  &quot;vscode:prepublish&quot;: &quot;webpack --mode production&quot;,
  &quot;compile&quot;: &quot;webpack --mode none&quot;,
  &quot;watch&quot;: &quot;webpack --mode none --watch&quot;,
},
</code></pre>
<p><code>compile</code>和<code>watch</code>脚本是开发时使用的，它们会产生构建文件。<code>vscode:prepublish</code>是<code>vsce</code>使用的，<code>vsce</code>是 VS Code 的打包和发布工具，你需要在发布插件之前运行这个命令。webpack 中的<a href="https://webpack.js.org/concepts/mode/">mode</a>是控制优化级别的配置项，如果你使用<code>production</code>字段，那么就会打包出最小的构建文件，但是也会耗费更多时间，所以我们开发中使用<code>none</code>。想要运行上述脚本，我们可以打开终端（命令行）输入<code>npm run compile</code>或者从<em>命令面板</em>（<kbd>Ctrl+Shift+P</kbd>）中使用<strong>运行任务</strong>来开始。</p>
<h2 id="运行插件"><a class="header" href="#运行插件">运行插件</a></h2>
<hr />
<p>运行插件之前，你需要将<code>package.json</code>中的<code>main</code>属性指向到构建文件上，也就是我们上面提到的<a href="https://github.com/Microsoft/vscode-references-view/blob/d649d01d369e338bbe70c86e03f28269cbf87027/package.json#L26"><code>&quot;./dist/extension&quot;</code></a>，改好之后我们就可以运行和测试插件了。关于调试配置，请注意更新<code>launch.json</code>中的<code>outFiles</code>属性。</p>
<h2 id="测试"><a class="header" href="#测试">测试</a></h2>
<hr />
<p>插件开发者一般都会给插件源代码进行单元测试，但是有了完备的底层架构支持，插件的源代码可以不依赖测试，webpack 产生的构建文件中也不应该包含任何测试代码。如果需要运行单元测试，只需要简单地编译就好了。在上面的例子里，我们有一个<code>test-compile</code>脚本，它会把调用 Typescript 编译器将插件编译至<code>out</code>目录中。这样一来我们就有了 JS 文件，再使用下面的<code>launch.json</code>就足够应付测试了。</p>
<pre><code class="language-json">{
  &quot;name&quot;: &quot;Extension Tests&quot;,
  &quot;type&quot;: &quot;extensionHost&quot;,
  &quot;request&quot;: &quot;launch&quot;,
  &quot;runtimeExecutable&quot;: &quot;${execPath}&quot;,
  &quot;args&quot;: [
    &quot;--extensionDevelopmentPath=${workspaceFolder}&quot;,
    &quot;--extensionTestsPath=${workspaceFolder}/out/test&quot;
  ],
  &quot;outFiles&quot;: [&quot;${workspaceFolder}/out/test/**/*.js&quot;],
  &quot;preLaunchTask&quot;: &quot;npm: test-compile&quot;
}
</code></pre>
<p>这个测试配置对于非 webpack 打包的插件来说也是可以使用的。我们没必要将单元测试打包起来，因为它们不应包含在我们发布的插件里。</p>
<h2 id="发布"><a class="header" href="#发布">发布</a></h2>
<hr />
<p>发布前你需要更新<code>.vscodeignore</code>文件。现在所有东西都打包到了<code>dist/extension.js</code>文件中，所以应该排除这个文件还有<code>out</code>文件夹（怕你漏了，特此提醒），以及最重要的<code>node_modules</code>文件夹。</p>
<p>一般来说，<code>.vsignore</code>文件应该是这样的：</p>
<pre><code class="language-bash">.vscode
node_modules
out/
src/
tsconfig.json
webpack.config.js
</code></pre>
<h2 id="迁移插件"><a class="header" href="#迁移插件">迁移插件</a></h2>
<hr />
<p>用 webpack 迁移现有的插件是很容易的，整个过程就像我们上面的指南一样。真实的例子如 VS Code 的 References 视图就是从这个<a href="https://github.com/Microsoft/vscode-references-view/pull/50">pull request</a>应用了 webpack 而来的。</p>
<p>在里面，你可以看到：</p>
<ul>
<li><code>devDependencies</code>中添加<code>webpack</code>，<code>webpack-cli</code>和<code>ts-loader</code></li>
<li>更新 npm 脚本以便开发时使用 webpack</li>
<li>更新调试配置文件<code>launch.json</code></li>
<li>添加和修改<code>webpack.config.js</code></li>
<li>更新<code>.vscodeignore</code>排除<code>node_modules</code>和其他开发时产生的临时文件</li>
<li>开始享受体积更小、安装更快的插件！</li>
</ul>
<h2 id="疑难解答"><a class="header" href="#疑难解答">疑难解答</a></h2>
<hr />
<h4 id="压缩"><a class="header" href="#压缩">压缩</a></h4>
<p>使用<code>production</code>模式会执行代码压缩，它会去除源代码中的空格和注释，并把变量名和函数名进行替换——混淆和压缩。不过形如<code>Function.prototype.name</code>的代码不会压缩。</p>
<h4 id="webpack-critical-dependencies"><a class="header" href="#webpack-critical-dependencies">webpack critical dependencies</a></h4>
<p>当你运行 webpack 时，你可能会碰到像<strong>Critical dependencies: the request of a dependency is an expression</strong>字样的警告。这些警告必须立即处理，一般来说会影响到打包过程。这句话意味着 webpack 不能静态分析某些依赖，一般是由动态使用<code>require</code>导致的，比如<code>require(someDynamicVariable)</code>。</p>
<p>想要处理这类警告，你需要：</p>
<ul>
<li>将需要打包的部分变成静态的依赖。</li>
<li>通过<code>externals</code>排除这部分依赖，但是注意它们的 Javascript 文件还是应该保留在我们打包的插件里，在<code>.vscodeignore</code>中使用 glob 模式，比如<code>!node_modules/mySpecialModule</code>。</li>
</ul>
<h2 id="下一步-5"><a class="header" href="#下一步-5">下一步</a></h2>
<ul>
<li><a href="https://code.visualstudio.com/docs/editor/extension-gallery">插件市场</a> - 学习更多 VS Code 插件市场的有关内容。</li>
<li><a href="working-with-extensions//working-with-extensions/testing-extension.html">测试插件</a> - 测试插件，提高项目质量。</li>
<li><a href="working-with-extensions//working-with-extensions/continuous-integration.html">持续集成</a> - 使用 Azure Pipeline 运行插件的 CI 构建。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="持续集成"><a class="header" href="#持续集成">持续集成</a></h1>
<p>插件测试也可以用诸如<a href="https://travis-ci.org/">Travis CI</a>自动运行测试。<a href="https://github.com/Microsoft/vscode-test"><code>vscode-test</code></a>库可以基于 CI 设置插件测试，而且里面还包含了一个 Azure Pipelines 的<a href="https://github.com/microsoft/vscode-test/tree/master/sample">示例插件</a>。你可以先看看<a href="https://dev.azure.com/vscode/vscode-test/_build?definitionId=15">构建管线</a>是什么样子的，或者直接查看<a href="https://github.com/microsoft/vscode-test/blob/master/sample/azure-pipelines.yml"><code>azure-pipelines.yml</code>file</a>。</p>
<h2 id="azure-pipelines"><a class="header" href="#azure-pipelines">Azure Pipelines</a></h2>
<hr />
<p><img src="https://media.githubusercontent.com/media/Microsoft/vscode-docs/master/api/working-with-extensions/images/continuous-integration/pipelines-logo.png" alt="pipelines-logo" /></p>
<p>你可以在<a href="https://azure.microsoft.com/services/devops/">Azure DevOps</a>上创建免费的项目，它为你提供了代码托管、看板、构建和测试基础设施等等。最重要的是，你可以获得<a href="https://azure.microsoft.com/services/devops/pipelines/">10 个免费的并行任务</a>容量，用于你构建项目，不论是在 Windows, macOS 还是 Linux 上。</p>
<p>首先，你需要创建一个免费的<a href="https://azure.microsoft.com/services/devops/">Azure DevOps</a>账号，然后给你的插件创建一个<a href="https://azure.microsoft.com/en-us/features/devops-projects/">Azure DevOps 项目</a>。</p>
<p>然后，把<code>azure-pipelines.yml</code>文件添加到插件仓库的根目录下，不同于 Linux 中的<code>xvfb</code>配置脚本，需要 VS Code 运行在 Linux 的无头 CI 机器上，我们的配置文件非常简单：</p>
<pre><code class="language-yaml">trigger:
  - master

strategy:
  matrix:
    linux:
      imageName: &quot;ubuntu-16.04&quot;
    mac:
      imageName: &quot;macos-10.13&quot;
    windows:
      imageName: &quot;vs2017-win2016&quot;

pool:
  vmImage: $(imageName)

steps:
  - task: NodeTool@0
    inputs:
      versionSpec: &quot;8.x&quot;
    displayName: &quot;Install Node.js&quot;

  - bash: |
      /usr/bin/Xvfb :99 -screen 0 1024x768x24 &gt; /dev/null 2&gt;&amp;1 &amp;
      echo &quot;&gt;&gt;&gt; Started xvfb&quot;
    displayName: Start xvfb
    condition: and(succeeded(), eq(variables['Agent.OS'], 'Linux'))

  - bash: |
      echo &quot;&gt;&gt;&gt; Compile vscode-test&quot;
      yarn &amp;&amp; yarn compile
      echo &quot;&gt;&gt;&gt; Compiled vscode-test&quot;
      cd sample
      echo &quot;&gt;&gt;&gt; Run sample integration test&quot;
      yarn &amp;&amp; yarn compile &amp;&amp; yarn test
    displayName: Run Tests
    env:
      DISPLAY: &quot;:99.0&quot;
</code></pre>
<p>最后，在你的 DveOps 项目里<a href="https://docs.microsoft.com/azure/devops/pipelines/get-started-yaml?view=vsts#get-your-first-build">创建一个新的管线</a>，然后指向<code>azure-pipelines.yml</code>文件，启动 build，然后……真香~</p>
<p><img src="https://media.githubusercontent.com/media/Microsoft/vscode-docs/master/api/working-with-extensions/images/continuous-integration/pipelines.png" alt="pipelines" /></p>
<p>你可以启用持续构建——每当有 pull requests 进入特定分支的时候自动进行构建。相关内容请查看<a href="https://docs.microsoft.com/azure/devops/pipelines/build/triggers">构建管线触发器</a>。</p>
<h2 id="travis-ci"><a class="header" href="#travis-ci">Travis CI</a></h2>
<hr />
<p><a href="https://github.com/microsoft/vscode-test">vscode-test</a>还包含了一份<a href="https://github.com/microsoft/vscode-test/blob/master/.travis.yml">Travis CI 构建文件</a>，因为 Travis 上的环境变量定义和 Azure 所有不同，<code>xvfb</code>脚本也有些许不一样：</p>
<pre><code class="language-yaml">language: node_js
os:
  - osx
  - linux
node_js: 8

install:
  - |
    if [ $TRAVIS_OS_NAME == &quot;linux&quot; ]; then
      export DISPLAY=':99.0'
      /usr/bin/Xvfb :99 -screen 0 1024x768x24 &gt; /dev/null 2&gt;&amp;1 &amp;
    fi
script:
  - |
    echo &quot;&gt;&gt;&gt; Compile vscode-test&quot;
    yarn &amp;&amp; yarn compile
    echo &quot;&gt;&gt;&gt; Compiled vscode-test&quot;
    cd sample
    echo &quot;&gt;&gt;&gt; Run sample integration test&quot;
    yarn &amp;&amp; yarn compile &amp;&amp; yarn test
cache: yarn
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="插件功能-1"><a class="header" href="#插件功能-1">插件功能</a></h1>
<p>VS Code 提供了非常多的方法，供插件扩展VS Code本身的能力。但是有的时候也很难找到对的<a href="extension-capabilities//references/contribution-points.html">发布内容配置</a>和<a href="extension-capabilities//references/vscode-api.html">VS Code API</a>。这章内容将插件的功能分成了几个部分，每个部分都将告诉你：</p>
<ul>
<li>插件可以使用的功能</li>
<li>这些功能点的细节索引</li>
<li>一些插件灵感</li>
</ul>
<p>不过，我们也会告诉你一些<a href="extension-capabilities%5Cindex.html#%E9%99%90%E5%88%B6">限制</a>，为了避免插件影响到VS Code的性能和稳定性。比如：插件不可以修改VS Code UI底层的DOM。</p>
<h2 id="常用功能"><a class="header" href="#常用功能">常用功能</a></h2>
<hr />
<p><a href="extension-capabilities//extension-capabilities/common-capabilities">常用功能</a>是你在任何插件中都可能用到的核心功能。</p>
<p>这些功能包括：</p>
<ul>
<li>注册命令、配置、快捷键绑定、菜单等。</li>
<li>保存工作区或全局数据。</li>
<li>显示通知信息。</li>
<li>使用快速选择获得用户输入。</li>
<li>打开系统的文件选择工具，以便用户选择文件或文件夹。</li>
<li>使用进度API提示耗时较长的操作。</li>
</ul>
<h2 id="主题"><a class="header" href="#主题">主题</a></h2>
<hr />
<p><a href="extension-capabilities//extension-capabilities/theming">主题</a>控制着VS Code的外观——编辑器中的源代码的颜色和VS Code UI颜色。如果你曾经想要把VS Code搞成绿色，想象自己在黑客帝国里写代码，或者想要追求极简性冷淡灰色风格，那么主题章节就是为你而来。</p>
<h5 id="插件灵感"><a class="header" href="#插件灵感">插件灵感</a></h5>
<ul>
<li>改变你的代码颜色</li>
<li>改变VS Code UI颜色</li>
<li>将现有的TextMate主题应用到VS Code中</li>
<li>添加自定义图标</li>
</ul>
<h2 id="声明式添加语言特性"><a class="header" href="#声明式添加语言特性">声明式添加语言特性</a></h2>
<hr />
<p><a href="extension-capabilities//language-extensions/README#%E5%A3%B0%E6%98%8E%E5%BC%8F%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7">声明式语言特性</a>添加了基础的编程语言编辑支持，如括号匹配、自动缩进和语法高亮。这些功能都可以通过声明配置而不用写任何代码就可以获得，更高级的语言特性如IntelliSense或调试，请看<a href="extension-capabilities%5Cindex.html#%E7%BC%96%E7%A8%8B%E5%BC%8F%E6%B7%BB%E5%8A%A0%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7">编程式添加语言特性</a></p>
<h5 id="插件灵感-1"><a class="header" href="#插件灵感-1">插件灵感</a></h5>
<ul>
<li>将常用的JS代码片段打包到插件中</li>
<li>为VS Code添加新的语言支持</li>
<li>为一门语言添加或替换语法</li>
<li>通过注入的方式，扩展一门语法</li>
<li>将现有的 TextMate 语法迁移到VS Code中</li>
</ul>
<h2 id="编程式添加语言特性"><a class="header" href="#编程式添加语言特性">编程式添加语言特性</a></h2>
<hr />
<p><a href="extension-capabilities//language-extensions/README#%E7%BC%96%E7%A8%8B%E5%BC%8F%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7">编程式添加语言特性</a>可以为编程语言添加更为丰富的特性，如：悬停提示、转跳定义、错误诊断、IntelliSense和CodeLens。这些语言特性暴露于<a href="https://code.visualstudio.com/api/references/vscode-api#languages"><code>vscode.languages.*</code></a>API。语言插件可以直接使用这些API，或是自己写一个语言服务器，通过<a href="https://github.com/Microsoft/vscode-languageserver-node">语言服务器库</a>将它适配到VS Code。</p>
<p>虽然我们提供了一个<a href="extension-capabilities//language-extensions/programmatic-language-features">语言特性</a>列表，但是并不阻碍你发挥想象，自由使用这些API。比方说，在行内显示额外信息，使用CodeLens和代码悬停是非常好的方式，而错误诊断可以高亮拼写或代码风格错误。</p>
<h5 id="插件灵感-2"><a class="header" href="#插件灵感-2">插件灵感</a></h5>
<ul>
<li>鼠标悬停于API上时, 出现用法示例</li>
<li>使用诊断，报告代码风格错误</li>
<li>注册新的HTML代码格式化</li>
<li>提供丰富的IntelliSense中间件</li>
<li>为一门语言添加代码折叠、面包屑、轮廓支持</li>
</ul>
<h2 id="扩展工作台"><a class="header" href="#扩展工作台">扩展工作台</a></h2>
<hr />
<p><a href="extension-capabilities//extension-capabilities/extending-workbench">扩展工作台</a>加强了 VS Code 工作台的UI，为资源管理侧边栏添加了新的右击行为，你甚至可以用 <a href="extension-capabilities//extension-guides/tree-view">TreeView</a>API构建自定义的资源管理侧边栏。如果你的插件需要完全自定义用户界面，那就使用<a href="extension-capabilities//extension-guides/webview">Webview API</a>和HTML，CSS，Javascript构建你自己的UI。</p>
<h5 id="插件灵感-3"><a class="header" href="#插件灵感-3">插件灵感</a></h5>
<ul>
<li>自定义资源管理侧边栏的菜单行为</li>
<li>在侧边栏中创建新的、交互式的TreeView</li>
<li>定义新的活动栏视图</li>
<li>在状态栏显示新的信息</li>
<li>使用<code>WebView</code> API显示自定义内容</li>
<li>配置*源控制(git/svn等)*来源</li>
</ul>
<h2 id="调试"><a class="header" href="#调试">调试</a></h2>
<hr />
<p>你可以利用<a href="https://code.visualstudio.com/docs/editor/debugging">调试</a>来制作<a href="extension-capabilities//extension-guides/debugger-extension">调试器插件</a>，这个插件需要将VS Code的调试UI连接到真实的调试器或者运行时上。</p>
<h5 id="插件灵感-4"><a class="header" href="#插件灵感-4">插件灵感</a></h5>
<ul>
<li>通过<a href="https://microsoft.github.io/debug-adapter-protocol/implementors/adapters/">调试适配器</a>将VS Code的调试UI连接到真实的调试器或者运行时上</li>
<li>通过调试器插件添加语言支持</li>
<li>为调试配置文件添加丰富的智能提示或者悬停信息</li>
<li>为调试配置文件添加代码片段</li>
</ul>
<p>另一方面，VS Code也提供了非常多的<a href="https://code.visualstudio.com/api/references/vscode-api#debug">调试器插件API</a>，你可以用来实现任何VS Code调试器相关的功能，加强用户的调试体验。</p>
<h5 id="插件灵感-5"><a class="header" href="#插件灵感-5">插件灵感</a></h5>
<ul>
<li>动态生成调试器配置文件，启动调试器会话</li>
<li>跟踪调试会话的声明周期</li>
<li>编程式管理断点</li>
</ul>
<h2 id="限制"><a class="header" href="#限制">限制</a></h2>
<hr />
<p>最后，我还对插件也提出了一些限制。</p>
<h4 id="不可访问dom"><a class="header" href="#不可访问dom">不可访问DOM</a></h4>
<p>插件没有权限访问VS Code UI的底层DOM，<strong>禁止</strong>添加自定义的CSS 和 HTML片段到VS Code UI上。</p>
<p>我们在一直努力优化VS Code底层的web技术，为用户创造高可用、持续响应的编辑器，而我们也会继续调整这些技术中使用到的DOM。为了确保不会干扰到VS Code的性能和稳定性，同时不阻断其他插件的运行，所以我们的插件都跑在<a href="extension-capabilities//advanced-topics/extension-host">插件主机</a>进程中，而且阻止了插件直接访问DOM的途径。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="常用功能-1"><a class="header" href="#常用功能-1">常用功能</a></h1>
<p>常用功能对你的插件来说非常重要，几乎所有的都会或多或少地用到这些功能，下面我们为你简单地介绍一下它们。</p>
<h2 id="命令"><a class="header" href="#命令">命令</a></h2>
<hr />
<p>命令是VS Code 运作的核心。你可以打开<em>命令面板</em>执行，用快捷键执行，还可以在菜单中鼠标右键执行。</p>
<p>一个插件应该：</p>
<ul>
<li>使用<a href="https://code.visualstudio.com/api/references/vscode-api#commands"><code>vscode.commands</code></a>注册和执行命令</li>
<li>配置<a href="extension-capabilities//references/contribution-points#contributescommands"><code>contributes.commands</code></a>，确保命令面板中可以顺利执行你注册的命令</li>
</ul>
<p>在<a href="extension-capabilities//extension-guides/command">插件指南/命令</a>中学习更多相关内容。</p>
<h2 id="配置"><a class="header" href="#配置">配置</a></h2>
<hr />
<p>插件需要在<a href="extension-capabilities//references/contribution-points#contributesconfiguration"><code>contributes.configuration</code></a>发布内容配置点中填写有关的配置，你可以<a href="https://code.visualstudio.com/api/references/vscode-api#workspace.getConfiguration"><code>workspace.getConfiguration</code></a>API中阅读有关内容。</p>
<h2 id="键位绑定"><a class="header" href="#键位绑定">键位绑定</a></h2>
<hr />
<p>插件可以添加自定义键位映射，在<a href="extension-capabilities//references/contribution-points?id=contributeskeybindings"><code>contributes.keybindings</code></a>和<a href="https://code.visualstudio.com/docs/getstarted/keybindings">键位绑定</a>中了解更多有关内容。</p>
<h2 id="菜单"><a class="header" href="#菜单">菜单</a></h2>
<hr />
<p>插件可以自定义上下文菜单项，菜单会根据用户右击VS Code UI的不同位置而各不相同。查看更多<a href="extension-capabilities//extensibility-reference/contribution-points#contributesmenus"><code>contributes.menus</code></a>发布内容配置。</p>
<h2 id="数据储存"><a class="header" href="#数据储存">数据储存</a></h2>
<hr />
<p>VS Code中有三种数据储存方式：</p>
<ul>
<li><a href="https://code.visualstudio.com/api/references/vscode-api#ExtensionContext.workspaceState"><code>ExtensionContext.workspaceState</code></a>：键值对组成的工作区数据。当同一个工作区再次打开时会重新取出数据。</li>
<li><a href="https://code.visualstudio.com/api/references/vscode-api#ExtensionContext.globalState"><code>ExtensionContext.globalState</code></a>：键值对组成的全局数据。当插件激活时会再次取出这些数据。</li>
<li><a href="https://code.visualstudio.com/api/references/vscode-api#ExtensionContext.storagePath"><code>ExtensionContext.storagePath</code></a>：指向你的插件可以读写的本地文件夹的路径。如果你要储存比较大的数据，这是一个非常好的选择。</li>
<li><a href="https://code.visualstudio.com/api/references/vscode-api#ExtensionContext.globalStoragePath"><code>ExtensionContext.globalStoragePath</code></a>：指向你的插件可以读写的本地存储的路径。如果你要存储所有工作区内的大文件，这时一个非常好的选择。</li>
</ul>
<p>插件的执行上下文在<code>activate</code>函数中，详见<a href="extension-capabilities//get-started/extension-anatomy#%E6%8F%92%E4%BB%B6%E5%85%A5%E5%8F%A3%E6%96%87%E4%BB%B6">插件入口文件</a>。</p>
<h2 id="显示通知"><a class="header" href="#显示通知">显示通知</a></h2>
<hr />
<p>几乎所有的插件都需要在某些时候为用户提示信息。VS Code提供了3个API来展示不同重要程度的信息：</p>
<ul>
<li><a href="https://code.visualstudio.com/api/references/vscode-api#window.showInformationMessage"><code>window.showInformationMessage</code></a></li>
<li><a href="https://code.visualstudio.com/api/references/vscode-api#window.showWarningMessage"><code>window.showWarningMessage</code></a></li>
<li><a href="https://code.visualstudio.com/api/references/vscode-api#window.showErrorMessage"><code>window.showErrorMessage</code></a></li>
</ul>
<h2 id="快速选择"><a class="header" href="#快速选择">快速选择</a></h2>
<hr />
<p>使用<a href="https://code.visualstudio.com/api/references/vscode-api#QuickPick"><code>vscode.QuickPick</code></a>API，你可以轻松地收集用户输入或者为用户显示选择列表。<a href="https://github.com/Microsoft/vscode-extension-samples/tree/master/quickinput-sample">快速输入 示例</a>将详细解释这个API。</p>
<h2 id="文件选择"><a class="header" href="#文件选择">文件选择</a></h2>
<hr />
<p>插件可以使用<a href="https://code.visualstudio.com/api/references/vscode-api#vscode.window.showOpenDialog"><code>vscode.window.showOpenDialog</code></a>API打开系统文件选择器，然后选择文件或是文件夹。</p>
<h2 id="输出渠道"><a class="header" href="#输出渠道">输出渠道</a></h2>
<hr />
<p><em>输出面板</em>显示了一组<a href="https://code.visualstudio.com/api/references/vscode-api#OutputChannel"><code>输出渠道</code></a>，以便于你查看日志。你可以使用<a href="https://code.visualstudio.com/api/references/vscode-api#window.createOutputChannel"><code>window.createOutputChannel</code></a>创建一个新的输出渠道。</p>
<h2 id="进度api"><a class="header" href="#进度api">进度API</a></h2>
<hr />
<p>使用<a href="https://code.visualstudio.com/api/references/vscode-api#Progress"><code>vscode.Progress</code></a>将处理进度报告给用户。</p>
<p>通过<a href="https://code.visualstudio.com/api/references/vscode-api#ProgressLocation"><code>ProgressLocation</code></a>选项，进度可以显示在不同的区域：</p>
<ul>
<li>显示在通知区</li>
<li>显示在源控制视图</li>
<li>VS Code窗口中的通用进度条位置</li>
</ul>
<p>详见<a href="https://github.com/Microsoft/vscode-extension-samples/tree/master/progress-sample">进度 示例</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="主题-1"><a class="header" href="#主题-1">主题</a></h1>
<p>VS Code中的主题分为两类：</p>
<ul>
<li><strong>色彩主题</strong>：UI组件ID和文本符号ID到色彩间的映射。通过色彩主题你可以修改VS Code UI组和编辑器中的文本。</li>
<li><strong>图标主题</strong>：文件类型/名称到图片之间的映射。文件图标显示于VS Code的资源管理侧边栏、快速打开列表和编辑器Tab等UI中。</li>
</ul>
<h2 id="色彩主题"><a class="header" href="#色彩主题">色彩主题</a></h2>
<hr />
<p><img src="https://media.githubusercontent.com/media/Microsoft/vscode-docs/master/api/extension-capabilities/images/theming/color-theme.png" alt="color-theme" /></p>
<p>如上图所示，色彩主题定义了2种映射：</p>
<ul>
<li><code>colors</code>控制UI组件的颜色</li>
<li><code>tokenColors</code>控制了每个代码标记单元(你的代码会根据<a href="extension-capabilities//language-extensions/syntax-highlight-guide">语法</a>分割成一个个标记单元)的颜色。</li>
</ul>
<p>创建主题详见<a href="extension-capabilities//extension-guides/color-theme">色彩主题指南</a>和<a href="https://github.com/Microsoft/vscode-extension-samples/tree/master/theme-sample">色彩主题 示例</a></p>
<h2 id="图标主题"><a class="header" href="#图标主题">图标主题</a></h2>
<hr />
<p>图标主题允许你：</p>
<ul>
<li>将图标ID映射至图片或者字体图标上。</li>
<li>根据文件名或这个文件的语言类型关联上图标ID</li>
</ul>
<p><a href="extension-capabilities//extension-guides/icon-theme">图标主题指南</a>会详细探讨其中的细节。
<img src="https://media.githubusercontent.com/media/Microsoft/vscode-docs/master/api/extension-capabilities/images/theming/file-icon-theme.png" alt="file-icon-theme" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="扩展工作台-1"><a class="header" href="#扩展工作台-1">扩展工作台</a></h1>
<p>“工作台”是指整个VS Code UI和其中包含的下列UI 组件：</p>
<ul>
<li>标题栏</li>
<li>活动栏</li>
<li>侧边栏</li>
<li>面板</li>
<li>编辑器群</li>
<li>状态栏</li>
</ul>
<p>VS Code提供了各式各样的API让在工作台你添加自己的组件。比如下图：</p>
<p><img src="https://code.visualstudio.com/assets/api/extension-capabilities/extending-workbench/workbench-contribution.png" alt="workbench-contribution" /></p>
<ul>
<li>活动栏：<a href="https://marketplace.visualstudio.com/items?itemName=ms-azuretools.vscode-azureappservice">Azure App Service extension</a>添加了一个<a href="extension-capabilities/extending-workbench.html#%E8%A7%86%E5%9B%BE%E5%AE%B9%E5%99%A8">视图容器</a></li>
<li>侧边栏：内置的<a href="https://github.com/Microsoft/vscode/tree/master/extensions/npm">NPM 插件</a> 添加了一个 <a href="extension-capabilities/extending-workbench.html#%E6%A0%91%E8%A7%86%E5%9B%BE">Tree View</a> 到资源管理器视图</li>
<li>编辑器群：内置的<a href="https://github.com/Microsoft/vscode/tree/master/extensions/markdown-language-features">Markdown 插件</a> 添加了一个<a href="extension-capabilities/extending-workbench.html#webview">Webview</a> 到编辑器的旁边</li>
<li>状态栏：<a href="https://marketplace.visualstudio.com/items?itemName=vscodevim.vim">VSCodeVim 插件</a> 添加了一个<a href="extension-capabilities/extending-workbench.html#%E7%8A%B6%E6%80%81%E6%A0%8F%E9%A1%B9">状态栏项目</a></li>
</ul>
<h2 id="视图容器"><a class="header" href="#视图容器">视图容器</a></h2>
<hr />
<p>在<a href="extension-capabilities//extensibility-reference/contribution-points?id=contributesviewscontainers"><code>contributes.viewsContainers</code></a>发布内容配置中，你可以添加新的视图容器在5个内置的视图容器中。学习更多<a href="extension-capabilities//extension-guides/tree-view">树视图</a>。</p>
<h2 id="树视图"><a class="header" href="#树视图">树视图</a></h2>
<hr />
<p>在<a href="extension-capabilities//extensibility-reference/contribution-points?#contributesviews"><code>contributes.views</code></a>发布内容配置中，你可以添加在任何视图容器岁添加新的视图。学习更多<a href="extension-capabilities//extension-guides/tree-view">树视图</a>。</p>
<h2 id="webview"><a class="header" href="#webview">Webview</a></h2>
<hr />
<p>Webview是使用HTML/CSS/JS高度定制的视图。它们显示在编辑器区域中。详见<a href="extension-capabilities//extension-guides/webview">Webview指南</a>。</p>
<h2 id="状态栏项"><a class="header" href="#状态栏项">状态栏项</a></h2>
<hr />
<p>插件可以创建自定义的<a href="https://code.visualstudio.com/api/references/vscode-api#StatusBarItem"><code>StatusBarItem</code></a>显示在状态栏中。状态栏项可以显示文本和图标，还可以在点击事件触发时运行命令。</p>
<ul>
<li>显示文本和图标</li>
<li>点击时运行命令</li>
</ul>
<p>状态栏插件的例子可以<a href="https://github.com/Microsoft/vscode-extension-samples/tree/master/statusbar-sample">戳这里</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="插件指南"><a class="header" href="#插件指南">插件指南</a></h1>
<p>通过<a href="extension-guides//get-started/your-first-extension">Hello World</a>学习过基本的VS Code插件API之后，现在是时间搞搞真正的插件了。在<a href="extension-guides//extension-capabilities/README">插件功能</a>章节，在更宽泛的层面上介绍了插件<strong>能做</strong>些什么，本章则细化了各个功能点，并提供了<strong>详细的代码</strong>和VS Code API的解释。</p>
<p>在每个指南-示例组合中，你将会看到：</p>
<ul>
<li>贯穿整个代码的注释</li>
<li>使用示例插件的gif或者图片</li>
<li>运行示例插件指引</li>
<li>使用过的VS Code API列表</li>
<li>使用过的配置点列表</li>
<li>真正的组合插件示例</li>
<li>API概念解释</li>
</ul>
<h2 id="指南和例子"><a class="header" href="#指南和例子">指南和例子</a></h2>
<hr />
<p>下面是一份指南和例子的表格，虽然每个指南都要有示例代码，但是一些示例目前暂时还没有与之匹配的指南。</p>
<p>每个例子都至少阐释了一个<a href="extension-guides//references/vscode-api">VS Code API</a>或者<a href="extension-guides//references/contribution-points">发布内容配置</a>的使用。</p>
<div class="table-wrapper"><table><thead><tr><th>例子</th><th>VS Code网页指南</th><th>API &amp; 配置</th></tr></thead><tbody>
<tr><td><a href="https://github.com/Microsoft/vscode-extension-samples/tree/master/webview-sample">Webview Sample</a></td><td><a href="extension-guides//extension-guides/webview">/extension-guides/webview</a></td><td><a href="https://code.visualstudio.com/api/references/vscode-api#window.createWebviewPanel">window.createWebviewPanel</a><br><a href="https://code.visualstudio.com/api/references/vscode-api#window.registerWebviewPanelSerializer">window.registerWebviewPanelSerializer</a></td></tr>
<tr><td><a href="https://github.com/Microsoft/vscode-extension-samples/tree/master/statusbar-sample">Status Bar Sample</a></td><td>N/A</td><td><a href="https://code.visualstudio.com/api/references/vscode-api#window.createStatusBarItem">window.createStatusBarItem</a><br><a href="https://code.visualstudio.com/api/references/vscode-api#StatusBarItem">StatusBarItem</a></td></tr>
<tr><td><a href="https://github.com/Microsoft/vscode-extension-samples/tree/master/tree-view-sample">Tree View Sample</a></td><td><a href="extension-guides//extension-guides/tree-view">/extension-guides/tree-view</a></td><td><a href="https://code.visualstudio.com/api/references/vscode-api#window.createTreeView">window.createTreeView</a><br><a href="https://code.visualstudio.com/api/references/vscode-api#window.registerTreeDataProvider">window.registerTreeDataProvider</a><br><a href="https://code.visualstudio.com/api/references/vscode-api#TreeView">TreeView</a><br><a href="https://code.visualstudio.com/api/references/vscode-api#TreeDataProvider">TreeDataProvider</a><br><a href="extension-guides//references/contribution-points?#contributesviews">contributes.views</a><br><a href="extension-guides//references/contribution-points#contributesviewscontainers">contributes.viewsContainers</a></td></tr>
<tr><td><a href="https://github.com/Microsoft/vscode-extension-samples/tree/master/task-provider-sample">Task Provider Sample</a></td><td><a href="extension-guides//extension-guides/task-provider">/extension-guides/task-provider</a></td><td><a href="https://code.visualstudio.com/api/references/vscode-api#tasks.registerTaskProvider">tasks.registerTaskProvider</a><br><a href="https://code.visualstudio.com/api/references/vscode-api#Task">Task</a><br><a href="https://code.visualstudio.com/api/references/vscode-api#ShellExecution">ShellExecution</a><br><a href="extension-guides//references/contribution-points?id=contributestaskdefinitions">contributes.taskDefinitions</a></td></tr>
<tr><td><a href="https://github.com/Microsoft/vscode-extension-samples/tree/master/basic-multi-root-sample">Multi Root Sample</a></td><td>N/A</td><td><a href="https://code.visualstudio.com/api/references/vscode-api#workspace.getWorkspaceFolder">workspace.getWorkspaceFolder</a><br><a href="https://code.visualstudio.com/api/references/vscode-api#workspace.onDidChangeWorkspaceFolders">workspace.onDidChangeWorkspaceFolders</a></td></tr>
<tr><td><a href="https://github.com/Microsoft/vscode-extension-samples/tree/master/completions-sample">Completion Provider Sample</a></td><td>N/A</td><td><a href="https://code.visualstudio.com/api/references/vscode-api#languages.registerCompletionItemProvider">languages.registerCompletionItemProvider</a><br><a href="https://code.visualstudio.com/api/references/vscode-api#CompletionItem">CompletionItem</a><br><a href="https://code.visualstudio.com/api/references/vscode-api#SnippetString">SnippetString</a></td></tr>
<tr><td><a href="https://github.com/Microsoft/vscode-extension-samples/tree/master/fsprovider-sample">File System Provider Sample</a></td><td>N/A</td><td><a href="https://code.visualstudio.com/api/references/vscode-api#workspace.registerFileSystemProvider">workspace.registerFileSystemProvider</a></td></tr>
<tr><td><a href="https://github.com/Microsoft/vscode-extension-samples/tree/master/decorator-sample">Editor Decorator Sample</a></td><td>N/A</td><td><a href="https://code.visualstudio.com/api/references/vscode-api#TextEditor.setDecorations">TextEditor.setDecorations</a><br><a href="https://code.visualstudio.com/api/references/vscode-api#DecorationOptions">DecorationOptions</a><br><a href="https://code.visualstudio.com/api/references/vscode-api#DecorationInstanceRenderOptions">DecorationInstanceRenderOptions</a><br><a href="https://code.visualstudio.com/api/references/vscode-api#ThemableDecorationInstanceRenderOptions">ThemableDecorationInstanceRenderOptions</a><br><a href="https://code.visualstudio.com/api/references/vscode-api#window.createTextEditorDecorationType">window.createTextEditorDecorationType</a><br><a href="https://code.visualstudio.com/api/references/vscode-api#TextEditorDecorationType">TextEditorDecorationType</a><br><a href="extension-guides//references/contribution-points#contributescolors">contributes.colors</a></td></tr>
<tr><td><a href="https://github.com/Microsoft/vscode-extension-samples/tree/master/i18n-sample">I18n Sample</a></td><td>N/A</td><td></td></tr>
<tr><td><a href="https://github.com/Microsoft/vscode-extension-samples/tree/master/terminal-sample">Terminal Sample</a></td><td>N/A</td><td><a href="https://code.visualstudio.com/api/references/vscode-api#window.createTerminal">window.createTerminal</a><br><a href="https://code.visualstudio.com/api/references/vscode-api#window.onDidChangeActiveTerminal">window.onDidChangeActiveTerminal</a><br><a href="https://code.visualstudio.com/api/references/vscode-api#window.onDidCloseTerminal">window.onDidCloseTerminal</a><br><a href="https://code.visualstudio.com/api/references/vscode-api#window.onDidOpenTerminal">window.onDidOpenTerminal</a><br><a href="https://code.visualstudio.com/api/references/vscode-api#window.Terminal">window.Terminal</a><br><a href="https://code.visualstudio.com/api/references/vscode-api#window.terminals">window.terminals</a></td></tr>
<tr><td><a href="https://github.com/Microsoft/vscode-extension-samples/tree/master/vim-sample">Vim Sample</a></td><td>N/A</td><td><a href="https://code.visualstudio.com/api/references/vscode-api#commands">commands</a><br><a href="https://code.visualstudio.com/api/references/vscode-api#StatusBarItem">StatusBarItem</a><br><a href="https://code.visualstudio.com/api/references/vscode-api#window.createStatusBarItem">window.createStatusBarItem</a><br><a href="https://code.visualstudio.com/api/references/vscode-api#TextEditorCursorStyle">TextEditorCursorStyle</a><br><a href="https://code.visualstudio.com/api/references/vscode-api#window.activeTextEditor">window.activeTextEditor</a><br><a href="https://code.visualstudio.com/api/references/vscode-api#Position">Position</a><br><a href="https://code.visualstudio.com/api/references/vscode-api#Range">Range</a><br><a href="https://code.visualstudio.com/api/references/vscode-api#Selection">Selection</a><br><a href="https://code.visualstudio.com/api/references/vscode-api#TextEditor">TextEditor</a><br><a href="https://code.visualstudio.com/api/references/vscode-api#TextEditorRevealType">TextEditorRevealType</a><br><a href="https://code.visualstudio.com/api/references/vscode-api#TextDocument">TextDocument</a></td></tr>
</tbody></table>
</div>
<h2 id="语言插件示例"><a class="header" href="#语言插件示例">语言插件示例</a></h2>
<hr />
<p>下面的部分是<a href="extension-guides//language-extensions/README">语言插件</a>相关示例：</p>
<div class="table-wrapper"><table><thead><tr><th>例子</th><th>VS Code网页指南</th></tr></thead><tbody>
<tr><td><a href="https://github.com/Microsoft/vscode-extension-samples/tree/master/snippet-sample">Snippet Sample</a></td><td><a href="extension-guides//language-extensions/snippet-guide">/language-extensions/snippet-guide</a></td></tr>
<tr><td><a href="https://github.com/Microsoft/vscode-extension-samples/tree/master/language-configuration-sample">Language Configuration Sample</a></td><td><a href="extension-guides//language-extensions/language-configuration-guide">/language-extensions/language-configuration-guide</a></td></tr>
<tr><td><a href="https://github.com/Microsoft/vscode-extension-samples/tree/master/lsp-sample">LSP Sample</a></td><td><a href="extension-guides//language-extensions/language-server-extension-guide">/language-extensions/language-server-extension-guide</a></td></tr>
<tr><td><a href="https://github.com/Microsoft/vscode-extension-samples/tree/master/lsp-log-streaming-sample">LSP Log Streaming Sample</a></td><td>N/A</td></tr>
<tr><td><a href="https://github.com/Microsoft/vscode-extension-samples/tree/master/lsp-multi-server-sample">LSP Multi Root Server Sample</a></td><td>https://github.com/Microsoft/vscode/wiki/Adopting-Multi-Root-Workspace-APIs#language-client--language-server</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="命令-1"><a class="header" href="#命令-1">命令</a></h1>
<p>命令会触发VS Code中注册的行为，如果你<a href="https://code.visualstudio.com/docs/getstarted/keybindings">配置过键位</a>，那么你就处理过了命令。命令也是插件将功能暴露给用户的地方，它绑定了VS Code UI中的行为，并在内部处理了相关逻辑。</p>
<h2 id="使用命令"><a class="header" href="#使用命令">使用命令</a></h2>
<hr />
<p>VS Code内部含有大量和编辑器交互、控制UI、后台操作的<a href="extension-guides//references/commands">内置命令</a>。许多插件将它们的核心功能暴露为<em>命令</em>的形式供用户或者其他插件使用。</p>
<h3 id="程序性执行一个命令"><a class="header" href="#程序性执行一个命令">程序性执行一个命令</a></h3>
<p><a href="https://code.visualstudio.com/api/references/vscode-api#commands.executeCommand"><code>vscode.commands.executeCommand</code></a>API可以程序性调用一个命令，你可以通过它将VS Code的内置函数构建在你的插件中，比如VS Code内置的Git和Markdown插件中的东西。</p>
<p>我们看个例子🌰：<code>editor.action.addCommentLine</code>命令可以将当前选中行变成注释(你可以偷偷把这个功能地集成到你自己的插件中哦)：</p>
<pre><code class="language-typescript">import * as vscode from 'vscode';

function commentLine() {
	vscode.commands.executeCommand('editor.action.addCommentLine');
}
</code></pre>
<p>有些命令可以接收改变行为的参数，有些会有返回结果。形如<code>vscode.executeDefinitionProvider</code>的API，它要求传入一个document的URI地址和position作为参数，并返回一个包含定义列表的promise：</p>
<pre><code class="language-typescript">import * as vscode from 'vscode';

async function printDefinitionsForActiveEditor() {
	const activeEditor = vscode.window.activeTextEditor;
	if (!activeEditor) {
		return;
	}

	const definitions = await vscode.commands.executeCommand&lt;vscode.Location[]&gt;(
		'vscode.executeDefinitionProvider',
		activeEditor.document.uri,
		activeEditor.selection.active
	);

	for (const definition of definitions) {
		console.log(definition);
	}
}
</code></pre>
<p>更多命令详见：</p>
<ul>
<li><a href="https://code.visualstudio.com/docs/getstarted/keybindings">浏览键盘快捷键</a></li>
<li><a href="extension-guides//references/commands">VS Code内置高级命令API</a></li>
</ul>
<h3 id="命令的urls"><a class="header" href="#命令的urls">命令的URLs</a></h3>
<p>命令URI是执行注册命令的链接。它们可被用于悬停文本上的可点击链接，代码补全提示中的细节信息，甚至可以出现在webview中。</p>
<p>命令URI使用<code>command</code>作为协议头，然后紧跟着命令名称。比如：<code>editor.action.addCommentLine</code>的命令URI是：<code>command:editor.action.addCommentLine</code>。下面是一个显示在当前行注释中显示链接的悬停函数。</p>
<pre><code class="language-typescript">import * as vscode from 'vscode';

export function activate(context: vscode.ExtensionContext) {
	vscode.languages.registerHoverProvider(
		'javascript',
		new class implements vscode.HoverProvider {
			provideHover(
				_document: vscode.TextDocument,
				_position: vscode.Position,
				_token: vscode.CancellationToken
			): vscode.ProviderResult&lt;vscode.Hover&gt; {
				const commentCommandUri = vscode.Uri.parse(`command:editor.action.addCommentLine`);
				const contents = new vscode.MarkdownString(`[Add comment](${commentCommandUri})`);

				// command URIs如果想在Markdown 内容中生效, 你必须设置`isTrusted`。
				// 当创建可信的Markdown 字符, 请合理地清理所有的输入内容
				// 以便你期望的命令command URIs生效
				contents.isTrusted = true;

				return new vscode.Hover(contents);
			}
		}()
	);
}
</code></pre>
<p>命令上的参数列表会从JSON数组变成URI格式：下面的例子使用了<code>git.stage</code>命令创建一个悬停操作——将当前文件进行git暂存：</p>
<pre><code class="language-typescript">import * as vscode from 'vscode';

export function activate(context: vscode.ExtensionContext) {
	vscode.languages.registerHoverProvider(
		'javascript',
		new class implements vscode.HoverProvider {
			provideHover(
				document: vscode.TextDocument,
				_position: vscode.Position,
				_token: vscode.CancellationToken
			): vscode.ProviderResult&lt;vscode.Hover&gt; {
				const args = [{ resourceUri: document.uri }];
				const commentCommandUri = vscode.Uri.parse(
					`command:git.stage?${encodeURIComponent(JSON.stringify(args))}`
				);
				const contents = new vscode.MarkdownString(`[Stage file](${commentCommandUri})`);
				contents.isTrusted = true;
				return new vscode.Hover(contents);
			}
		}()
	);
}
</code></pre>
<h2 id="新建命令"><a class="header" href="#新建命令">新建命令</a></h2>
<hr />
<h3 id="注册一个命令"><a class="header" href="#注册一个命令">注册一个命令</a></h3>
<p><a href="https://code.visualstudio.com/api/references/vscode-api#commands.registerCommand"><code>vscode.commands.registerCommand</code></a>会把命令ID绑定到你插件的函数上：</p>
<pre><code class="language-typescript">import * as vscode from 'vscode';

export function activate(context: vscode.ExtensionContext) {
	const command = 'myExtension.sayHello';

	const commandHandler = (name?: string = 'world') =&gt; {
		console.log(`Hello ${name}!!!`);
	};

	context.subscriptions.push(vscode.commands.registerCommand(command, commandHandler));
}
</code></pre>
<p>只要<code>myExtension.sayHello</code>命令执行，就会调用对应的处理函数，你也可以通过<code>executeCommand</code>程序性调用它，或者从VS Code UI中，抑或快捷键的方式调用。</p>
<h3 id="创建面向用户的命令"><a class="header" href="#创建面向用户的命令">创建面向用户的命令</a></h3>
<p><code>vscode.commands.registerCommand</code>仅仅是将命令id绑定到了处理函数上，如果想让用户从<em>命令面板</em>中找到你的命令，你还需要在<code>package.json</code>中配置对应的命令<code>配置项(contribution)</code>：</p>
<pre><code class="language-json">{
	&quot;contributes&quot;: {
		&quot;commands&quot;: [
			{
				&quot;command&quot;: &quot;myExtension.sayHello&quot;,
				&quot;title&quot;: &quot;Say Hello&quot;
			}
		]
	}
}
</code></pre>
<p><code>commands</code>配置告诉VS Code你的插件提供了一个命令，而且允许你控制命令在UI中的显示。现在，我们的命令终于出现在<em>命令面板</em>中了：</p>
<p><img src="https://media.githubusercontent.com/media/Microsoft/vscode-docs/master/api/extension-guides/images/commands/palette.png" alt="命令面板" /></p>
<p>我们依旧需要使用<code>registerCommand</code>将真实的命令id绑定到函数上。也就是说，如果我们的插件没有激活，那么用户从<em>命令面板</em>中选择<code>myExtension.sayHello</code>也不会有任何效果。为了避免这种事，插件必须注册一个面向全部用户场景的命令<code>onCommand</code> <code>activiationEvent</code>：</p>
<pre><code class="language-json">{
	&quot;activationEvents&quot;: [&quot;onCommand:myExtension.sayHello&quot;]
}
</code></pre>
<p>现在当用户第一次调用<code>myExtension.sayHello</code>时，插件就会自动激活，<code>registerCommand</code>会将<code>myExtension.sayHello</code>绑定到正确的处理函数上。</p>
<p>对于内部命令你不需要使用<code>onCommand</code>，但是下面的场景中你必须定义好激活事件：</p>
<ul>
<li>需要使用<em>命令面板</em>调用</li>
<li>需要快捷键调用</li>
<li>需要通过VS Code UI调用，比如在编辑器标题栏上触发</li>
<li>意在供其他插件使用时</li>
</ul>
<h3 id="控制命令出现在命令面板的时机"><a class="header" href="#控制命令出现在命令面板的时机">控制命令出现在<em>命令面板</em>的时机</a></h3>
<p>默认情况下，所有<em>命令面板</em>中出现的命令都可以在<code>package.json</code>的<code>commands</code>部分中配置。不过，有些命令是场景相关的，比如在特定的语言的编辑器中，或者只有用户设置了某些选项时才展示。</p>
<p><a href="extension-guides//references/contribution-points#contributesmenus"><code>menus.commandPalette</code></a>发布内容配置运行你限制命令出现在<em>命令面板</em>的时机。你需要配置命令ID和一条<a href="https://code.visualstudio.com/docs/getstarted/keybindings#_when-clause-contexts">when语句</a>：</p>
<pre><code class="language-json">{
	&quot;contributes&quot;: {
		&quot;menus&quot;: {
			&quot;commandPalette&quot;: [
				{
					&quot;command&quot;: &quot;myExtension.sayHello&quot;,
					&quot;when&quot;: &quot;editorLangId == markdown&quot;
				}
			]
		}
	}
}
</code></pre>
<p>现在<code>myExtension.sayHello</code>命令只会出现在用户的Markdown文件中了。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="色彩主题-1"><a class="header" href="#色彩主题-1">色彩主题</a></h1>
<p>色彩可视化工作在VS Code可以分成两种类型：</p>
<ul>
<li>工作台（Workbench）色彩：在视图和编辑器中使用的工作台（Workbench）色彩，包括视图、编辑器、活动栏、状态栏等。整个色彩列表<a href="extension-guides//references/theme-color">查看这里</a>。</li>
<li>语法色彩：语法色彩就是编辑器中代码的颜色，它基于TextMate语法和TextMate主题规则进行着色。</li>
</ul>
<p>下面将分别介绍这两种类型。</p>
<h2 id="工作台色彩"><a class="header" href="#工作台色彩">工作台色彩</a></h2>
<hr />
<p>创建工作台色彩最简单的方式就是使用现成的主题，然后开始定制。</p>
<ul>
<li>在VS Code中切换到你想要编辑的色彩主题。</li>
<li>打开<a href="https://code.visualstudio.com/docs/getstarted/settings">设置</a>，用<code>workbench.colorCustomizations</code>修改视图和编辑器色彩。一般来说会即时生效，如果没有生效你需要自己重启VS Code。</li>
</ul>
<p>下面是一个改变了标题栏颜色的配置</p>
<pre><code class="language-json">{
	&quot;workbench.colorCustomizations&quot;: {
		&quot;titleBar.activeBackground&quot;: &quot;#ff0000&quot;
	}
}
</code></pre>
<ul>
<li><a href="extension-guides//references/theme-color">完整的主题色彩列表</a></li>
</ul>
<h2 id="语法色彩"><a class="header" href="#语法色彩">语法色彩</a></h2>
<hr />
<p>新建语法高亮色彩有两种方式：</p>
<ul>
<li>直接使用社区现成的TextMate主题（<code>.tmTheme</code>文件）</li>
<li>自己想一个主题规则出来</li>
</ul>
<p>当然，还有更简单的方式：</p>
<ul>
<li>切换到色彩主题，用<a href="https://code.visualstudio.com/docs/getstarted/settings">设置</a>中的<code>editor.tokenColorCustomizations</code>进行自定义，就像上面修改工作台色彩一样，修改会立即呈现，你不需要重启VS Code。</li>
</ul>
<p>下面的例子修改了编辑器中注释的颜色：</p>
<pre><code class="language-json">{
	&quot;editor.tokenColorCustomizations&quot;: {
		&quot;comments&quot;: &quot;#FF0000&quot;
	}
}
</code></pre>
<p>设置支持一些简单的语法标识模型，比如“comments”，“strings”，“numbers”等等。如果你想定制更多颜色，那么直接应用TextMate语法规则就可以了，详见<a href="extension-guides//language-extensions/syntax-highlight-guide">语法高亮指南</a>。</p>
<h2 id="创建新的色彩主题"><a class="header" href="#创建新的色彩主题">创建新的色彩主题</a></h2>
<hr />
<p>既然你已经用过<code>workbench.colorCustomizations</code>和<code>editor.tokenColorCustomizations</code>笨拙地修改过颜色，那么接下来我们可以见识见识大杀器了。</p>
<ul>
<li>打开<strong>命令面板</strong>输入<strong>Developer: Generate Color Theme from Current Settings</strong></li>
<li>使用VS Code的 <a href="http://yeoman.io/">Yeoman</a> 插件生成器，生成新的主题：</li>
</ul>
<pre><code class="language-bash">npm install -g yo generator-code
yo code
</code></pre>
<ul>
<li>如果你像下图这样选择了自定义主题，则选择'Start fresh'</li>
</ul>
<p><img src="https://media.githubusercontent.com/media/Microsoft/vscode-docs/master/api/extension-guides/images/color-theme/yocode-colortheme.png" alt="生成新主题" /></p>
<ul>
<li>把从设置中生成的主题文件复制到新的插件中</li>
<li>如果你想使用现成的TextMate主题，那你就需要在插件生成的时候选择导入TextMate主题并打包。另外，如果你下载了一个主题，那么只要用<code>.tmTheme</code>链接替换<code>tokenColors</code>部分就可以了。</li>
</ul>
<pre><code class="language-json">{
    &quot;type&quot;: &quot;dark&quot;,
    &quot;colors&quot;: {
        &quot;editor.background&quot;: &quot;#1e1e1e&quot;,
        &quot;editor.foreground&quot;: &quot;#d4d4d4&quot;,
        &quot;editorIndentGuide.background&quot;: &quot;#404040&quot;,
        &quot;editorRuler.foreground&quot;: &quot;#333333&quot;,
        &quot;activityBarBadge.background&quot;: &quot;#007acc&quot;,
        &quot;sideBarTitle.foreground&quot;: &quot;#bbbbbb&quot;
    },
    &quot;tokenColors&quot;: &quot;./Diner.tmTheme&quot;
}
</code></pre>
<p>?&gt; 为你的色彩文件添加<code>.color-theme.json</code>前缀，那么你在编辑这个文件时就能自动获得悬浮提示、代码补全、色彩装饰器和色彩选择器等功能了。</p>
<p>?&gt; <a href="https://colorsublime.github.io/">ColorSublime</a>有成百上千个现成的TextMate主题。你可以选择一个你喜欢的主题，复制下载链接，然后用Yeoman选择这个主题生成你的插件。格式如：<code>&quot;https://raw.githubusercontent.com/Colorsublime/Colorsublime-Themes/master/themes/(name).tmTheme&quot;</code></p>
<h2 id="测试新的主题"><a class="header" href="#测试新的主题">测试新的主题</a></h2>
<hr />
<p>通过按<kbd>F5</kbd>打开一个插件主机开发窗口，来测试主题。</p>
<p>通过<strong>文件 &gt; 首选项 &gt; 颜色主题</strong>，在下拉菜单里找到你的主题。然后通过移动<kbd>上下箭头</kbd>，预览你自己的主题。</p>
<p><img src="https://media.githubusercontent.com/media/Microsoft/vscode-docs/master/api/extension-guides/images/color-theme/mytheme.png" alt="选择我的主题" /></p>
<p>主题文件的改动，会实时同步到<code>插件开发主机</code>窗口。</p>
<h2 id="将主题发布到插件市场"><a class="header" href="#将主题发布到插件市场">将主题发布到插件市场</a></h2>
<hr />
<p>如果你想把主题分享给社区，通过<a href="https://code.visualstudio.com/docs/editor/extension-gallery">插件市场</a>去发布它吧。用<a href="extension-guides//working-with-extensions/publish-extension">vsce publishing tool</a>打包你的主题然后发布到VS Code市场。</p>
<p>?&gt; 小贴士：想要用户轻松地找到你的主题，最好修改一下<code>package.json</code>，把关键字&quot;theme&quot;写到插件描述（extension description）中，然后把<code>Category</code>设置为<code>Theme</code></p>
<p>要想让你的插件在插件市场上看起来更好一点，我们建议你参考一下<a href="extension-guides//references/extension-manifest#%E6%8F%92%E4%BB%B6%E5%B8%82%E5%9C%BA%E5%B1%95%E7%A4%BA%E5%B0%8F%E8%B4%B4%E5%A3%AB">插件市场展示小贴士</a>。</p>
<h2 id="添加新的色彩id"><a class="header" href="#添加新的色彩id">添加新的色彩id</a></h2>
<hr />
<p><a href="extension-guides//references/contribution-points#contributescolors">色彩配置点</a>可以配置插件的<em>色彩id</em>，当在<code>workbench.colorCustomizations</code>和主题文件中使用代码补全时，这些色彩也会出现。用户可以在<a href="https://code.visualstudio.com/docs/editor/extension-gallery#_extension-details">插件配置</a>选项卡中看到插件定义了什么颜色。</p>
<h2 id="更多"><a class="header" href="#更多">更多</a></h2>
<ul>
<li><a href="https://css-tricks.com/creating-a-vs-code-theme/">CSS Tricks - 新建一个VS Code主题</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="图标主题-1"><a class="header" href="#图标主题-1">图标主题</a></h1>
<p>VS Code的UI在文件名称左边显示图标，插件配置的图标系列可以让用户自由选择他们喜爱的图标。</p>
<h2 id="添加新的图标主题"><a class="header" href="#添加新的图标主题">添加新的图标主题</a></h2>
<hr />
<p>你能使用图标文件（最好是SVG）和字体图标创建自己的图标主题。作为示例，你可以参考一下2个内置主题：<a href="https://github.com/Microsoft/vscode/tree/master/extensions/theme-defaults">Minimal</a>，<a href="https://github.com/Microsoft/vscode/tree/master/extensions/theme-seti">Seti</a></p>
<p>首先，创建一个VS Code插件，然后把<code>iconTheme</code>配置点(contribution point)添加进去</p>
<pre><code class="language-json">&quot;contributes&quot;: {
    &quot;iconThemes&quot;: [
        {
            &quot;id&quot;: &quot;turtles&quot;,
            &quot;label&quot;: &quot;Turtles&quot;,
            &quot;path&quot;: &quot;./fileicons/turtles-icon-theme.json&quot;
        }
    ]
}
</code></pre>
<ul>
<li><code>id</code>作为这个图标主题的标识，目前只做内部使用，未来可能会用在设置里面，所以最好设置一个可读性强的唯一值。</li>
<li><code>label</code>会显示在<em>主题选择</em>下拉框中。</li>
<li><code>path</code>指示了图标集所在的位置。如果你的图标系列名称遵循<code>*icon-theme.json</code>命名规范，那么VS Code就能提供完整的支持。</li>
</ul>
<h3 id="图标文件集icon-set-file"><a class="header" href="#图标文件集icon-set-file">图标文件集(Icon set file)</a></h3>
<p>图标文件集是一个JSON文件，包含了所有的<strong>关联图标</strong>和图标定义。</p>
<p>一个<strong>关联图标</strong>将<strong>图标定义</strong>映射到一个文件上（类型如：文件，文件夹，json文件...）。<strong>图标定义</strong>指示了图标的所在位置：可以是一个图片文件，或者glyph字体。</p>
<h3 id="图标定义"><a class="header" href="#图标定义">图标定义</a></h3>
<p><code>iconDefinitions</code>部分包含了所有定义。每个定义有一个id，用于指向定义。一个定义能供多个文件关联引用。</p>
<pre><code class="language-json">&quot;iconDefinitions&quot;: {
    &quot;_folder_dark&quot;: {
        &quot;iconPath&quot;: &quot;./images/Folder_16x_inverse.svg&quot;
    }
}
</code></pre>
<p>这里，<strong>图标定义</strong>包含了一个标识符<code>_folder_dark</code>。除此之外还支持以下属性：</p>
<ul>
<li><code>iconPath</code>：当使用svg/png文件时：指向图片的路径。</li>
<li><code>fontCharacter</code>：当使用glyph字体时：字体中使用的字符。</li>
<li><code>fontColor</code>：当使用glyph字体时：设置glyph的颜色。</li>
<li><code>fontSize</code>：当使用字体时：设置字体大小。默认情况下会使用字体本身定义的字体大小。这个值应为父级字号的相对值(如 150%)。</li>
<li><code>fontId</code>：当使用字体时: 字体的ID。如果没有指定，则会采用<code>font specification</code>部分的第一个字体。</li>
</ul>
<h3 id="关联文件"><a class="header" href="#关联文件">关联文件</a></h3>
<p>图标能关联到文件夹，文件夹名称，文件，文件名称，文件插件，和<a href="extension-guides//references/contribution-points#contributeslanguages">语言Id</a>。</p>
<p>这些关联都能被提炼为诸如'light'和'highContrast'色彩主题。</p>
<p>每个文件关联指向一个<strong>图标定义</strong></p>
<pre><code class="language-json">&quot;file&quot;: &quot;_file_dark&quot;,
&quot;folder&quot;: &quot;_folder_dark&quot;,
&quot;folderExpanded&quot;: &quot;_folder_open_dark&quot;,
&quot;folderNames&quot;: {
    &quot;.vscode&quot;: &quot;_vscode_folder&quot;,
},
&quot;fileExtensions&quot;: {
    &quot;ini&quot;: &quot;_ini_file&quot;,
},
&quot;fileNames&quot;: {
    &quot;win.ini&quot;: &quot;_win_ini_file&quot;,
},
&quot;languageIds&quot;: {
    &quot;ini&quot;: &quot;_ini_file&quot;
},
&quot;light&quot;: {
    &quot;folderExpanded&quot;: &quot;_folder_open_light&quot;,
    &quot;folder&quot;: &quot;_folder_light&quot;,
    &quot;file&quot;: &quot;_file_light&quot;,
    &quot;fileExtensions&quot;: {
        &quot;ini&quot;: &quot;_ini_file_light&quot;,
    }
},
&quot;highContrast&quot;: {
}
</code></pre>
<ul>
<li><code>file</code>是一个默认文件图标，为那些没有匹配到任何插件、文件名、语言类型的文件所准备的。目前所有文件图标属性都会被继承(只适用于：glyphs字体、字体大小(fontSize))。</li>
<li><code>folder</code>收起的文件夹图标，如果<code>folderExpanded</code>没有设置，那么展开的文件夹也会使用这个图标。使用<code>folderNames</code>关联特殊名称的文件夹。文件夹图标是可选的，如果不设置，那文件夹就不会显示任何图标。</li>
<li><code>folderExpanded</code>展开的文件夹图标。这个图标是可选的，如果不设置就会使用<code>folder</code>定义好的图标。</li>
<li><code>folderNames</code>特殊名称文件夹图标。这个键是用于文件夹名称的，不支持包含路径的名称，不支持匹配模式和通配符。大小写不敏感。</li>
<li><code>folderNamesExpanded</code>展开的特殊名称文件夹图标。</li>
<li><code>rootFolder</code> 收起的工作区根文件夹图标，如果<code>rootFolderExpanded</code>没有设置，那么展开的工作区根文件夹也会使用这个图标。如果不设置，则会使用<code>folder</code>定义的文件夹图标。</li>
<li><code>rootFolderExpanded</code> 展开的工作区根文件夹图标。如果没有设置，则会使用<code>rootFolder</code>定义的文件夹图标。</li>
<li><code>languageIds</code>语言类型图标。这个键将匹配在*语言配置点（contribution point）*配置的<a href="extension-guides//references/contribution-points#contributeslanguages">语言id</a>。注意语言配置的'第一行'是不考虑在内的。</li>
<li><code>fileExtensions</code>文件插件图标。根据文件插件的名称匹配。插件名称是文件名点号后面（不包含点号）。拥有多重点号的文件名称，如<code>lib.d.ts</code>会匹配多个模式——<code>d.ts</code>和<code>ts</code>。大小写敏感。</li>
<li><code>fileNames</code>文件图标。这个键需要文件的全称进行匹配，不支持包含路径的名称，不支持模式和通配符。大小写敏感。<code>fileNames</code>是最高优先匹配。</li>
</ul>
<p>匹配优先级：<code>fileNames</code> &gt; <code>fileExtensions</code> &gt; <code>languageIds</code></p>
<p><code>light</code>和<code>highContrast</code>部分的属性表和上面相同，只是会在对应的主题下覆盖原有图标配置。</p>
<h3 id="字体定义"><a class="header" href="#字体定义">字体定义</a></h3>
<p>在'font'部分添加任意你喜欢的字形和字体。定义好之后，你就可以在图标定义中使用它们了。如果没有指定字体id，那么默认使用第一个定义的字体。</p>
<p>将字体文件移动到你的插件中，设置好对应的路径。推荐使用<a href="https://developer.mozilla.org/zh-CN/docs/WOFF">WOFF</a>字体。</p>
<ul>
<li>设置格式为'woff'</li>
<li>字重键值的定义参考<a href="https://developer.mozilla.org/docs/Web/CSS/font-weight#Values">这里</a></li>
<li>样式键值对的定义参考在<a href="https://developer.mozilla.org/docs/Web/CSS/@font-face/font-style#Values">这里</a></li>
<li>使用图标引用该字体时的字号。因此字体字号总是以百分比表示。</li>
</ul>
<pre><code class="language-json">&quot;fonts&quot;: [
    {
        &quot;id&quot;: &quot;turtles-font&quot;,
        &quot;src&quot;: [
            {
                &quot;path&quot;: &quot;./turtles.woff&quot;,
                &quot;format&quot;: &quot;woff&quot;
            }
        ],
        &quot;weight&quot;: &quot;normal&quot;,
        &quot;style&quot;: &quot;normal&quot;,
        &quot;size&quot;: &quot;150%&quot;
    }
],
&quot;iconDefinitions&quot;: {
    &quot;_file&quot;: {
        &quot;fontCharacter&quot;: &quot;\\E002&quot;,
        &quot;fontColor&quot;: &quot;#5f8b3b&quot;,
        &quot;fontId&quot;: &quot;turtles-font&quot;
    }
}
</code></pre>
<h3 id="图标主题中的文件夹图标"><a class="header" href="#图标主题中的文件夹图标">图标主题中的文件夹图标</a></h3>
<p>文件图标主题会告诉文件浏览器不要显示默认文件夹图标（倒三角或者横杠），这个模式可在配置中加入<code>&quot;hidesExplorerArrows&quot;:true</code>覆盖默认VS Code的设置。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="产品图标主题预览"><a class="header" href="#产品图标主题预览">产品图标主题（预览）</a></h1>
<p>VS Code 包含了大量内置图标，他们可以用在视图、编辑器、悬浮栏、状态栏，甚至插件中。文末的示例中演示了在过滤器按钮、视图按钮、状态栏、断点、树视图折叠按钮、编辑器中使用图标。</p>
<p>产品图标主题让插件可以自定义 VS Code 的整体外观。但是 <em>产品主题图标</em> 不包含文件图标（会被文件图标主题覆盖）和插件配置的图标。</p>
<p>VS Code 要求图标一定是图标字体定义的字形，用于限制（当前）产品图标统一为一种颜色。图标的颜色可以在使用时，可被当前激活的主题色所修改。</p>
<p>!&gt; 注意：产品图标主题仍在预览阶段，其配置格式还会有所修改。在正式发布之前，如果插件需要定义产品图标主题，需要打开<code>enableProposedApi</code>设置。你需要注意开发中的插件只能在 <a href="https://code.visualstudio.com/insiders/">Insider release</a> 版本中运行。同时，你无法将这类插件发布到市场上。</p>
<h2 id="添加一个新的产品图标主题"><a class="header" href="#添加一个新的产品图标主题">添加一个新的产品图标主题</a></h2>
<p>在 <code>package.json</code> 中的 <code>productIconTheme</code> 配置产品图标主题</p>
<pre><code class="language-json">{
  &quot;contributes&quot;: {
    &quot;productIconTheme&quot;: [
      {
        &quot;id&quot;: &quot;aliensAreBack&quot;,
        &quot;label&quot;: &quot;Aliens Are Back&quot;,
        &quot;path&quot;: &quot;./producticons/aliens-product-icon-theme.json&quot;
      }
    ]
  }
}
</code></pre>
<p>其中 <code>id</code> 是这个产品图标主题的唯一标识。它会显示在设置中，所以你定义 <code>id</code> 时注意要有唯一性和可读性。
<code>label</code> 则会展示在产品图标主题选择下拉框中。<code>path</code> 则指向了插件定义图标系列的地方。如果你的文件名遵循 <code>*product-icon-theme.json</code> 的格式，那么你在编辑图标主题文件时，你就会获得代码补全和悬浮提示。</p>
<p>当你完成图标主题之后，你还得在<code>package.json</code>中加上下面的配置</p>
<pre><code class="language-json">&quot;enableProposedApi&quot;: true
</code></pre>
<h2 id="产品图标定义文件"><a class="header" href="#产品图标定义文件">产品图标定义文件</a></h2>
<p>产品图标定义文件由一个或多个图标字体组成的图标定义集合的 JSON 文件。</p>
<h3 id="字体定义-1"><a class="header" href="#字体定义-1">字体定义</a></h3>
<p><code>font</code>部分可以声明一个以上的字形字体。
这些字体稍后会在图标定义文件中可以引用。如果图标定义不指定字体 ID，那么默认会使用第一个声明的字体。</p>
<p>将字体文件复制到你的插件里，然后设置好相应的路径。</p>
<p>我们建议你使用 <a href="https://developer.mozilla.org/docs/Web/Guide/WOFF">WOFF</a> 字体</p>
<ul>
<li>设置字体格式为'woff'</li>
<li>weight 属性值定义<a href="https://developer.mozilla.org/docs/Web/CSS/font-weight#Values">在这</a></li>
<li>style 属性值定义<a href="https://developer.mozilla.org/docs/Web/CSS/@font-face/font-style#Values">在这</a></li>
</ul>
<pre><code class="language-json">{
  &quot;fonts&quot;: [
    {
      &quot;id&quot;: &quot;alien-font&quot;,
      &quot;src&quot;: [
        {
          &quot;path&quot;: &quot;./alien.woff&quot;,
          &quot;format&quot;: &quot;woff&quot;
        }
      ],
      &quot;weight&quot;: &quot;normal&quot;,
      &quot;style&quot;: &quot;normal&quot;
    }
  ]
}
</code></pre>
<h3 id="图标定义-1"><a class="header" href="#图标定义-1">图标定义</a></h3>
<p>VS Code 维护了一个被视图引用的图标ID列表，产品图标的 <code>iconDefinitions</code> 可以将新的图标设置到这些 ID 上。</p>
<p>每个定义都要使用 <code>fontId</code> 引用定义在 <code>fonts</code> 部分的字体，如果遗漏了 <code>fontId</code>，则会取字体定义中的首个字体。</p>
<pre><code class="language-json">{
  &quot;iconDefinitions&quot;: {
    &quot;dialog-close&quot;: {
      &quot;fontCharacter&quot;: &quot;\\43&quot;,
      &quot;fontId&quot;: &quot;alien-font&quot;
    }
  }
}
</code></pre>
<p>所有图标的 ID 可以在 <a href="https://code.visualstudio.com/api/references/icons-in-labels#icon-listing">图标参考</a> 中查看</p>
<h2 id="开发和测试"><a class="header" href="#开发和测试">开发和测试</a></h2>
<p>VS Code 为 <code>package.json</code> 内置了多种编辑特性。想在产品图标主题文件中启动这个功能，你的主题文件需要以 <code>product-icon-theme.json</code> 结尾。然后你就获得了所有属性的代码补全、悬浮提示和校验。</p>
<p>现在试一下产品图标主题，在 VS Code 中打开你的产品图标主题插件目录，然后按下<code>F5</code>，接着 VS Code 会启动插件开发主机并运行你的插件。这个窗口启用了你的插件，并且自动使用了第一个产品图标主题。</p>
<p>并且 VS Code 会监测主题文件的变动，任何图标的更新都会自动应用到 VS Code 界面上。只要你修改了产品图标定义文件，你就可以在界面上看到实时变化。</p>
<p>使用<strong>Preferences: Product Icon Theme</strong>切换产品图标主题。</p>
<p>想要知道 VS Code UI的某个图标到底用的是什么，打开<strong>Help &gt; Toggle Developer Tools</strong>然后：</p>
<ul>
<li>点击开发者工具左上角的检查工具</li>
<li>将鼠标移动到你想要检查的图标上</li>
<li>如果图标的类名是<code>codicon.codicon-remote</code>，那么这个图标的 ID 就是<code>remote</code></li>
</ul>
<p><img src="https://code.visualstudio.com/assets/api/extension-guides/product-icon-theme/dev-tool-select-tool.png" alt="dev-tool-select-tool" /></p>
<h2 id="示例"><a class="header" href="#示例">示例</a></h2>
<p><a href="https://github.com/microsoft/vscode-extension-samples/tree/master/product-icon-theme-sample">产品颜色主题示例</a> 可以供你体验和使用。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="树视图-1"><a class="header" href="#树视图-1">树视图</a></h1>
<p>本节将教你如何为VS Code添加<em>视图容器</em>和<em>树视图</em>的插件，示例插件的源代码请查看<a href="https://github.com/Microsoft/vscode-extension-samples/tree/master/tree-view-sample">https://github.com/Microsoft/vscode-extension-samples/tree/master/tree-view-sample</a>。</p>
<h2 id="视图容器-1"><a class="header" href="#视图容器-1">视图容器</a></h2>
<hr />
<p><em>视图容器</em>包含了一列<em>视图(views)</em>，这些<em>视图</em>又包含在内置的<em>视图容器</em>中。</p>
<p><img src="https://media.githubusercontent.com/media/Microsoft/vscode-docs/master/api/extension-guides/images/tree-view/view-container.png" alt="view-container" /></p>
<p>要想配置一个视图容器，你首先得注册<code>package.json</code>中的<a href="extension-guides//references/contribution-points#contributesviewscontainers"><code>contributes.viewsContainers</code></a>。你还必须配置以下字段：</p>
<ul>
<li><code>id</code>: 新视图容器的名称</li>
<li><code>title</code>: 展示给用户的视图容器名称，它会显示在视图容器上方</li>
<li><code>icon</code>: 在活动栏中展示的图标</li>
</ul>
<pre><code class="language-json">&quot;contributes&quot;: {
  &quot;viewsContainers&quot;: {
    &quot;activitybar&quot;: [
      {
        &quot;id&quot;: &quot;package-explorer&quot;,
        &quot;title&quot;: &quot;Package Explorer&quot;,
        &quot;icon&quot;: &quot;media/dep.svg&quot;
      }
    ]
  }
}
</code></pre>
<h2 id="树视图-2"><a class="header" href="#树视图-2">树视图</a></h2>
<hr />
<p><em>视图</em>是显示在视图容器中的UI片段。使用<a href="extension-guides//references/contribution-points#contributesviews"><code>contributes.views</code></a>进行配置，你就可以将新的<em>视图</em>添加到内置或者你配置好的视图容器中了。</p>
<p><img src="https://media.githubusercontent.com/media/Microsoft/vscode-docs/master/api/extension-guides/images/tree-view/view.png" alt="view" /></p>
<p>要想配置一个<em>视图</em>，你首先得注册<code>package.json</code>中的<a href="extension-guides//references/vscode-api"><code>contributes.views</code></a>。你必须给<em>视图</em>配置一个ID外加一个名称，你还可以配置<em>视图</em>出现的位置：</p>
<ul>
<li><code>explorer</code>: 显示在资源管理器侧边栏</li>
<li><code>debug</code>: 显示在调试侧边栏</li>
<li><code>scm</code>: 显示在源代码侧边栏</li>
<li><code>test</code>: 测试侧边栏中的资源管理器视图</li>
<li>显示在你定义好的<em>视图容器</em>中</li>
</ul>
<pre><code class="language-json">&quot;contributes&quot;: {
  &quot;views&quot;: {
    &quot;package-explorer&quot;: [
      {
        &quot;id&quot;: &quot;nodeDependencies&quot;,
        &quot;name&quot;: &quot;Node Dependencies&quot;,
        &quot;when&quot;: &quot;explorer&quot;
      }
    ]
  }
}
</code></pre>
<p>当用户打开了对应的视图，VS Code会触发<a href="extension-guides//references/activation-events?id=onview"><code>onView:${viewId}</code></a>事件(如上面例子中，这个事件写为<code>onView:nodeDependencies</code>)。你也可以通过配置<code>when</code>字段控制视图的展示。</p>
<h2 id="视图的操作"><a class="header" href="#视图的操作">视图的操作</a></h2>
<hr />
<p>你可以配置<em>视图</em>下述位置的操作：</p>
<ul>
<li><code>view/title</code>: <em>视图</em>标题位置显示的操作。这里可以配置主要的操作，使用<code>&quot;group&quot;: &quot;navigation&quot;</code>进行配置，剩余的二级操作则出现在<code>...</code>菜单中。</li>
<li><code>view/item/context</code>: 每个<em>视图项</em>的操作。这里可以配置主要的操作，使用<code>&quot;group&quot;: &quot;inline&quot;</code>，剩余的二级操作则出现在<code>...</code>菜单中。</li>
</ul>
<p>使用<code>when</code>属性控制这些操作的展示。</p>
<p><img src="https://media.githubusercontent.com/media/Microsoft/vscode-docs/master/api/extension-guides/images/tree-view/view-actions.png" alt="view-actions" /></p>
<p>例如：</p>
<pre><code class="language-json">&quot;contributes&quot;: {
  &quot;commands&quot;: [
    {
      &quot;command&quot;: &quot;nodeDependencies.refreshEntry&quot;,
      &quot;title&quot;: &quot;Refresh&quot;,
      &quot;icon&quot;: {
        &quot;light&quot;: &quot;resources/light/refresh.svg&quot;,
        &quot;dark&quot;: &quot;resources/dark/refresh.svg&quot;
      }
    },
    {
      &quot;command&quot;: &quot;nodeDependencies.addEntry&quot;,
      &quot;title&quot;: &quot;Add&quot;
    },
    {
      &quot;command&quot;: &quot;nodeDependencies.editEntry&quot;,
      &quot;title&quot;: &quot;Edit&quot;,
      &quot;icon&quot;: {
        &quot;light&quot;: &quot;resources/light/edit.svg&quot;,
        &quot;dark&quot;: &quot;resources/dark/edit.svg&quot;
      }
    },
    {
      &quot;command&quot;: &quot;nodeDependencies.deleteEntry&quot;,
      &quot;title&quot;: &quot;Delete&quot;
    }
  ],
  &quot;menus&quot;: {
    &quot;view/title&quot;: [
      {
        &quot;command&quot;: &quot;nodeDependencies.refreshEntry&quot;,
        &quot;when&quot;: &quot;view == nodeDependencies&quot;,
        &quot;group&quot;: &quot;navigation&quot;
      },
      {
        &quot;command&quot;: &quot;nodeDependencies.addEntry&quot;,
        &quot;when&quot;: &quot;view == nodeDependencies&quot;
      }
    ],
    &quot;view/item/context&quot;: [
      {
        &quot;command&quot;: &quot;nodeDependencies.editEntry&quot;,
        &quot;when&quot;: &quot;view == nodeDependencies &amp;&amp; viewItem == dependency&quot;,
        &quot;group&quot;: &quot;inline&quot;
      },
      {
        &quot;command&quot;: &quot;nodeDependencies.deleteEntry&quot;,
        &quot;when&quot;: &quot;view == nodeDependencies &amp;&amp; viewItem == dependency&quot;
      }
    ]
  }
}
</code></pre>
<p>!&gt; <strong>注意</strong>：如果你需要针对特定的条目显示特殊的操作，定义树视图项的<code>TreeItem.contextValue</code>，并且在<code>when</code>中使用表达式，视图项的值储存在表达式的<code>viewItem</code>中。</p>
<p>如：</p>
<pre><code class="language-json">&quot;contributes&quot;: {
  &quot;menus&quot;: {
    &quot;view/item/context&quot;: [
      {
        &quot;command&quot;: &quot;nodeDependencies.deleteEntry&quot;,
        &quot;when&quot;: &quot;view == nodeDependencies &amp;&amp; viewItem == dependency&quot;
      }
    ]
  }
}
</code></pre>
<h2 id="为树视图提供数据"><a class="header" href="#为树视图提供数据">为树视图提供数据</a></h2>
<hr />
<p>插件创作者需要注册<a href="https://code.visualstudio.com/api/references/vscode-api#TreeDataProvider"><code>TreeDataProvider</code></a>，以便动态生成<em>视图</em>中的数据。</p>
<pre><code class="language-typescript">vscode.window.registerTreeDataProvider('nodeDependencies', new DepNodeProvider());
</code></pre>
<p>更多实现请参考<a href="https://github.com/Microsoft/vscode-extension-samples/tree/master/tree-view-sample/src/nodeDependencies.ts">nodeDependencies.ts</a></p>
<h2 id="动态创建树视图"><a class="header" href="#动态创建树视图">动态创建树视图</a></h2>
<hr />
<p>如果你想在<em>视图</em>中通过编程手段创建一些操作，你就不能再注册<code>window.registerTreeDataProvider</code>了，而是<code>window.createTreeView</code>，这样一来你就有权限提供你喜欢的视图操作了：</p>
<pre><code class="language-typescript">vscode.window.createTreeView('ftpExplorer', {
  treeDataProvider: new FtpTreeDataProvider()
});
</code></pre>
<p>更多实现请参考<a href="https://github.com/Microsoft/vscode-extension-samples/tree/master/tree-view-sample/src/ftpExplorer.ts">ftpExplorer.ts</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="webview-api"><a class="header" href="#webview-api">Webview API</a></h1>
<p>webview API为开发者提供了完全自定义视图的能力，例如内置的Markdown插件使用了webview渲染Markdown预览文件。Webview也能用于构建比VS Code原生API支持构建的更加复杂的用户交互界面。</p>
<p>可以把webview看成是VS Code中的<code>iframe</code>，它可以渲染几乎全部的HTML内容，它通过消息机制和插件通信。这样的自由度令我们的webview非常强劲并将插件的潜力提升到了新的高度。</p>
<h2 id="相关链接"><a class="header" href="#相关链接">相关链接</a></h2>
<hr />
<ul>
<li><a href="https://github.com/Microsoft/vscode-extension-samples/blob/master/webview-sample/README.md">Webview 示例</a></li>
</ul>
<h3 id="使用的vs-code-api"><a class="header" href="#使用的vs-code-api">使用的VS Code API</a></h3>
<ul>
<li><a href="https://code.visualstudio.com/api/references/vscode-api#window.createWebviewPanel">window.createWebviewPanel</a></li>
<li><a href="https://code.visualstudio.com/api/references/vscode-api#window.registerWebviewPanelSerializer">window.registerWebviewPanelSerializer</a></li>
</ul>
<h2 id="我应该用webview吗"><a class="header" href="#我应该用webview吗">我应该用webview吗？</a></h2>
<hr />
<p>webview虽然很赞，但是我们应该节制地使用这个功能——比如当VS Code原生API不够用时。Webview重度依赖资源，所以它脱离插件的进程而单独运行在其他环境中。在VS Code中使用设计不良的webview会让用户抓狂。</p>
<p>在使用webview之前，请作以下考虑：</p>
<ul>
<li>这个功能真的需要VS Code来提供吗？分离成一个应用或者网站会不会更好？</li>
<li>webview是实现这个特性的最后方案吗？VS Code原生API是否能达到同样的目的呢？</li>
<li>你的webview所牺牲的高资源占用是否能换得同样的用户价值？</li>
</ul>
<p>请记住：不要因为能使用webview而滥用webview。相反，如果你有充足的理由和自信，那么本篇教程对你来说会非常有用，现在就让我们开始吧。</p>
<h2 id="webviews-api-基础"><a class="header" href="#webviews-api-基础">Webviews API 基础</a></h2>
<hr />
<p>为了解释webviewAPI，我们先构建一个简单的<strong>Cat Coding</strong>插件。这个插件会用一个webview显示猫写代码的gif。随着我们不断了解API，我们会不断地给插件添加功能，包括我们的猫写了多少行代码的计数跟踪器，如果猫猫写出了bug还会有一个提示弹出框。</p>
<p>这是<strong>Cat Coding</strong>插件的第一版<code>package.json</code>，你可以在<a href="https://github.com/Microsoft/vscode-extension-samples/blob/master/webview-sample/README.md">这里</a>找到完整的代码。我们的第一版插件<a href="extension-guides//extensibility-reference/contribution-points#contributescommands">提供了一个命令</a>，叫做<code>catCoding.start</code>。当用户从<strong>命令面板</strong>调用<em>Cat Coding: Start new cat coding session</em>，或者一个创建好的<em>键绑定</em>命令，我们的猫猫会出现在webview窗口内。</p>
<pre><code class="language-json">{
  &quot;name&quot;: &quot;cat-coding&quot;,
  &quot;description&quot;: &quot;Cat Coding&quot;,
  &quot;version&quot;: &quot;0.0.1&quot;,
  &quot;publisher&quot;: &quot;bierner&quot;,
  &quot;engines&quot;: {
    &quot;vscode&quot;: &quot;^1.23.0&quot;
  },
  &quot;activationEvents&quot;: [&quot;onCommand:catCoding.start&quot;],
  &quot;main&quot;: &quot;./out/src/extension&quot;,
  &quot;contributes&quot;: {
    &quot;commands&quot;: [
      {
        &quot;command&quot;: &quot;catCoding.start&quot;,
        &quot;title&quot;: &quot;Start new cat coding session&quot;,
        &quot;category&quot;: &quot;Cat Coding&quot;
      }
    ]
  },
  &quot;scripts&quot;: {
    &quot;vscode:prepublish&quot;: &quot;tsc -p ./&quot;,
    &quot;compile&quot;: &quot;tsc -watch -p ./&quot;,
    &quot;postinstall&quot;: &quot;node ./node_modules/vscode/bin/install&quot;
  },
  &quot;dependencies&quot;: {
    &quot;vscode&quot;: &quot;*&quot;
  },
  &quot;devDependencies&quot;: {
    &quot;@types/node&quot;: &quot;^9.4.6&quot;,
    &quot;typescript&quot;: &quot;^2.8.3&quot;
  }
}
</code></pre>
<p>现在让我们实现<code>catCoding.start</code>命令，在我们的主文件中，像下面这样注册一个基础的webview：</p>
<pre><code class="language-typescript">import * as vscode from 'vscode';

export function activate(context: vscode.ExtensionContext) {
  context.subscriptions.push(
    vscode.commands.registerCommand('catCoding.start', () =&gt; {
      // 创建并显示新的webview
      const panel = vscode.window.createWebviewPanel(
        'catCoding', // 只供内部使用，这个webview的标识
        'Cat Coding', // 给用户显示的面板标题
        vscode.ViewColumn.One, // 给新的webview面板一个编辑器视图
        {} // Webview选项。我们稍后会用上
      );
    })
  );
}
</code></pre>
<p><code>vscode.window.createWebviewPanel</code>函数创建并在编辑区展示了一个webview，下图显示了如果你试着运行<code>catCoding.start</code>命令会显示的东西：</p>
<p><img src="https://media.githubusercontent.com/media/Microsoft/vscode-docs/master/api/extension-guides/images/webview/basics-no_content.png" alt="一个空的webview" /></p>
<p>我们的命令以正确的标题打开了一个新的webview面板，但是没有任何内容！要想把我们的猫加到这个面板里面，我们需要<code>webview.html</code>设置HTML内容。</p>
<pre><code class="language-typescript">import * as vscode from 'vscode';

export function activate(context: vscode.ExtensionContext) {
  context.subscriptions.push(
    vscode.commands.registerCommand('catCoding.start', () =&gt; {
      // 创建和显示webview
      const panel = vscode.window.createWebviewPanel(
        'catCoding',
        'Cat Coding',
        vscode.ViewColumn.One,
        {}
      );

      // 设置HTML内容
      panel.webview.html = getWebviewContent();
    })
  );
}

function getWebviewContent() {
  return
    `
        &lt;!DOCTYPE html&gt;
        &lt;html lang=&quot;en&quot;&gt;
        &lt;head&gt;
            &lt;meta charset=&quot;UTF-8&quot;&gt;
            &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
            &lt;title&gt;Cat Coding&lt;/title&gt;
        &lt;/head&gt;
        &lt;body&gt;
            &lt;img src=&quot;https://media.giphy.com/media/JIX9t2j0ZTN9S/giphy.gif&quot; width=&quot;300&quot; /&gt;
        &lt;/body&gt;
        &lt;/html&gt;
    `;
}
</code></pre>
<p>如果你再次运行命令，应该能看到下图：</p>
<p><img src="https://media.githubusercontent.com/media/Microsoft/vscode-docs/master/api/extension-guides/images/webview/basics-html.png" alt="含有html内容的webview" /></p>
<p>大功告成！</p>
<p><code>webview.html</code>应该是一个完整的HTML文档。使用HTML片段或者格式错乱的HTML会造成异常。</p>
<h3 id="更新webview内容"><a class="header" href="#更新webview内容">更新webview内容</a></h3>
<p><code>webview.html</code>也能在webview创建后更新内容，让我们用猫猫轮播图使<strong>Cat Coding</strong>具有动态性：</p>
<pre><code class="language-typescript">import * as vscode from 'vscode';

const cats = {
  'Coding Cat': 'https://media.giphy.com/media/JIX9t2j0ZTN9S/giphy.gif',
  'Compiling Cat': 'https://media.giphy.com/media/mlvseq9yvZhba/giphy.gif'
};

export function activate(context: vscode.ExtensionContext) {
  context.subscriptions.push(
    vscode.commands.registerCommand('catCoding.start', () =&gt; {
      const panel = vscode.window.createWebviewPanel(
        'catCoding',
        'Cat Coding',
        vscode.ViewColumn.One,
        {}
      );

      let iteration = 0;
      const updateWebview = () =&gt; {
        const cat = iteration++ % 2 ? 'Compiling Cat' : 'Coding Cat';
        panel.title = cat;
        panel.webview.html = getWebviewContent(cat);
      };

      // 设置初始化内容
      updateWebview();

      // 每秒更新内容
      setInterval(updateWebview, 1000);
    })
  );
}

function getWebviewContent(cat: keyof typeof cats) {
  return
    `
        &lt;!DOCTYPE html&gt;
        &lt;html lang=&quot;en&quot;&gt;
        &lt;head&gt;
            &lt;meta charset=&quot;UTF-8&quot;&gt;
            &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
            &lt;title&gt;Cat Coding&lt;/title&gt;
        &lt;/head&gt;
        &lt;body&gt;
            &lt;img src=&quot;${cats[cat]}&quot; width=&quot;300&quot; /&gt;
        &lt;/body&gt;
        &lt;/html&gt;
    `;
}
</code></pre>
<p><img src="https://media.githubusercontent.com/media/Microsoft/vscode-docs/master/api/extension-guides/images/webview/basics-update.gif" alt="更新webview内容" /></p>
<p>因为<code>webview.html</code>方法替换了整个webview内容，页面看起来像重新加载了一个iframe。记住：如果你在webview中使用了脚本，那就意味着<code>webview.html</code>的重置会使脚本状态重置。</p>
<p>上述示例也使用了<code>webview.title</code>改变编辑器中的展示的文件名称，设置标题不会使webview重载。</p>
<h3 id="生命周期"><a class="header" href="#生命周期">生命周期</a></h3>
<p>webview从属于创建他们的插件，插件必须保持住从webview返回的<code>createWebviewPanel</code>。如果你的插件失去了这个关联，它就不能再访问webview了，不过即使这样，webview还会继续展示在VS Code中。</p>
<p>因为webview是一个文本编辑器视图，所以用户可以随时关闭webview。当用户关闭了webview面板后，webview就被销毁了。在我们的例子中，销毁webview时抛出了一个异常，说明我们上面的示例中使用的<code>seInterval</code>实际上产生了非常严重的Bug：如果用户关闭了面板，<code>setInterval</code>会继续触发，而且还会尝试更新<code>panel.webview.html</code>，这当然会抛出异常。喵星人可不喜欢异常，我们现在就来解决这个问题吧。</p>
<p><code>onDidDispose</code>事件在webview被销毁时触发，我们在这个事件结束之后更新并释放webview资源。</p>
<pre><code class="language-typescript">import * as vscode from 'vscode';

const cats = {
  'Coding Cat': 'https://media.giphy.com/media/JIX9t2j0ZTN9S/giphy.gif',
  'Compiling Cat': 'https://media.giphy.com/media/mlvseq9yvZhba/giphy.gif'
};

export function activate(context: vscode.ExtensionContext) {
  context.subscriptions.push(
    vscode.commands.registerCommand('catCoding.start', () =&gt; {
      const panel = vscode.window.createWebviewPanel(
        'catCoding',
        'Cat Coding',
        vscode.ViewColumn.One,
        {}
      );

      let iteration = 0;
      const updateWebview = () =&gt; {
        const cat = iteration++ % 2 ? 'Compiling Cat' : 'Coding Cat';
        panel.title = cat;
        panel.webview.html = getWebviewContent(cat);
      };

      updateWebview();
      const interval = setInterval(updateWebview, 1000);

      panel.onDidDispose(
        () =&gt; {
          // 当面板关闭时，取消webview内容之后的更新
          clearInterval(interval);
        },
        null,
        context.subscriptions
      );
    })
  );
}
</code></pre>
<p>插件也可以通过编程方式关闭webview视图——调用它们的<code>dispose()</code>方法。我们假设，现在限制我们的猫猫每天工作5秒钟：</p>
<pre><code class="language-typescript">export function activate(context: vscode.ExtensionContext) {
  context.subscriptions.push(
    vscode.commands.registerCommand('catCoding.start', () =&gt; {
      const panel = vscode.window.createWebviewPanel(
        'catCoding',
        'Cat Coding',
        vscode.ViewColumn.One,
        {}
      );

      panel.webview.html = getWebviewContent(cats['Coding Cat']);

      // 5秒后，程序性地关闭webview面板
      const timeout = setTimeout(() =&gt; panel.dispose(), 5000);

      panel.onDidDispose(
        () =&gt; {
          // 在第五秒结束之前处理用户手动的关闭动作
          clearTimeout(timeout);
        },
        null,
        context.subscriptions
      );
    })
  );
}
</code></pre>
<h3 id="移动和可见性"><a class="header" href="#移动和可见性">移动和可见性</a></h3>
<p>当webview面板被移动到了非激活标签上，它就隐藏起来了。但这时并不是销毁，当重新激活标签后，VS Code会从<code>webview.html</code>自动恢复webview的内容。</p>
<p><img src="https://media.githubusercontent.com/media/Microsoft/vscode-docs/master/api/extension-guides/images/webview/basics-restore.gif" alt="webview自动恢复内容" /></p>
<p><code>.visible</code>属性告诉你当前webview面板是否是可见的。</p>
<p>插件也可以通过调用<code>reveal()</code>方法，程序性地将webview面板激活。这个方法可以接受一个用于放置面板的目标视图布局。一个面板一次只能显示在一个编辑布局中。调用<code>reveal()</code>或者拖动webview面板到新的编辑布局中去。</p>
<p><img src="https://media.githubusercontent.com/media/Microsoft/vscode-docs/master/api/extension-guides/images/webview/basics-drag.gif" alt="在标签页中移动webview视图" /></p>
<p>现在更新我们的插件，一次只允许存在一个webview视图。如果面板处于非激活状态，那<code>catCoding.start</code>命令就把这个面板激活。</p>
<pre><code class="language-typescript">export function activate(context: vscode.ExtensionContext) {
  // 追踪当前webview面板
  let currentPanel: vscode.WebviewPanel | undefined = undefined;

  context.subscriptions.push(
    vscode.commands.registerCommand('catCoding.start', () =&gt; {
      const columnToShowIn = vscode.window.activeTextEditor
        ? vscode.window.activeTextEditor.viewColumn
        : undefined;

      if (currentPanel) {
        // 如果我们已经有了一个面板，那就把它显示到目标列布局中
        currentPanel.reveal(columnToShowIn);
      } else {
        // 不然，创建一个新面板
        currentPanel = vscode.window.createWebviewPanel(
          'catCoding',
          'Cat Coding',
          columnToShowIn,
          {}
        );
        currentPanel.webview.html = getWebviewContent(cats['Coding Cat']);

        // 当前面板被关闭后重置
        currentPanel.onDidDispose(
          () =&gt; {
            currentPanel = undefined;
          },
          null,
          context.subscriptions
        );
      }
    })
  );
}
</code></pre>
<p>下面是一个新插件的行为：</p>
<p><img src="https://media.githubusercontent.com/media/Microsoft/vscode-docs/master/api/extension-guides/images/webview/basics-single_panel.gif" alt="在单个面板中展示" /></p>
<p>不论何时，如果webview的可见性改变了，或者当webview移动到了新的视图布局中，就会触发<code>onDidChangeViewState</code>。我们的插件可以利用这个时间改变布局中的webview显示的猫：</p>
<pre><code class="language-typescript">const cats = {
  'Coding Cat': 'https://media.giphy.com/media/JIX9t2j0ZTN9S/giphy.gif',
  'Compiling Cat': 'https://media.giphy.com/media/mlvseq9yvZhba/giphy.gif',
  'Testing Cat': 'https://media.giphy.com/media/3oriO0OEd9QIDdllqo/giphy.gif'
};

export function activate(context: vscode.ExtensionContext) {
  context.subscriptions.push(
    vscode.commands.registerCommand('catCoding.start', () =&gt; {
      const panel = vscode.window.createWebviewPanel(
        'catCoding',
        'Cat Coding',
        vscode.ViewColumn.One,
        {}
      );
      panel.webview.html = getWebviewContent(cats['Coding Cat']);

      // 根据视图状态变动更新内容
      panel.onDidChangeViewState(
        e =&gt; {
          const panel = e.webviewPanel;
          switch (panel.viewColumn) {
            case vscode.ViewColumn.One:
              updateWebviewForCat(panel, 'Coding Cat');
              return;

            case vscode.ViewColumn.Two:
              updateWebviewForCat(panel, 'Compiling Cat');
              return;

            case vscode.ViewColumn.Three:
              updateWebviewForCat(panel, 'Testing Cat');
              return;
          }
        },
        null,
        context.subscriptions
      );
    })
  );
}

function updateWebviewForCat(panel: vscode.WebviewPanel, catName: keyof typeof cats) {
  panel.title = catName;
  panel.webview.html = getWebviewContent(cats[catName]);
}
</code></pre>
<p><img src="https://media.githubusercontent.com/media/Microsoft/vscode-docs/master/api/extension-guides/images/webview/basics-ondidchangeviewstate.gif" alt="响应onDidChangeViewState事件" /></p>
<h3 id="检查和调试webviews"><a class="header" href="#检查和调试webviews">检查和调试webviews</a></h3>
<p>在命令面板中输入<strong>Developer: Toggle Developer Tools</strong>能帮助你调试webview。运行命令之后会为当前可见的webview加载一个devtool：</p>
<p><img src="https://media.githubusercontent.com/media/Microsoft/vscode-docs/master/api/extension-guides/images/webview/basics-developer_tools.png" alt="Webview开发者工具" /></p>
<p>webview的内容是在webview文档中的一个iframe中的，用开发者工具检查和修改webview的DOM，在webview内调试脚本。</p>
<p>如果你用了webview开发者工具的console，确保你在Console面板左上角的下拉框里选中了当前<strong>激活窗体</strong>环境：</p>
<p><img src="https://media.githubusercontent.com/media/Microsoft/vscode-docs/master/api/extension-guides/images/webview/debug-active-frame.png" alt="选择激活窗体" /></p>
<p><strong>激活窗体</strong>环境是webview脚本执行的地方。</p>
<p>另外，<strong>Developer: Reload Webview</strong>命令会刷新所有已激活的webview。如果你需要重置一个webview的状态，这个命令会非常有用，或者你想要读取硬盘内容的webview更新一下，也可以使用这个方法。</p>
<h2 id="加载本地内容"><a class="header" href="#加载本地内容">加载本地内容</a></h2>
<hr />
<p>webview运行在独立的环境中，因此不能直接访问本地资源，这是出于安全性考虑的做法。这也意味着要想从你的插件中加载图片、样式等其他资源，或是从用户当前的工作区加载任何内容的话，你必须使用webview中的<code>vscode-resource:</code>协议。</p>
<p><code>vscode-resource:</code>协议就像<code>file:</code>协议一样，不过它只允许访问本地文件。和<code>file:</code>一样的是，<code>vscode-resource:</code>只能从绝对路径中加载资源。</p>
<p>想象一下，我们想要从本地把喵喵们的gif打包进来，而不是从Giphy（国外出名的gif收集站）里加载进来。要想做到这点，我们首先给本地文件新建一个URI，然后用<code>vscode-resource:</code>协议更新这些URI：</p>
<pre><code class="language-typescript">import * as vscode from 'vscode';
import * as path from 'path';

export function activate(context: vscode.ExtensionContext) {
  context.subscriptions.push(
    vscode.commands.registerCommand('catCoding.start', () =&gt; {
      const panel = vscode.window.createWebviewPanel(
        'catCoding',
        'Cat Coding',
        vscode.ViewColumn.One,
        {}
      );

      // 获取磁盘上的资源路径
      const onDiskPath = vscode.Uri.file(
        path.join(context.extensionPath, 'media', 'cat.gif')
      );

      // 获取在webview中使用的特殊URI
      const catGifSrc = onDiskPath.with({ scheme: 'vscode-resource' });

      panel.webview.html = getWebviewContent(catGifSrc);
    })
  );
}
</code></pre>
<p><code>catGifSrc</code>的值最后会像这样：</p>
<pre><code class="language-bash">vscode-resource:/Users/toonces/projects/vscode-cat-coding/media/cat.gif
</code></pre>
<p>默认情况下，<code>scode-resource:</code>只能访问下列地址的资源：</p>
<ul>
<li>你的插件安装的目录</li>
<li>用户当前激活的工作区</li>
</ul>
<p>你也可以用data URI将资源直接嵌套到webview中去。</p>
<h3 id="控制本地资源访问"><a class="header" href="#控制本地资源访问">控制本地资源访问</a></h3>
<p>使用<code>localResourceRoots</code>选项，webview可以控制<code>vscode-resource:</code>加载的的资源。
<code>localResourceRoots</code>定义了可能被加载的本地内容的根URI。</p>
<p>我们用<code>localResourceRoots</code>去约束<strong>Cat Coding</strong>webview只加载我们插件的<code>media</code>目录下的内容：</p>
<pre><code class="language-typescript">import * as vscode from 'vscode';
import * as path from 'path';

export function activate(context: vscode.ExtensionContext) {
  context.subscriptions.push(
    vscode.commands.registerCommand('catCoding.start', () =&gt; {
      const panel = vscode.window.createWebviewPanel(
        'catCoding',
        'Cat Coding',
        vscode.ViewColumn.One,
        {
          // 只允许webview加载我们插件的`media`目录下的资源
          localResourceRoots: [vscode.Uri.file(path.join(context.extensionPath, 'media'))]
        }
      );

      const onDiskPath = vscode.Uri.file(
        path.join(context.extensionPath, 'media', 'cat.gif')
      );
      const catGifSrc = onDiskPath.with({ scheme: 'vscode-resource' });

      panel.webview.html = getWebviewContent(catGifSrc);
    })
  );
}
</code></pre>
<p>为了禁止所有的本地资源，只要把<code>localResourceRoots</code>设为<code>[]</code>就好了。</p>
<p>通常来说，webview应该和加载本地资源一样严格，然而，<code>vscode-resource</code>和<code>localResourceRoots</code>并不保证百分百的安全性。请确保你的webview遵循<a href="extension-guides//extension-guides/webview#%E5%AE%89%E5%85%A8%E6%80%A7">安全性最佳实践</a>，强烈建议考虑添加一个<a href="extension-guides//extension-guides/webview#%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E7%AD%96%E7%95%A5">内容安全政策</a>以便约束之后加载的内容。</p>
<h3 id="给webview内容加上主题"><a class="header" href="#给webview内容加上主题">给webview内容加上主题</a></h3>
<p>webview可以基于当前的VS Code主题和CSS改变自身的样式。VS Code将主题分成3中类别，而且在<code>body</code>元素上加上了特殊类名以表明当前主题：</p>
<ul>
<li><code>vscode-light</code>——亮色主题</li>
<li><code>vscode-dark</code>——暗色主题</li>
<li><code>vscode-high-contrast</code>——高反差主题</li>
</ul>
<p>下列CSS改变了基于用户当前主题的webview字体颜色：</p>
<pre><code class="language-css">body.vscode-light {
  color: black;
}

body.vscode-dark {
  color: white;
}

body.vscode-high-contrast {
  color: red;
}
</code></pre>
<p>当开发一个webview应用的时候，请保证应用能在三种主题下都可以运作，务必在高反差模式下测试你的webview，以便有视觉障碍的用户也能正常使用。</p>
<p>webview可以通过<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Using_CSS_variables">CSS variables</a>访问VS Code主题，这些变量以<code>vscode</code>为前缀，并且用<code>-</code>替代了<code>.</code>，例如<code>editor.foreground</code>变成了<code>var(--vscode-editor-foreground)</code>：</p>
<pre><code class="language-css">code {
  color: var(--vscode-editor-foreground);
}
</code></pre>
<p>更多可用的主题变量，参阅<a href="extension-guides//references/theme-color">主题色彩</a>。</p>
<p>下面也定义了一些与字体有关的变量：</p>
<ul>
<li><code>-vscode-editor-font-family</code> - 编辑器的文字类型(设置中的<code>editor.fontFamily</code>配置项)</li>
<li><code>-vscode-editor-font-weight</code> - 编辑器的文字粗细(设置中的<code>editor.fontWeight</code>配置项)</li>
<li><code>-vscode-editor-font-size</code> - 编辑器文字大小(设置中的<code>editor.fontSize</code>配置项)</li>
</ul>
<h2 id="脚本和信息传递"><a class="header" href="#脚本和信息传递">脚本和信息传递</a></h2>
<hr />
<p>既然webview就像iframe一样，也就是说它们也可以运行脚本，webview中的Javascript默认是禁用的，不过我们能用<code>enableScripts: true</code>打开它。</p>
<p>让我们写一段脚本，追踪我们家喵星人写代码的行数。运行一个基础脚本非常的容易，但是注意这个示例只作演示用途，在实践中，你的webview应该遵循<a href="extension-guides/webview.html#%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E7%AD%96%E7%95%A5">内容安全政策</a>，禁止行内脚本。</p>
<pre><code class="language-typescript">import * as path from 'path';
import * as vscode from 'vscode';

export function activate(context: vscode.ExtensionContext) {
    context.subscriptions.push(vscode.commands.registerCommand('catCoding.start', () =&gt; {
        const panel = vscode.window.createWebviewPanel('catCoding', &quot;Cat Coding&quot;, vscode.ViewColumn.One, {
            // 在webview中启用脚本
            enableScripts: true
        });

        panel.webview.html = getWebviewContent();
    }));
}

function getWebviewContent() {
    return
        `
            &lt;!DOCTYPE html&gt;
            &lt;html lang=&quot;en&quot;&gt;
            &lt;head&gt;
                &lt;meta charset=&quot;UTF-8&quot;&gt;
                &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
                &lt;title&gt;Cat Coding&lt;/title&gt;
            &lt;/head&gt;
            &lt;body&gt;
                &lt;img src=&quot;https://media.giphy.com/media/JIX9t2j0ZTN9S/giphy.gif&quot; width=&quot;300&quot; /&gt;
                &lt;h1 id=&quot;lines-of-code-counter&quot;&gt;0&lt;/h1&gt;

                &lt;script&gt;
                    const counter = document.getElementById('lines-of-code-counter');

                    let count = 0;
                    setInterval(() =&gt; {
                        counter.textContent = count++;
                    }, 100);
                &lt;/script&gt;
            &lt;/body&gt;
            &lt;/html&gt;
        `;
}
</code></pre>
<p><img src="https://media.githubusercontent.com/media/Microsoft/vscode-docs/master/api/extension-guides/images/webview/scripts-basic.gif" alt="在webview中运行脚本" /></p>
<p>哇！真是位高产的喵主子!</p>
<p>!&gt; webveiw的脚本能做到任何普通网页脚本能做到的事情，但是webview运行在自己的上下文中，脚本不能访问VS Code API。</p>
<h3 id="将插件的信息传递到webview"><a class="header" href="#将插件的信息传递到webview">将插件的信息传递到webview</a></h3>
<p>插件可以用<code>webview.postMessage()</code>将数据发送到它的webview中。这个方法能发送任何序列化的JSON数据到webview中，在webview中则通过<code>message</code>事件接受信息。</p>
<p>我们现在就来看看这个实现，在Cat Coding中新增一个命令来表示我们家的喵在重构他的代码（所以会减少代码总行数）。新增<code>catCoding.doRefactor</code>命令，利用<code>postMessage</code>把指示发送到webview中，webview中的<code>window.addEventListener('message' event =&gt; { ... })</code>则会处理这些信息：</p>
<pre><code class="language-typescript">export function activate(context: vscode.ExtensionContext) {

    // 现在只有一只喵喵程序员了
    let currentPanel: vscode.WebviewPanel | undefined = undefined;

    context.subscriptions.push(vscode.commands.registerCommand('catCoding.start', () =&gt; {
        if (currentPanel) {
            currentPanel.reveal(vscode.ViewColumn.One);
        } else {
            currentPanel = vscode.window.createWebviewPanel('catCoding', &quot;Cat Coding&quot;, vscode.ViewColumn.One, {
                enableScripts: true
            });
            currentPanel.webview.html = getWebviewContent();
            currentPanel.onDidDispose(() =&gt; { currentPanel = undefined; }, undefined, context.subscriptions);
        }
    }));

    // 我们新的命令
    context.subscriptions.push(vscode.commands.registerCommand('catCoding.doRefactor', () =&gt; {
        if (!currentPanel) {
            return;
        }

        // 把信息发送到webview
        // 你可以发送任何序列化的JSON数据
        currentPanel.webview.postMessage({ command: 'refactor' });
    }));
}

function getWebviewContent() {
    return
        `
            &lt;!DOCTYPE html&gt;
            &lt;html lang=&quot;en&quot;&gt;
            &lt;head&gt;
                &lt;meta charset=&quot;UTF-8&quot;&gt;
                &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
                &lt;title&gt;Cat Coding&lt;/title&gt;
            &lt;/head&gt;
            &lt;body&gt;
                &lt;img src=&quot;https://media.giphy.com/media/JIX9t2j0ZTN9S/giphy.gif&quot; width=&quot;300&quot; /&gt;
                &lt;h1 id=&quot;lines-of-code-counter&quot;&gt;0&lt;/h1&gt;

                &lt;script&gt;
                    const counter = document.getElementById('lines-of-code-counter');

                    let count = 0;
                    setInterval(() =&gt; {
                        counter.textContent = count++;
                    }, 100);

                    // Handle the message inside the webview
                    window.addEventListener('message', event =&gt; {

                        const message = event.data; // The JSON data our extension sent

                        switch (message.command) {
                            case 'refactor':
                                count = Math.ceil(count * 0.5);
                                counter.textContent = count;
                                break;
                        }
                    });
                &lt;/script&gt;
            &lt;/body&gt;
            &lt;/html&gt;
        `;
</code></pre>
<p><img src="https://media.githubusercontent.com/media/Microsoft/vscode-docs/master/api/extension-guides/images/webview/scripts-extension_to_webview.gif" alt="向webview传递信息" /></p>
<h3 id="将webview的信息传递到插件中"><a class="header" href="#将webview的信息传递到插件中">将webview的信息传递到插件中</a></h3>
<p>webview也可以把信息传递回对应的插件中，用VS Code API 为webview提供的<code>postMessage</code>函数我们就可以完成这个目标。调用webview中的<code>acquireVsCodeApi</code>获取VS Code API对象。这个函数在一个会话中只能调用一次，你必须保持住这个方法返回的VS Code API实例，然后再转交到需要调用这个实例的地方。</p>
<p>现在我们在<strong>Cat Coding</strong>添加一个弹出bug的警示框：</p>
<pre><code class="language-typescript">export function activate(context: vscode.ExtensionContext) {
    context.subscriptions.push(vscode.commands.registerCommand('catCoding.start', () =&gt; {
        const panel = vscode.window.createWebviewPanel('catCoding', &quot;Cat Coding&quot;, vscode.ViewColumn.One, {
            enableScripts: true
        });

        panel.webview.html = getWebviewContent();

        // 处理webview中的信息
        panel.webview.onDidReceiveMessage(message =&gt; {
            switch (message.command) {
                case 'alert':
                    vscode.window.showErrorMessage(message.text);
                    return;
            }
        }, undefined, context.subscriptions);
    }));
}

function getWebviewContent() {
    return
        `
            &lt;!DOCTYPE html&gt;
            &lt;html lang=&quot;en&quot;&gt;
            &lt;head&gt;
                &lt;meta charset=&quot;UTF-8&quot;&gt;
                &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
                &lt;title&gt;Cat Coding&lt;/title&gt;
            &lt;/head&gt;
            &lt;body&gt;
                &lt;img src=&quot;https://media.giphy.com/media/JIX9t2j0ZTN9S/giphy.gif&quot; width=&quot;300&quot; /&gt;
                &lt;h1 id=&quot;lines-of-code-counter&quot;&gt;0&lt;/h1&gt;

                &lt;script&gt;
                    (function() {
                        const vscode = acquireVsCodeApi();
                        const counter = document.getElementById('lines-of-code-counter');

                        let count = 0;
                        setInterval(() =&gt; {
                            counter.textContent = count++;

                            // Alert the extension when our cat introduces a bug
                            if (Math.random() &lt; 0.001 * count) {
                                vscode.postMessage({
                                    command: 'alert',
                                    text: '🐛  on line ' + count
                                })
                            }
                        }, 100);
                    }())
                &lt;/script&gt;
            &lt;/body&gt;
            &lt;/html&gt;
        `;
}
</code></pre>
<p><img src="https://media.githubusercontent.com/media/Microsoft/vscode-docs/master/api/extension-guides/images/webview/scripts-webview_to_extension.gif" alt="从webview向插件传递信息" /></p>
<p>出于安全性考虑，你必须保证VS Code API的私有性，也不会泄露到全局状态中去。</p>
<h2 id="安全性"><a class="header" href="#安全性">安全性</a></h2>
<hr />
<p>每一个你创建的webview都必须遵循这些基础的安全性最佳实践。</p>
<h3 id="限制能力"><a class="header" href="#限制能力">限制能力</a></h3>
<p>webview应该留有它所需的最小功能集合即可。例如：如果你的webview不需要运行脚本，就不要设置<code>enableScripts: true</code>。如果你的webview不需要加载用户工作区的资源，就把<code>localResourceRoots</code>设置为<code>[vscode.Uri.file(extensionContext.extensionPath)]</code>或者<code>[]</code>以便禁止访问任何本地资源。</p>
<h3 id="内容安全策略"><a class="header" href="#内容安全策略">内容安全策略</a></h3>
<p><a href="https://developers.google.com/web/fundamentals/security/csp/">内容安全策略</a>可以进一步限制webview可以加载和执行的内容。例如：内容安全策略强制可以运行在webview中的脚本白名单，或者告诉webview只加载带<code>https</code>协议的图片。</p>
<p>要想加上内容安全策略，将<code>&lt;meta http-equiv=&quot;Content-Security-Policy&quot;&gt;</code>指令放到webview的<code>&lt;head&gt;</code>中</p>
<pre><code class="language-typescript">function getWebviewContent() {
    return
        `
            &lt;!DOCTYPE html&gt;
            &lt;html lang=&quot;en&quot;&gt;
            &lt;head&gt;
                &lt;meta charset=&quot;UTF-8&quot;&gt;

                &lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;default-src 'none';&quot;&gt;

                &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;

                &lt;title&gt;Cat Coding&lt;/title&gt;
            &lt;/head&gt;
            &lt;body&gt;
                ...
            &lt;/body&gt;
            &lt;/html&gt;
        `;
}
</code></pre>
<p><code>default-src 'none';</code>策略直接禁止了所有内容。我们可以按插件需要的最少内容修改这个指令，如只允许通过<code>https</code>加载本地脚本、样式和图片：</p>
<pre><code class="language-html">&lt;meta
    http-equiv=&quot;Content-Security-Policy&quot;
    content=&quot;default-src 'none'; img-src vscode-resource: https:; script-src vscode-resource:; style-src vscode-resource:;&quot;
&gt;
</code></pre>
<p>上述策略也隐式地禁用了内联脚本和样式。把内联样式和脚本提取到外部文件中是一个非常好的实践，也不会与内容安全策略冲突。</p>
<h3 id="只通过https加载内容"><a class="header" href="#只通过https加载内容">只通过https加载内容</a></h3>
<p>如果你的webview允许加载外部资源，我们强烈建议你只允许通过<code>https</code>加载而不要使用http，上面的例子已经用内容安全策略展示了使用<code>https</code>的方式。</p>
<h3 id="审查用户输入"><a class="header" href="#审查用户输入">审查用户输入</a></h3>
<p>就像构建普通HTML页面一样，你也同样需要在webview中审查用户输入的内容。
没有审查输入内容可能会导致内容注入，也就意味着将用户置于了危险之中。</p>
<p>可能需要审查的值：</p>
<ul>
<li>文件内容</li>
<li>文件和文件夹路径</li>
<li>用户工作区设置</li>
</ul>
<p>可以考虑用一个辅助库去构建HTML模板，或者确保所有来自用户工作区的内容都通过了审查</p>
<p>只依赖审查内容的安全性是不够的，你也要遵循其他<a href="extension-guides/webview.html#%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E7%AD%96%E7%95%A5">安全性的最佳实践</a>，尽可能减少潜在的内容注入。</p>
<h2 id="持久性"><a class="header" href="#持久性">持久性</a></h2>
<hr />
<p>在webview的标准<a href="extension-guides/webview.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">生命周期</a>中，<code>createWebviewPanel</code>负责创建和销毁（用户关闭或者调用<code>.dispose()</code>方法）webview。而webview的内容再是在webview可见时创建的，在webview处于非激活状态时销毁。webview处于非激活标签中时，任何webview中的保留的状态都会丢失。</p>
<p>所以最好减少webview中的状态，取而代之用<a href="extension-guides/webview.html#%E5%B0%86webview%E7%9A%84%E4%BF%A1%E6%81%AF%E4%BC%A0%E9%80%92%E5%88%B0%E6%8F%92%E4%BB%B6%E4%B8%AD">消息传递</a>储存状态。</p>
<h3 id="getstate和setstate"><a class="header" href="#getstate和setstate">getState和setState</a></h3>
<p>运行在webview中的脚本可以使用<code>getState</code>和<code>setState</code>方法保存和恢复JSON序列化的状态对象。这个状态可以一直保留，即使webview面板已经被隐藏，只有当它销毁时，状态则会一起销毁。</p>
<pre><code class="language-typescript">// webview中的脚本
const vscode = acquireVsCodeApi();

const counter = document.getElementById('lines-of-code-counter');

// 检查是否需要恢复状态
const previousState = vscode.getState();
let count = previousState ? previousState.count : 0;
counter.textContent = count;

setInterval(() =&gt; {
    counter.textContent = count++;
    // 更新已经保存的状态
    vscode.setState({ count })
}, 100);
</code></pre>
<p><code>getState</code>和<code>setState</code>是用来保存状态的比较好的办法，因为他们的性能消耗要远低于<code>retainContextWhenHidden</code>。</p>
<h3 id="序列化"><a class="header" href="#序列化">序列化</a></h3>
<p>使用<code>WebviewPanelSerializer</code>之后，你的webview可以在VS Code关闭后自动恢复。序列化构建于<code>getState</code>和<code>setState</code>之上，只有你的插件注册了<code>WebviewPanelSerializer</code>，这个功能才会生效。</p>
<p>给插件的<code>package.json</code>添加一个<code>onWebviewPanel</code>激活事件，然后我们的代码喵就能在VS Code重启后继续工作了：</p>
<pre><code class="language-json">&quot;activationEvents&quot;: [
    ...,
    &quot;onWebviewPanel:catCoding&quot;
]
</code></pre>
<p>这个激活事件确保我们的插件不论VS Code何时恢复<code>catCoding</code>webview时都会启动。</p>
<p>然后在我们插件的<code>activate</code>方法中调用<code>registerWebviewPanelSerializer</code>注册一个新的<code>WebviewPanelSerializer</code>，这个函数负责恢复webview之前保存的内容。其中的state就是webview用<code>setState</code>设置的JSON格式的状态。</p>
<pre><code class="language-typescript">export function activate(context: vscode.ExtensionContext) {
    // 常见设置...

    // 确保我们注册了一个序列化器
    vscode.window.registerWebviewPanelSerializer('catCoding', new CatCodingSerializer());
}

class CatCodingSerializer implements vscode.WebviewPanelSerializer {
    async deserializeWebviewPanel(webviewPanel: vscode.WebviewPanel, state: any) {
        // `state`是webview内调用`setState`保留住的
        console.log(`Got state: ${state}`);

        // 恢复我们的webview内容
        //
        // 确保我们将`webviewPanel`传递到了这里
        // 然后用事件侦听器恢复我们的内容
        webviewPanel.webview.html = getWebviewContent();
    }
}
</code></pre>
<p>在VS Code中打开一个喵喵打代码的面板，关闭后重启就能看到这个面板恢复到了之前的状态和位置。</p>
<h3 id="隐藏时保留上下文"><a class="header" href="#隐藏时保留上下文">隐藏时保留上下文</a></h3>
<p>如果webview的视图非常复杂，或者状态不能很快地保存和恢复，你则可以用<code>retainContextWhenHidden</code>选项，这个选项在不可见的状态中保存了webview的内容，即使webview本身不处于激活状态。</p>
<p>虽然<strong>Cat Coding</strong>说不上有很复杂的状态，不过我们可以打开<code>retainContextWhenHidden</code>看看webview的行为会发生什么变化：</p>
<pre><code class="language-typescript">import * as vscode from 'vscode';

export function activate(context: vscode.ExtensionContext) {
  context.subscriptions.push(
    vscode.commands.registerCommand('catCoding.start', () =&gt; {
      const panel = vscode.window.createWebviewPanel(
        'catCoding',
        'Cat Coding',
        vscode.ViewColumn.One,
        {
          enableScripts: true,
          retainContextWhenHidden: true
        }
      );
      panel.webview.html = getWebviewContent();
    })
  );
}

function getWebviewContent() {
  return
    `
        &lt;!DOCTYPE html&gt;
        &lt;html lang=&quot;en&quot;&gt;
        &lt;head&gt;
            &lt;meta charset=&quot;UTF-8&quot;&gt;
            &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
            &lt;title&gt;Cat Coding&lt;/title&gt;
        &lt;/head&gt;
        &lt;body&gt;
            &lt;img src=&quot;https://media.giphy.com/media/JIX9t2j0ZTN9S/giphy.gif&quot; width=&quot;300&quot; /&gt;
            &lt;h1 id=&quot;lines-of-code-counter&quot;&gt;0&lt;/h1&gt;

            &lt;script&gt;
                const counter = document.getElementById('lines-of-code-counter');

                let count = 0;
                setInterval(() =&gt; {
                    counter.textContent = count++;
                }, 100);
            &lt;/script&gt;
        &lt;/body&gt;
        &lt;/html&gt;
    `;
}
</code></pre>
<p><img src="https://media.githubusercontent.com/media/Microsoft/vscode-docs/master/api/extension-guides/images/webview/persistence-retrain.gif" alt="持久化保留" /></p>
<p>我们可以注意到计数器没有重置，webview隐藏之后就恢复了。而且不需要多余的代码！<code>retainContextWhenHidden</code>的行为就像浏览器一样，脚本和其他内容被暂时挂起，但是一旦webview可见之后就会立即恢复。但是在webview隐藏状态下，你还是不能给它发送消息的。</p>
<p>虽然<code>retainContextWhenHidden</code>很吸引人，但是记住这个功能的内容占用很高，只有其他的持久化技术无能为力之时再选择这种方式。</p>
<h2 id="下一步-6"><a class="header" href="#下一步-6">下一步</a></h2>
<p>如果你想了解学习更多VS Code扩展性的内容，请查看下列主题：</p>
<ul>
<li><a href="extension-guides//">插件API</a> - 所有的VS Code插件API</li>
<li><a href="extension-guides//extension-capabilities/README">插件功能</a> - 其它拓展VS Code功能的方式</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="笔记本-api"><a class="header" href="#笔记本-api">笔记本 API</a></h1>
<p>笔记本 API 允许 Visual Studio Code 以笔记本的形式打开文件，执行笔记本代码单元，把笔记本的内容以多种丰富的并且可交互式的格式展现。在 Visual Studio Code 里面，你可以获得与 Jupyter、Google Colab 等流行的笔记本相似的书写体验。</p>
<p>!&gt; **注意：**笔记本相关的 API 目前还处于开发状态，所以目前只能在 <a href="https://github.com/microsoft/vscode-docs/blob/master/insiders">VS Code Insiders</a> 版本内部使用，同时需要给你的插件项目添加 <code>vscode.proposed.d.ts</code> 文件。想了解更多的有关于试验性 API 的内容， 可以 <a href="https://github.com/microsoft/vscode-docs/blob/master/api/advanced-topics/using-proposed-api">点这里</a>。</p>
<h2 id="笔记本的构成"><a class="header" href="#笔记本的构成">笔记本的构成</a></h2>
<hr />
<p>一个笔记本由一系列代码块以及输出构成。代码块由 VS Code 核心进程负责渲染，它有两种类型，一种是 <strong>Markdown 代码块</strong>，另一种是<strong>常规代码块</strong>。输出的格式是多种多样的，比如普通文本、JSON、图片、HTML。其它的应用相关的数据以及交互式的小程序，由插件<strong>自行</strong>负责渲染。</p>
<p>代码块的读写操作是由 <code>NotebookContentProvider</code> 控制的，<code>NotebookContentProvider</code> 从文件系统中读取数据并将其转化为代码块，同时将笔记本的改动同步给文件系统。<code>NotebookKernel</code> 处理来自代码块的内容，并输出各种各样的格式，包括纯文本、格式化文档或者交互式小程序。应用相关的输出格式和交互式小程序则由 <code>NotebookOutputRenderer</code> 渲染。</p>
<p>一图胜千言：</p>
<p><img src="https://media.githubusercontent.com/media/microsoft/vscode-docs/master/api/extension-guides/images/notebook/architecture-overview.png" alt="结构概览" /></p>
<h2 id="内容供应器函数"><a class="header" href="#内容供应器函数">内容供应器函数</a></h2>
<hr />
<p><a href="https://github.com/microsoft/vscode/blob/43184b2beda9edb613caadc2bab29ec50bad863f/src/vs/vscode.proposed.d.ts#L1792-L1805">参考 NotebookContentProvider API</a></p>
<p>可以使用 <code>NotebookContentProvider</code> 生成一段段的 Markdown 和代码块。与此同时，<code>NotebookContentProvider</code> 会将笔记本中产生的更改同步到源文件中。</p>
<p>下面是一些范例：</p>
<ul>
<li><a href="https://github.com/microsoft/notebook-extension-samples/tree/master/notebook-provider">.ipynb 内容供应器函数</a>：笔记本采用 <a href="https://nbformat.readthedocs.io/en/latest/format_description.html">Jupyter</a> 格式。</li>
<li><a href="https://github.com/microsoft/vscode-markdown-notebook">Markdown 内容供应器函数</a>：以笔记本的格式打开和编辑 Markdown。</li>
</ul>
<h3 id="举个例子"><a class="header" href="#举个例子">举个例子</a></h3>
<p>下面的例子中，我们创建了一个简化版的后缀名为 <code>.notebook</code> 的笔记本提供商插件，用来查看 <a href="https://nbformat.readthedocs.io/en/latest/format_description.html">Jupyter</a> 格式的文件。</p>
<p>内容供应器函数是定义在 <code>package.json</code> 的 <code>contributes.notebookProvider</code> 字段中的，像下面这样：</p>
<pre><code class="language-json">{
    ...
    &quot;activationEvents&quot;: [&quot;onNotebook:my-notebook-provider&quot;],
    &quot;contributes&quot;: {
        ...
        &quot;notebookProvider&quot;: [
            {
                &quot;viewType&quot;: &quot;my-notebook-provider&quot;,
                &quot;displayName&quot;: &quot;My Notebook Provider&quot;,
                &quot;selector&quot;: [
                    {
                        &quot;filenamePattern&quot;: &quot;*.notebook&quot;
                    }
                ]
            }
        ]
    }
}
</code></pre>
<p>然后在插件的 activate 事件中注册：</p>
<pre><code class="language-typescript">import * as vscode from 'vscode';

export function activate(context: vscode.ExtensionContext) {
  context.subscriptions.push(
    vscode.notebook.registerNotebookContentProvider(
      'my-notebook-provider',
      new SampleProvider()
    )
  );
}

class SampleProvider implements vscode.NotebookContentProvider {
  async openNotebook(uri: vscode.Uri): Promise&lt;vscode.NotebookData&gt; {
    const content = JSON.parse((await vscode.workspace.fs.readFile(uri)).toString());
    return {
      languages: [],
      metadata: { custom: content.metadata },
      cells: content.cells.map((cell: any) =&gt; {
        if (cell.cell_type === 'markdown') {
          return {
            cellKind: vscode.CellKind.Markdown,
            source: cell.source,
            language: 'markdown',
            outputs: [],
            metadata: {}
          };
        } else if (cell.cell_type === 'code') {
          return {
            cellKind: vscode.CellKind.Code,
            source: cell.source,
            language: content.metadata?.language_info?.name || 'python',
            outputs: [
              /* not implemented */
            ],
            metadata: {}
          };
        } else {
          console.error('Unexpected cell:', cell);
        }
      })
    };
  }

  // 下面是一些伪方法，与本例无关
  onDidChangeNotebook = new vscode.EventEmitter&lt;vscode.NotebookDocumentEditEvent&gt;().event;
  async resolveNotebook(): Promise&lt;void&gt; {}
  async saveNotebook(): Promise&lt;void&gt; {}
  async saveNotebookAs(): Promise&lt;void&gt; {}
  async backupNotebook(): Promise&lt;vscode.NotebookDocumentBackup&gt; {
    return { id: '', delete: () =&gt; {} };
  }
}
</code></pre>
<p>紧接着，启动你的插件并在插件窗口中打开后缀名为 <code>.notebook</code> 的 Jupyter 格式文件：</p>
<p><img src="https://media.githubusercontent.com/media/microsoft/vscode-docs/master/api/extension-guides/images/notebook/ipynb-simple-provider.png" alt="简单的供应商——ipynb" /></p>
<p>现在，我们可以打开和编辑 Jupyter 格式的笔记本，并且以普通文本和 Markdown 的形式预览代码块。然而，在编辑的时候由于并不会自动并持续性的将内容写入到磁盘中，所以需要实现 <code>saveNotebook</code> 方法，上面的代码中也提到了这个方法。同时，如果要运行每个代码块，需要实现 <code>NotebookKernel</code> 方法。</p>
<p>!&gt; **注意：**默认情况下，输出的 MIME 类型的顺序是通过笔记本提供的 <code>NotebookData#metadata.displayOrder</code> 属性来定义的，你也可以在 <code>openNotebook</code> 方法中自行设置。</p>
<h2 id="内核"><a class="header" href="#内核">内核</a></h2>
<hr />
<p><a href="https://github.com/microsoft/vscode/blob/43184b2beda9edb613caadc2bab29ec50bad863f/src/vs/vscode.proposed.d.ts#L1807-L1812">参考 NotebookKernel API</a></p>
<p><code>NotebookKernel</code> 负责接收一个代码单元，并将其转化为一个或一组输出。</p>
<p>可以通过设置 <code>NotebookContentProvider#kernel</code> 属性，将笔记本内核（<code>NotebookKernel</code>）与一个内容供应器函数直接关联；或者调用 <code>vscode.registerNotebookKernel</code> 方法来全局注册，<code>registerNotebookKernel</code> 方法接收三个参数：</p>
<ul>
<li>
<p>一个内核的标识符</p>
</li>
<li>
<p>与验证文件相关的正则表达式列表</p>
</li>
<li>
<p>一个 <code>vscode.NotebookKernel</code> 对象：</p>
<pre><code class="language-typescript">vscode.notebook.registerNotebookKernel(
    &quot;http-kernel&quot;,
    [&quot;*.http&quot;],
    {
        label: &quot;Http Kernel&quot;,
        executeCell(document: NotebookDocument, cell: NotebookCell, token: CancellationToken): Promise&lt;void&gt; { ... }
        executeAllCells(document: NotebookDocument, token: CancellationToken): Promise&lt;void&gt; { ... }
    }
)
</code></pre>
</li>
</ul>
<p>如果已经通过 <code>NotebookContentProvider#kernel</code> 属性为 <code>NotebookContentProvider</code> 注册了一个内核，那么当你打开某个笔记本的时候， 这个内核会被默认选中。否则，会从已注册的内核中选取，你也可以使用 <strong>Notebook: Select Notebook Kernel</strong> 命令来自行切换要使用的内核。</p>
<p>一个小例子：</p>
<ul>
<li><a href="https://github.com/microsoft/vscode-github-issue-notebooks/blob/master/src/extension/notebookProvider.ts">Github Issues 笔记本</a>：一个笔记本内核，用来执行 Github Issues 查询</li>
</ul>
<h3 id="最佳实践"><a class="header" href="#最佳实践">最佳实践</a></h3>
<p>尽管一个笔记本内核只需要返回一个输出，实际上你仍然可以在其执行每一个代码块的时候，设置代码块的 <code>metadata</code>，借此来实现诸如时间计数器、执行徽标排序、运行状态图标此类的功能。下面的代码演示了如何使用 <code>executeCell</code> 方法：</p>
<pre><code class="language-typescript">async function executeCell(
  document: vscode.NotebookDocument,
  cell: vscode.NotebookCell,
  token: vscode.CancellationToken
) {
  try {
    cell.metadata.runState = vscode.NotebookCellRunState.Running;
    const start = +new Date();
    cell.metadata.runStartTime = start;
    cell.metadata.executionOrder = ++this.runIndex;
    const result = await doExecuteCell(document, cell, token);
    cell.outputs = [result];
    cell.metadata.runState = vscode.NotebookCellRunState.Success;
    cell.metadata.lastRunDuration = +new Date() - start;
  } catch (e) {
    cell.outputs = [
      {
        outputKind: vscode.CellOutputKind.Error,
        ename: e.name,
        evalue: e.message,
        traceback: [e.stack]
      }
    ];
    cell.metadata.runState = vscode.NotebookCellRunState.Error;
    cell.metadata.lastRunDuration = undefined;
  }
}
</code></pre>
<h2 id="输出类型"><a class="header" href="#输出类型">输出类型</a></h2>
<hr />
<p>输出的类型必须得是以下这三种格式中的一个：</p>
<ul>
<li>文本</li>
<li>错误</li>
<li>富文本</li>
</ul>
<p>一个代码块如果产生多种输出，这种情况下输出为一个列表。</p>
<p>一些简单的输出格式，比如文本、错误、富文本（HTML，Markdown，JSON），由 VS Code 核心进程负责渲染；而一些增强型的输出格式，比如与应用相关的富文本输出类型，则由 <a href="extension-guides/notebook.html#%E8%BE%93%E5%87%BA%E6%B8%B2%E6%9F%93%E5%99%A8">NotebookOutputRenderer</a> 负责渲染。插件可以自行渲染一些 “简单的” 增强型输出格式，比如添加 Markdown 对 LaTeX 的支持。</p>
<p><img src="https://media.githubusercontent.com/media/microsoft/vscode-docs/master/api/extension-guides/images/notebook/kernel.png" alt="内核" /></p>
<h3 id="文本输出"><a class="header" href="#文本输出">文本输出</a></h3>
<p>文本是最简单的输出格式，输出文本所做的工作和很多其它的编辑器类似。文本仅由 <code>文本域</code> 组成，会以普通文本的形式进行渲染。</p>
<pre><code class="language-typescript">{
    outputKind: vscode.CellOutputKind.Text,
    text: '...'
}
</code></pre>
<p><img src="https://media.githubusercontent.com/media/microsoft/vscode-docs/master/api/extension-guides/images/notebook/text-output.png" alt="输出文本" /></p>
<h3 id="错误输出"><a class="header" href="#错误输出">错误输出</a></h3>
<p>错误输出可以通过一种易于理解的方式来展示运行时发生的异常。它包含 <code>ename</code>、<code>evalue</code>、<code>traceback</code> 这几个属性，前两者分别用来展示错误类型和错误信息，<code>traceback</code> 接收一个字符串数组并以调用栈的形式展示。并且数组中的字符串可以使用 ANSI 编码来进行着色：</p>
<pre><code class="language-typescript">{
    outputKind: vscode.CellOutputKind.Error,
    ename: 'Error Name',
    evalue: 'Error Value',
    traceback: ['\x1b[35mstack frame 1\x1b[0m', 'stack frame 2', 'stack frame 3', 'stack frame 4']
}
</code></pre>
<p><img src="https://media.githubusercontent.com/media/microsoft/vscode-docs/master/api/extension-guides/images/notebook/error-output.png" alt="输出错误" /></p>
<h3 id="富文本输出"><a class="header" href="#富文本输出">富文本输出</a></h3>
<p>富文本以 MIME 类型作为 key 值，可以为输出的数据提供多种不同的展现形式，是展示代码块的最高级的输出格式。假如代码块是一个 Github Issue，那么内核会基于代码块的 <code>data</code> 配置项，产生以下几种不同格式的输出：</p>
<ul>
<li><code>text/html</code>：将 Github Issue 转化为 HTML 输出</li>
<li><code>application/json</code>：输出 JSON 格式的数据</li>
<li><code>application/github-issue</code>：可以使用 <code>NotebookOutputRenderer</code> 来创建一个完整的关于该 Github Issue 的交互式视图</li>
</ul>
<p><code>text/html</code> 和 <code>application/json</code> 由 VS Code 自己负责渲染，而 <code>application/github-issue</code> 则交给 <code>NotebookOutputRenderer</code> 负责渲染，如果 MIME 类型没有注册相应的 <code>NotebookOutputRenderer</code>，那么就会展示一个错误。</p>
<pre><code class="language-typescript">{
    outputKind: vscode.CellOutputKind.Rich,
    data: {
        'text/html': '&lt;b&gt;Hello&lt;/b&gt; World',
        'application/json': { hello: 'world' },
        'application/custom': 'my-custom-data-interchange-format',
    }
}
</code></pre>
<p><img src="https://media.githubusercontent.com/media/microsoft/vscode-docs/master/api/extension-guides/images/notebook/rich-output.gif" alt="输出富文本" /></p>
<p>一般情况下，VS Code 可以渲染以下几种 MIME 类型：</p>
<ul>
<li>application/json</li>
<li>application/javascript</li>
<li>text/html</li>
<li>image/svg+xml</li>
<li>text/markdown</li>
<li>image/png</li>
<li>image/jpeg</li>
<li>text/plain</li>
<li>text/x-javascript</li>
</ul>
<p>如果你想渲染其它类型的 MIME，就需要为这个 MIME 注册一个 <code>NotebookOutputRenderer</code>。</p>
<h2 id="输出渲染器"><a class="header" href="#输出渲染器">输出渲染器</a></h2>
<hr />
<p>输出渲染器负责接收并渲染 MIME 类型的输出数据，最终呈现的渲染结果可以是简单的 HTML，也可以是复杂的交互式应用程序。在本节，我们一起看看如何渲染一个关于 Github Issue 的视图。</p>
<h3 id="一个简单的-非交互式的渲染器"><a class="header" href="#一个简单的-非交互式的渲染器">一个简单的, 非交互式的渲染器</a></h3>
<p>为了渲染一组 MIME 类型的数据，你可以在你的插件项目的 <code>package.json</code> 文件中的 <code>contributes.notebookOutRenderer</code> 字段下声明渲染器。我们假设已经安装的内核能够正常提供渲染器，那么当你输入 <code>ms-vscode.github-issue-notebook/github-issue</code> 的时候，这个渲染器就会开始工作。</p>
<pre><code class="language-json">{
  &quot;activationEvents&quot;: [&quot;....&quot;],
  &quot;contributes&quot;: {
    ...
    &quot;notebookOutputRenderer&quot;: [
      {
        &quot;id&quot;: &quot;github-issue-static-renderer&quot;,
        &quot;displayName&quot;: &quot;Static Issue Renderer&quot;,
        &quot;entrypoint&quot;: &quot;./out/renderer.js&quot;,
        &quot;mimeTypes&quot;: [
          &quot;ms-vscode.github-issue-notebook/github-issue&quot;
        ]
      }
    ]
  }
}
</code></pre>
<p>为了避免输出渲染器和 VS Code 的 UI 发生冲突，导致 VS Code 性能下降，输出渲染器总是被放到一个独立的 <code>iframe</code> 中。上述代码中 “entrypoint” 字段指的是一个独立的脚本文件，可以是自己手写，也可以是 Webpack、Rollup、Parcel 打包后的文件，当 <code>iframe</code> 里面需要渲染内容的时候，就会加载这个脚本。</p>
<p>当 “entrypoint” 脚本加载完成之后，会立刻调用 <code>acquireNotebookRendererApi()</code> 函数并传入你的渲染器 ID 作为参数，与此同时，开始监听笔记本的输出事件。比如，下面的代码会把整个 Github Issue 作为 JSON 传递给代码块作为输出：</p>
<pre><code class="language-javascript">const notebookApi = acquireNotebookRendererApi('github-issue-static-renderer');

notebookApi.onDidCreateOutput(evt =&gt; {
  const output = evt.output.data[evt.mimeType];
  evt.element.innerText = JSON.stringify(output);
});
</code></pre>
<p>完整的 API 声明可以 <a href="https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/vscode-notebook-renderer/index.d.ts">看这里</a>。如果你用的是 TypeScript，那么为了使用上述的 API 声明，你首先需要安装 <code>@types/vscode-notebook-renderer</code>，然后在 <code>tsconfig.json</code> 文件的 <code>types</code> 字段中添加 <code>vscode-notebook-renderer</code>。因为 <code>acquireNotebookRendererApi</code> 方法是一个全局变量，所以我们把 <code>@types/vscode</code> 和 <code>@types/vscode-notebook-renderer</code> 这两个声明文件分开了。</p>
<p>要创建富文本内容，你可以手动创建 DOM 元素，或者直接使用 Preact 这样的框架，将内容直接注入到指定的元素，看下面的例子：</p>
<pre><code class="language-typescript">import { h, render } from 'preact';

const notebookApi = acquireNotebookRendererApi(&quot;github-issue-static-renderer&quot;);

const Issue: FunctionComponent&lt;{ issue: GithubIssue }&gt; = ({ issue }) =&gt; (
  &lt;div key={issue.number}&gt;
    &lt;h2&gt;
      {issue.title}
      (&lt;a href={`https://github.com/${issue.repo}/issues/${issue.number}`}&gt;#{issue.number}&lt;/a&gt;)
    &lt;/h2&gt;
    &lt;img src={issue.user.avatar_url} style={{ float: 'left', width: 32, borderRadius: '50%', marginRight: 20 }} /&gt;
    &lt;i&gt;@{issue.user.login}&lt;/i&gt; Opened: &lt;div style=&quot;margin-top: 10px&quot;&gt;{issue.body}&lt;/div&gt;
  &lt;/div&gt;
);

const GithubIssues: FunctionComponent&lt;{ issues: GithubIssue[]; }&gt; = ({ issues }) =&gt; (
  &lt;div&gt;{issues.map(issue =&gt; &lt;Issue key={issue.number} issue={issue} /&gt;)}&lt;/div&gt;
);

notebookApi.onDidCreateOutput((evt) =&gt; {
  const output = evt.output.data[evt.mimeType];
  render(&lt;GithubIssues issues={output} /&gt;, evt.element);
});
</code></pre>
<p>现在可以在输出代码块上通过运行 <code>ms-vscode.github-issue-notebook/github-issue</code> 来预览结果，如下图所示：</p>
<p><img src="https://media.githubusercontent.com/media/microsoft/vscode-docs/master/api/extension-guides/images/notebook/static-renderer-sample.png" alt="静态的渲染器示例" /></p>
<p>如果在代码块的 DOM 容器外部有其它的元素，或者有一些异步任务，那么你可以在 <code>onWillDestroyOutput</code> 方法中进行释放。<code>onWillDestroyOutput</code>方法会在以下几个条件下执行：</p>
<ul>
<li>代码块输出被清空后</li>
<li>当前代码块被删除之后</li>
<li>当前代码块的输出进行渲染之前</li>
</ul>
<p>可以看下面的例子：</p>
<pre><code class="language-javascript">const intervals = new Map();

notebookApi.onDidCreateOutput(evt =&gt; {
  const output = evt.output.data[evt.mimeType];
  render(&lt;GithubIssues issues={output} /&gt;, evt.element);

  // 创建一个定时器，在每一秒进行修改 h2 的颜色
  intervals.set(
    evt.outputId,
    setInterval(() =&gt; {
      evt.element.querySelector('h2').style.color = `hsl(${Math.random() *
        360}, 100%, 50%)`;
    }, 1000)
  );
});

notebookApi.onWillDestroyOutput(scope =&gt; {
  if (scope === undefined) {
    // 如果 scope 是 undefined 的话，所有的输出都会被销毁
    for (const interval of intervals.values()) {
      clearInterval(interval);
    }
    intervals.clear();
  } else {
    // 反之，销毁一个单独的输出
    clearInterval(intervals.get(scope.outputId));
    intervals.delete(scope.outputId);
  }
});
</code></pre>
<p>你必须牢记在心的是，一个笔记本中的每个代码块，会被渲染到同一个 iframe 的不同 DOM 元素上，所以为了避免产生冲突，当你使用诸如 <code>document.querySelector</code> 此类的选择器的时候，要确保每个代码块都有一个特定的标识。在上面的例子中，我们通过使用 <code>evt.element.querySelector</code> 来避免这个问题。</p>
<h3 id="交互式的笔记本"><a class="header" href="#交互式的笔记本">交互式的笔记本</a></h3>
<p>想象一下，如果我们想通过点击一个按钮，然后查看这个 Github Issue 的评论，应该怎么做呢？在这里，我们假设在运行 <code>ms-vscode.github-issue-notebook/github-issue-with-comments</code> 命令之后，内核（<code>kernel</code>）可以正常提供带有评论的 Github Issue，下面是代码实现：</p>
<pre><code class="language-typescript">const Issue: FunctionComponent&lt;{ issue: GithubIssueWithComments }&gt; = ({ issue }) =&gt; {
  const [showComments, setShowComments] = useState(false);

  return (
    &lt;div key={issue.number}&gt;
      &lt;h2&gt;
        {issue.title}
        (&lt;a href={`https://github.com/${issue.repo}/issues/${issue.number}`}&gt;#{issue.number}&lt;/a&gt;)
      &lt;/h2&gt;
      &lt;img src={issue.user.avatar_url} style={{ float: 'left', width: 32, borderRadius: '50%', marginRight: 20 }} /&gt;
      &lt;i&gt;@{issue.user.login}&lt;/i&gt; Opened: &lt;div style=&quot;margin-top: 10px&quot;&gt;{issue.body}&lt;/div&gt;
      &lt;button onClick={() =&gt; setShowComments(true)}&gt;Show Comments&lt;/button&gt;
      {showComments &amp;&amp; issue.comments.map(comment =&gt; &lt;div&gt;{comment.text}&lt;/div&gt;)}
    &lt;/div&gt;
  );
};
</code></pre>
<p>上面的代码存在几个明显的问题：</p>
<ul>
<li>在点击按钮之前，就已经把所有 Issue 的评论都加载了</li>
<li>仅仅是展示更多数据，就需要为所有不同的 MIME 类型提供笔记本内核（<code>kernel</code>）的支持</li>
</ul>
<p>内核可以给渲染器提供额外的功能，比如添加一个预加载器，VS Code 会将预加载器里内容也装载到 iframe 里。这个加载项脚本可以通过其自身的 postMessage 接口来访问 <code>acquireVsCodeApi()</code>，你可以把它封装为 iframe 中的全局对象。</p>
<p><img src="https://media.githubusercontent.com/media/microsoft/vscode-docs/master/api/extension-guides/images/notebook/kernel-communication.png" alt="内核通讯" /></p>
<p>举个例子，你可能会修改内核中的 <code>preloads</code> 来引用一个新文件，在这个文件里你创建了一个与插件主机通信的连接，并暴露了一个全局对象供渲染器使用，具体代码如下：</p>
<pre><code class="language-typescript">globalThis.githubIssueCommentProvider = {
  loadComments(issueId: string, callback: (comments: GithubComment[]) =&gt; void) {
    vscodeApi.postMessage({ command: 'comments', issueId });
    const listener = event =&gt; {
      if (event.data.type === 'comments' &amp;&amp; event.data.issueId === issueId) {
        callback(event.data.comments);
        window.removeEventListener('message', listener);
      }
    };

    window.addEventListener('message', listener);
  }
};
</code></pre>
<p>由于其他开发者可能在其它的笔记本上创建了 Github Issue 输出，并且没有实现 <code>githubIssueCommentProvider</code>，因此在这种情况下，我们在渲染器中首先要判断预加载脚本中的全局对象是否存在并且可用，并且只在可用的情况下显示 “Load Comments（加载评论）” 按钮：</p>
<pre><code class="language-typescript">const canLoadComments = globalThis.githubIssueCommentProvider !== undefined;

const Issue: FunctionComponent&lt;{ issue: GithubIssue }&gt; = ({ issue }) =&gt; {
  const [comments, setComments] = useState([]);
  const loadComments = () =&gt;
    globalThis.githubIssueCommentProvider.loadComments(issue.id, setComments);

  return (
    &lt;div key={issue.number}&gt;
      &lt;h2&gt;
        {issue.title}
        (&lt;a href={`https://github.com/${issue.repo}/issues/${issue.number}`}&gt;#{issue.number}&lt;/a&gt;)
      &lt;/h2&gt;
      &lt;img src={issue.user.avatar_url} style={{ float: 'left', width: 32, borderRadius: '50%', marginRight: 20 }} /&gt;
      &lt;i&gt;@{issue.user.login}&lt;/i&gt; Opened: &lt;div style=&quot;margin-top: 10px&quot;&gt;{issue.body}&lt;/div&gt;
      {canLoadComments &amp;&amp; &lt;button onClick={loadComments}&gt;Load Comments&lt;/button&gt;}
      {comments.map(comment =&gt; &lt;div&gt;{comment.text}&lt;/div&gt;)}
    &lt;/div&gt;
  );
};
</code></pre>
<p>最后，假设我们想要与 webview 建立通信。文档选中内核时会调用 <code>NotebookKernelProvider.resolveKernel</code>，然后你就可以往该方法中提供引用到 webview 对象的参数实现通信了。要实现这个方法，可以给 <code>onDidReceiveMessage</code> 方法设置一个监听器：</p>
<pre><code class="language-typescript">export class MyKernelProvider extends vscode.NotebookKernelProvider {
  // ...

  public resolveKernel(kernel, document, webview) {
    webview.onDidReceiveMessage(message =&gt; {
      if (message.command === 'comments') {
        kernel.getCommentsForIssue(message.issueId).then(comments =&gt; webview.postMessage({
          type: 'comments',
          issueId: message.issueId,
          comments,
        }));
      }
    });
  }
</code></pre>
<h2 id="调试支持"><a class="header" href="#调试支持">调试支持</a></h2>
<hr />
<p>对于一些实现了支持编程语言特性的笔记本内核，支持代码块的调试是很有必要的。可以通过以下几种方式来为内核添加调试支持：</p>
<ul>
<li>可以利用笔记本内核实现一个 <a href="extension-guides//extension-guides/debugger-extension.html">调试器插件</a></li>
<li>直接实现一个 <a href="https://microsoft.github.io/debug-adapter-protocol/">调试器协议(DAP)</a></li>
<li>通过代理，将协议转换为现有的笔记本调试器（查阅 ‘vscode-simple-jupyter-notebook’）</li>
</ul>
<p>当然，最简单的方式就是使用现有的未经修改的调试器插件，并将调试器协议（DAP）转化为符合当前笔记本要求的协议（查阅 ‘vscode-nodebook’）。</p>
<p>最后附上案例：</p>
<ul>
<li><a href="https://github.com/microsoft/vscode-nodebook">vscode-nodebook</a>：基于 VS Code 内置的 JavaScript 调试器和一些简单的转换协议，提供的 Node.js 笔记本调试器</li>
<li><a href="https://github.com/microsoft/vscode-simple-jupyter-notebook">vscode-simple-jupyter-notebook</a>：基于已存的 Xeus 调试器</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="虚拟文档"><a class="header" href="#虚拟文档">虚拟文档</a></h1>
<p>通过VS Code的文本内容供应器API(text document content provider API)，你可以为任意来源的文件创建只读文档。本示例源码请查看<a href="https://github.com/Microsoft/vscode-extension-samples/blob/master/virtual-document-sample/README.md">https://github.com/Microsoft/vscode-extension-samples/blob/master/virtual-document-sample/README.md</a></p>
<h2 id="textdocumentcontentprovider"><a class="header" href="#textdocumentcontentprovider">TextDocumentContentProvider</a></h2>
<hr />
<p>这个API工作于uri协议之上，你需要声明一个<em>供应器函数(provider)</em>，然后这个函数还需要返回文本内容。供应器函数必须提供<em>协议(scheme)</em>，而且函数注册之后不可改变这个协议。一个供应器函数可以对应多个协议，而多个供应器函数也可以只注册一个协议。</p>
<pre><code class="language-typescript">vscode.workspace.registerTextDocumentContentProvider(myScheme, myProvider);
</code></pre>
<p>调用<code>registerTextDocumentContentProvider</code>函数会返回一个用于释放资源的<em>释放器</em>。供应器函数还必须实现<code>provideTextDocumentContent</code>函数，这个函数需要传入uri参数和取消式令牌(cancellation token)调用。</p>
<pre><code class="language-typescript">const myProvider = class implements vscode.TextDocumentContentProvider {
	provideTextDocumentContent(uri: vscode.Uri): string {
		// 简单调用cowsay, 直接把uri-path当做文本内容
		return cowsay.say({ text: uri.path });
	}
};
</code></pre>
<p>!&gt; <strong>注意</strong>：我们的供应器函数不为虚拟文档创建uri——他的角色仅仅只是<strong>根据uri返回对应的文本内容</strong>。</p>
<p>下面我们简单使用一个'cowsay'命令创建一个uri，然后编辑器就能显示了：</p>
<pre><code class="language-typescript">vscode.commands.registerCommand('cowsay.say', async () =&gt; {
	let what = await vscode.window.showInputBox({ placeHolder: 'cow say?' });
	if (what) {
		let uri = vscode.Uri.parse('cowsay:' + what);
		let doc = await vscode.workspace.openTextDocument(uri); // 调用供应器函数
		await vscode.window.showTextDocument(doc, { preview: false });
	}
});
</code></pre>
<p>这个命令首先弹出了一个输入框，然后创建了一个*<code>cowsay</code>协议*的uri，再然后根据这个uri读取了文档，最后为这个文档内容打开了一个编辑器（这里的“编辑器”不是指VS Code本身，而是VS Code中打开的单个编辑区tab）。在第三步中，<em>供应器函数</em>需要为这个uri提供对应的内容。</p>
<p>经过这整个流程，我们才算完整地实现了一个<em>文本内容供应器</em>，接下来的部分我们继续学习怎么更新虚拟文档，怎么注册虚拟文档的 UI命令。</p>
<h3 id="更新虚拟文档"><a class="header" href="#更新虚拟文档">更新虚拟文档</a></h3>
<p>为了支持跟踪虚拟文档发生的变化，供应器实现了<code>onDidChange</code>事件。如果文档正在被使用，那么必须为其提供一个uri来调用它，同时编辑器会请求新的内容。</p>
<p><code>vscode.Event</code>定义了VS Code的事件规范。实现事件的最好方式就是使用<code>vscode.EventEmitter</code>，比如：</p>
<pre><code class="language-typescript">const myProvider = class implements vscode.TextDocumentContentProvider {
  // 事件发射器和事件
  onDidChangeEmitter = new vscode.EventEmitter&lt;vscode.Uri&gt;();
  onDidChange = this.onDidChangeEmitter.event;

  //...
};
</code></pre>
<p>上述就是VS Code监听虚拟文档变化所必须的内容。下面将使用事件发射器来添加<em>编辑器行为</em>。</p>
<h3 id="添加编辑器命令"><a class="header" href="#添加编辑器命令">添加编辑器命令</a></h3>
<p>为了阐述事件变动和获取更多cowsay，我们需要倒叙cow刚刚说的东西。首先我们需要一个命令：</p>
<pre><code class="language-typescript">// 注册一个可以更新当前cow的命令
subscriptions.push(
	vscode.commands.registerCommand('cowsay.backwards', async () =&gt; {
		if (!vscode.window.activeTextEditor) {
			return; // 不打开编辑器
		}
		let { document } = vscode.window.activeTextEditor;
		if (document.uri.scheme !== myScheme) {
			return; // 不是我的协议时直接返回
		}
		// 获取path的内容, 对这个内容倒序处理, 然后创建一个新的uri
		let say = document.uri.path;
		let newSay = say
			.split('')
			.reverse()
			.join('');
		let newUri = document.uri.with({ path: newSay });
		await vscode.window.showTextDocument(newUri, { preview: false });
	})
);
</code></pre>
<p>上面的代码片段检查了我们当前是不是激活了一个编辑器（用户当前选中的编辑器tab），对应的文档是不是符合我们的协议。因为命令是对任何人生效的，所以我们有必要去做这些检查。然后uri的path对象被翻转，再重新创建出一个新的uri，最后则打开了一个编辑器。</p>
<p>注册命令最重要事就是在<code>package.json</code>中声明配置。我们在<code>contributes</code>部分添加下列配置：</p>
<pre><code class="language-json">&quot;menus&quot;: {
  &quot;editor/title&quot;: [
    {
      &quot;command&quot;: &quot;cowsay.backwards&quot;,
      &quot;group&quot;: &quot;navigation&quot;,
      &quot;when&quot;: &quot;resourceScheme == cowsay&quot;
    }
  ]
}
</code></pre>
<p><code>contributes/commands</code>中的<code>cowsay.backwards</code>命令告诉编辑器<em>操作</em>出现在编辑器的标题菜单中（工具栏右上角），但如果只是这样简单的配置，每个编辑器就都会显示这个命令。然后我们的<code>when</code>语句就出场了，它描述了何时才显示这个操作。在这个例子中，文档的资源协议必须是<code>cowsay</code>，我们的命令才会生效。这个配置对默认显示全部命令的<code>commandPalette</code>菜单同样生效。</p>
<p><img src="https://media.githubusercontent.com/media/Microsoft/vscode-docs/master/api/extension-guides/images/virtual-documents/cowsay-bwd.png" alt="cowsay-bwd" /></p>
<h3 id="事件的可见性"><a class="header" href="#事件的可见性">事件的可见性</a></h3>
<p><em>文档供应器函数</em>是VS Code中的一等公民，它们的内容以常规的文本文档格式呈现，它们共用一套基础实现方式——如：使用了文件系统的实现。这也就意味着“你的”文档无法被隐藏，它们必定会出现在<code>onDidOpenTextDocument</code>和<code>onDidCloseTextDocument</code>事件中，它们是<code>vscode.workspace.textDocuments</code>中的一部分。通用的准则就是根据文档的<code>协议</code>决定你是否需要对文档进行什么操作。</p>
<h3 id="文件系统api"><a class="header" href="#文件系统api">文件系统API</a></h3>
<p>如果你需要更强的灵活性和掌控力，请查看<a href="https://code.visualstudio.com/api/references/vscode-api#FileSystemProvider"><code>FileSystemProvider</code></a>API，它可以实现整套完整的文件系统，获取文件、文件夹、二进制数据，删除文件，创建文件等等。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="任务"><a class="header" href="#任务">任务</a></h1>
<p>通常，在VS Code中，用户可以通过<code>task.json</code>定义一个<a href="https://code.visualstudio.com/docs/editor/tasks">任务</a>。不过在软件开发中，VS Code会自动检测某些任务。</p>
<p>本节介绍了插件应该怎样使用<a href="https://ruby.github.io/rake/">Rakefiles</a>中的<strong>自动检测任务</strong>配置项，为最终用户提供任务。完整的源代码请参阅<a href="https://github.com/Microsoft/vscode-extension-samples/tree/master/task-provider-sample">这里</a>。</p>
<h2 id="定义任务"><a class="header" href="#定义任务">定义任务</a></h2>
<hr />
<p>想要定义一个系统级别的任务，插件需要通过properties定义任务，在下面叫做Rake的例子中，任务是这样定义的：</p>
<p>?&gt;**译者注：**rake是ruby实现的任务管理和自动构建工具，详细请参考<a href="https://rubygems.org/gems/rake/">rake</a></p>
<pre><code class="language-json">&quot;taskDefinitions&quot;: [
    {
        &quot;type&quot;: &quot;rake&quot;,
        &quot;required&quot;: [
            &quot;task&quot;
        ],
        &quot;properties&quot;: {
            &quot;task&quot;: {
                &quot;type&quot;: &quot;string&quot;,
                &quot;description&quot;: &quot;The Rake task to customize&quot;
            },
            &quot;file&quot;: {
                &quot;type&quot;: &quot;string&quot;,
                &quot;description&quot;: &quot;The Rake file that provides the task. Can be omitted.&quot;
            }
        }
    }
]
</code></pre>
<p>上面代码里面，我们为<code>rake</code><em>任务集</em>配置了一个<strong>任务定义</strong>。任务定义有两个属性<code>task</code>和<code>file</code>，<code>task</code>是Rake任务的名字，file指向了包含任务的文件。<code>task</code>属性是必须的，<code>file</code>则为可选。如果省略了<code>file</code>属性，则会使用工作区根目录下名为<code>RakeFile</code>的文件。</p>
<h2 id="任务供应器函数"><a class="header" href="#任务供应器函数">任务供应器函数</a></h2>
<hr />
<p>和语言供应器函数相同，任务供应器使插件支持代码补全，一个插件可以只注册一个任务供应器函数然后执行所有可用的任务集合。使用<code>vscode.tasks</code>命名空间达成这一目标：</p>
<pre><code class="language-typescript">import * as vscode from 'vscode';

let rakePromise: Thenable&lt;vscode.Task[]&gt; | undefined = undefined;
const taskProvider = vscode.tasks.registerTaskProvider('rake', {
    provideTasks: () =&gt; {
        if (!rakePromise) {
            rakePromise = getRakeTasks();
        }
        return rakePromise;
    },
    resolveTask(_task: vscode.Task): vscode.Task | undefined {
        return undefined;
    }
});
</code></pre>
<p>目前<code>resolveTask</code>只返回了<code>undefined</code>，而将来VS Code会通过这个方法优化任务的加载。</p>
<p><code>getRakeTasks</code>的实现做了下面的事情：</p>
<ul>
<li>使用<code>rake -AT -f Rakefile</code>命令列出rake文件中的所有rake任务</li>
<li>转换为stdio输出</li>
<li>对每个任务创建一个<code>vscode.task</code>实现</li>
</ul>
<p>因为一个rake任务初始化需要<code>package.json</code>中有对应的任务定义，VS Code会用TypeScript接口定义出结构，像这样：</p>
<pre><code class="language-typescript">interface RakeTaskDefinition extends vscode.TaskDefinition {

    /**
     * The task name
     */
    task: string;

    /**
     * The rake file containing the task
     */
    file?: string;
}
</code></pre>
<p>假设我们的输出最终来自于一个叫<code>compile</code>的任务，那么对应的任务创建过程如下所示：</p>
<pre><code class="language-typescript">let task = new vscode.Task(
    { type: 'rake', task: 'compile' },
    'compile',
    'rake',
    new vscode.ShellExecution('rake compile')
);
</code></pre>
<p>每个输出任务都对应着上述过程，最后通过调用<code>getRakeTasks</code>会返回一个任务数组。</p>
<p><code>ShellExecution</code>会针对不同的系统在shell中执行<code>rake compile</code>命令（如：在Windows下会在PowerShell中执行，Ubuntu则是bash）。如果某个任务需要直接执行进程（不通过shell生成），则可以使用<code>vscode.ProcessExecution</code>。<code>ProcessExecution</code>的优势在于插件可以完全控制传入进程的参数，<code>ShellExecution</code>则会使用shell命令转义（比如：bash中的*展开）。如果<code>ShellExecution</code>是通过单个命令创建的，那么插件需要在命令内部确保引号和转义符的正确使用（比如，如何处理空格）。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="源控制api"><a class="header" href="#源控制api">源控制API</a></h1>
<p>VS Code 允许插件创作者通过扩展API去定义<em>源控制管理</em>特性（Source Control Management，SCM），VS Code整合了各式各样的SCM体系，而只给用户展现了一组小巧、强大的API接口，还是带用户界面的那种。</p>
<p><img src="https://media.githubusercontent.com/media/Microsoft/vscode-docs/master/api/extension-guides/images/scm-provider/main.png" alt="VS Code的SCM" /></p>
<p>VS Code自带一个源控制器：Git，它是源控制API的最佳实践。如果你想构建你自己的SCM供应器，那么这是<a href="https://github.com/Microsoft/vscode/blob/master/extensions/git/src/repository.ts">一个很好的起点</a>。</p>
<blockquote>
<p>VS Code插件市场还有很多类似的超赞的插件，比如<a href="https://marketplace.visualstudio.com/items?itemName=johnstoncode.svn-scm">SVN</a>。</p>
</blockquote>
<p>如果你需要帮助，请查看<a href="https://code.visualstudio.com/api/references/vscode-api#scm">vscode命名空间API</a>。</p>
<h2 id="源控制模型"><a class="header" href="#源控制模型">源控制模型</a></h2>
<hr />
<p><code>SourceControl</code>负责生产源控制模型的实体，它里面有<code>SourceControlResourceState</code>实例的<strong>资源状态</strong>，而资源状态又是<code>SourceControlResourceGroup</code>实例整理成<strong>组</strong>的。</p>
<p>通过<code>vscode.scm.createSourceControl</code>创建一个新的<em>源控制器</em>。</p>
<p>为了更好地理解这几种实体的交互，让我们拿<a href="https://github.com/Microsoft/vscode/tree/master/extensions/git">Git</a>来做例子，考虑下列<code>git status</code>输出：</p>
<pre><code class="language-bash">vsce master* → git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)

        modified:   README.md
        renamed:    src/api.ts -&gt; src/test/api.ts

Changes not staged for commit:
  (use &quot;git add/rm &lt;file&gt;...&quot; to update what will be committed)
  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)

        deleted:    .travis.yml
        modified:   README.md
</code></pre>
<p>这个工作区里面发生了很多事，首先，<code>README.md</code>文件已经被修改了但还没有提交，然后立刻又被修改了。 其次，<code>src/api.ts</code>文件被移动到了<code>src/test/api.ts</code>，这个修改已经存备（staged）， 最后，<code>.travis.yml</code>文件被删除。</p>
<p>对于这个工作区而言，Git定义了两个资源组：<strong>工作中（Working tree）<strong>和</strong>已索引（Index）</strong>，对于单个组而言，每次<strong>文件修改</strong>就会产生一些资源状态：</p>
<ul>
<li><strong>已索引</strong> - 资源组
<ul>
<li>修改<code>README.md</code> - 资源状态</li>
<li>移动<code>src/api.ts</code>到<code>src/test/api.ts</code> - 资源状态</li>
</ul>
</li>
<li><strong>工作中</strong> - 资源组
<ul>
<li>删除<code>.travis.yml</code> - 资源状态</li>
<li>修改<code>README.md</code> - 资源状态</li>
</ul>
</li>
</ul>
<p>同一个<code>README.md</code>是怎么成为两组截然不同的资源状态呢？</p>
<p>下面揭秘Git是如何创建这个模型的：</p>
<pre><code class="language-typescript">function createResourceUri(relativePath: string): vscode.Uri {
  const absolutePath = path.join(vscode.workspace.rootPath, relativePath);
  return vscode.Uri.file(absolutePath);
}

const gitSCM = vscode.scm.createSourceControl('git', &quot;Git&quot;);

const index = gitSCM.createResourceGroup('index', &quot;Index&quot;);
index.resourceStates = [
  { resourceUri: createResourceUri('README.md') },
  { resourceUri: createResourceUri('src/test/api.ts') }
];

const workingTree = gitSCM.createResourceGroup('workingTree', &quot;Changes&quot;);
workingTree.resourceStates = [
  { resourceUri: createResourceUri('.travis.yml') },
  { resourceUri: createResourceUri('README.md') }
];
</code></pre>
<p>源变动和最终产生的资源组会传递到源控制视图上。</p>
<h2 id="源控制视图"><a class="header" href="#源控制视图">源控制视图</a></h2>
<hr />
<p>当源变动时，VS Code会生成源控制视图。源状态可通过<code>SourceControlResourceDecorations</code>自定义：</p>
<pre><code class="language-typescript">export interface SourceControlResourceState {
  readonly decorations?: SourceControlResourceDecorations;
}
</code></pre>
<p>上述例子已经足以让源控制视图生成一个简单的列表，不过用户可能想要在不同的资源状态上进行不同的操作。比如，当用户点击资源状态时，会发生什么呢？资源状态提供了一个可选命令去处理这类场景：</p>
<pre><code class="language-typescript">export interface SourceControlResourceState {
  readonly command?: Command;
}
</code></pre>
<h3 id="菜单-1"><a class="header" href="#菜单-1">菜单</a></h3>
<p>要想提供更加丰富的交互效果，我们提供了5个源控制菜单项供你使用。</p>
<p><code>scm/title</code>菜单在源控制视图的顶部右上方，菜单项水平排列在<code>标题栏</code>中，另外一些会在<code>...</code>下拉菜单中。</p>
<p><code>scm/resourceGroup/context</code>和<code>scm/resourceState/context</code>是类似的，你可以通过前者自定义资源组，后者则是定义资源状态。将菜单项放在<code>inline</code>组里，可以水平在视图中展示它们。而其他的菜单项可以通过鼠标右击的形式展示在菜单中。菜单中调用的命令会传入资源状态作为参数。注意SCM视图提供多选，因此命令函数可能一次性会接收一个或多个参数。</p>
<p>例如，Git支持往<code>scm/resourceState/context</code>菜单中添加<code>git.stage</code>命令和使用下列方法，提供多个文件的存备（staged）：</p>
<pre><code class="language-typescript">stage(...resourceStates: SourceControlResourceState[]): Promise&lt;void&gt;;
</code></pre>
<p>创建它们的时候，<code>SourceControl</code>和<code>SourceControlResourceGroup</code>实例会需要你提供一个string类型的<code>id</code>，这些值最终会在<code>scmProvider</code>和<code>scmResourceGroup</code>以上下文键值的形式出现。在菜单项的<code>when</code>语法中使用这些<a href="https://code.visualstudio.com/docs/getstarted/keybindings#_when-clause-contexts">上下文键值</a>。看个Git如何通过<code>git.stage</code>命令显示菜单项的：</p>
<pre><code class="language-json">{
  &quot;command&quot;: &quot;git.stage&quot;,
  &quot;when&quot;: &quot;scmProvider == git &amp;&amp; scmResourceGroup == merge&quot;,
  &quot;group&quot;: &quot;inline&quot;
}
</code></pre>
<p><code>scm/change/title</code>可以对<em>行内变动</em>配置标题栏的命令（contribute commands to the title bar of an inline change）。命令中的参数有文档的URI，变动数组，当前行内变动所在索引。例如下面是一个可以配置菜单的Git<code>stageChange</code>命令声明：</p>
<pre><code class="language-typescript">async stageChange(uri: Uri, changes: LineChange[], index: number): Promise&lt;void&gt;;
</code></pre>
<p><code>scm/sourceControl</code>菜单根据环境出现在源控制实例的边上。</p>
<p><img src="https://media.githubusercontent.com/media/Microsoft/vscode-docs/master/api/extension-guides/images/scm-provider/sourcecontrol-menu.png" alt="源控制菜单" /></p>
<p>最后，<code>scm/change/title</code>菜单是和快速Diff功能相关联的，越新的文件越靠前，你可以针对特定的代码变动调用命令。</p>
<h3 id="scm-输入框"><a class="header" href="#scm-输入框">SCM 输入框</a></h3>
<p>源控制输入框位于每个源控制视图的顶部，接收用户输入的信息。你可以获取（或设置）这个信息供后续使用。在Git中，比如说，这可以作为一个commit框，用户输入了提交信息后，触发<code>git commit</code>命令：</p>
<pre><code class="language-typescript">export interface SourceControlInputBox {
  value: string;
}

export interface SourceControl {
  readonly inputBox: SourceControlInputBox;
}
</code></pre>
<p>用户可以通过<kbd>Ctrl+Enter</kbd>（Mac上是<kbd>Cmd+Enter</kbd>）接收任意信息，在<code>SourceControl</code>中的<code>acceptInputCommand</code>处理这类事件。</p>
<pre><code class="language-typescript">export interface SourceControl {
  readonly acceptInputCommand?: Command;
}
</code></pre>
<h2 id="快速diff"><a class="header" href="#快速diff">快速Diff</a></h2>
<hr />
<p>VS Code支持显示<strong>快速Diff</strong>编辑器的高亮槽，点击这些槽会出现一个内部diff交互器，你可以在这里为上下文配置命令。</p>
<p><img src="https://media.githubusercontent.com/media/Microsoft/vscode-docs/master/api/extension-guides/images/scm-provider/quickdiff.png" alt="SCM快速Diff" /></p>
<p>这些高亮槽是VS Code自己计算出来的，你要做的就是根据给定的文件提供原始文件内容</p>
<pre><code class="language-typescript">export interface SourceControl {
  quickDiffProvider?: QuickDiffProvider;
}
</code></pre>
<p>使用<code>QuickDiffProvider</code>，你的实现需要告诉VS Code——参数传入的给定资源<code>Uri</code>所对应的原始资源<code>Uri</code>。</p>
<p>?&gt; <strong>提示</strong>: 如果你想在给定<code>Uri</code>的情况下，为任意资源提供内容，那么你可以把<strong>源控制API</strong>和**<a href="https://code.visualstudio.com/api/references/vscode-api#workspace">工作区命名空间的<code>registerTextDocumentContentProvider</code>方法</a>**结合起来使用。</p>
<h2 id="下一步-7"><a class="header" href="#下一步-7">下一步</a></h2>
<p>想要学习更多关于VS Code扩展性模型，请参考：</p>
<ul>
<li><a href="https://code.visualstudio.com/docs/extensionAPI/vscode-api#_scm">SCM API 参考</a> - 查看完整的SCM API文档</li>
<li><a href="https://github.com/Microsoft/vscode/tree/master/extensions/git">Git 插件</a> - 学习Git插件实现</li>
<li><a href="extension-guides//">插件API概览</a> - 学习全部的VS Code扩展性模型</li>
<li><a href="extension-guides//references/extension-manifest">插件配置清单</a> - VS Code package.json插件配置清单参考</li>
<li><a href="extension-guides//references/contribution-points">发布内容配置点</a> - VS Code发布内容配置点参考</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="调试器插件"><a class="header" href="#调试器插件">调试器插件</a></h1>
<p>VS Code已经内置了一套通用的用户界面，插件作者能够通过VS Code的调试架构轻松将已有的调试器整合进来。</p>
<p>VS Code已经内置了一个<a href="https://nodejs.org/">Node.js</a>调试器插件，它将成为你学习VS Code调试器特性的绝佳搭档。</p>
<p><img src="https://media.githubusercontent.com/media/Microsoft/vscode-docs/master/api/extension-guides/images/debugger-extension/debug-features.png" alt="VS Code调试功能" /></p>
<p>上面的截图展示了以下调试功能：</p>
<ol>
<li>管理调试器配置</li>
<li>开始、停止、步进等调试操作</li>
<li>源、函数、条件断点、行断点和记录点</li>
<li>支持多线程和多进程的调用栈</li>
<li>在<em>视图</em>中浏览复杂的数据，鼠标悬停在数据上可以看到更多信息</li>
<li>鼠标悬停在源代码中可以看到变量的值</li>
<li>管理watch表达式</li>
<li>调试控制台支持交互操作，如求值、自动补全等</li>
</ol>
<p>本节将帮你创建一个任意调试器都可以和VS Code协作的调试器插件。</p>
<h2 id="vs-code-中的调试架构"><a class="header" href="#vs-code-中的调试架构">VS Code 中的调试架构</a></h2>
<hr />
<p>VS Code基于抽象协议，实现了一个原生（非语言相关的）的调试器UI，它可以和任意后台调试程序通信。通常来讲，调试器不会实现这份协议，因此调试器中需要一些中间件去“适配”这个协议。这个中间件一般而言是一个独立和调试器通信的进程。</p>
<p><img src="https://media.githubusercontent.com/media/Microsoft/vscode-docs/master/api/extension-guides/images/debugger-extension/debug-arch1.png" alt="VS Code的调试架构" /></p>
<p>我们将这个中间件称为<strong>调试适配器（Debug Adapter）</strong>（简写为<strong>DA</strong>），在VS Code和DA之间通信的抽象协议称之为<strong>调试适配器协议(Debug Adapter Protocol)</strong> (简写<strong>DAP</strong>)。调试适配器协议独立于VS Code，它有自己的<a href="https://microsoft.github.io/debug-adapter-protocol/">网站</a>，你在上面可以找到相关的<a href="https://microsoft.github.io/debug-adapter-protocol/overview">介绍和概述</a>，以及详细的<a href="https://microsoft.github.io/debug-adapter-protocol/specification">说明书</a>，上面还列出了一些<a href="https://microsoft.github.io/debug-adapter-protocol/implementors/adapters/">已知实现和支持工具</a>，这份努力背后的故事和动机，我们都记录在了<a href="https://code.visualstudio.com/blogs/2018/08/07/debug-adapter-protocol-website#_why-the-need-for-decoupling-with-protocols">博客</a>中。</p>
<p>因为调试适配器独立于VSCode，所以它可用在<a href="https://microsoft.github.io/debug-adapter-protocol/implementors/tools/">其他开发工具</a>中，它们无需匹配VS Code的插件架构，而只需基于插件和<em>发布内容配置</em>即可。</p>
<p>出于这个原因，VS Code提供了一个配置点<code>debuggers</code>，调试适配器在这里可以配置特定的调试类型（例如：Node.js调试器使用<code>node</code>）。用户只要启动了这个类型的调试适配器会话，VS Code就能加载注册好的调试适配器。</p>
<p>因此调试适配器的最小形式就是声明一个配置，对应调试适配器的实现，这个插件就是调试适配器的装载容器，而且不需要任何多余的代码。</p>
<p><img src="https://media.githubusercontent.com/media/Microsoft/vscode-docs/master/api/extension-guides/images/debugger-extension/debug-arch2.png" alt="VS Code调试架构-2" /></p>
<p>一个更贴近现实的调试器插件往往会添加很多配置，如下面的：</p>
<ul>
<li>调试器支持的语言。VS Code会为这些语言启用UI界面的断点功能</li>
<li>由调试器引入的JSON格式的调试配置属性。VS Code会使用这个格式校验launch.json中的配置，并提供补全功能</li>
<li>首次加载调试时，VS Code自动生成初始launch.json文件</li>
<li>用户可以给launch.json添加的调试配置片段</li>
<li>声明调试配置中可以使用的变量</li>
</ul>
<p>想要了解更多相关内容，请查看<a href="extension-guides//extensibility-reference/contribution-points#contributesbreakpoints">contributes.breakpoints</a>和<a href="extension-guides//extensibility-reference/contribution-points#contributesdebuggers">contributes.debuggers</a>。</p>
<h2 id="模拟调试插件"><a class="header" href="#模拟调试插件">模拟调试插件</a></h2>
<hr />
<p>由于从头开始创建一个调试适配器太繁琐了，所以我们将从简单的DA(我们已经创建过的<strong>入门级调试适配器</strong>)开始。因为它不与真正的调试器进行通信，所以就叫它——<em>模拟调试</em>吧。</p>
<p><em>模拟调试</em>模拟了调试器功能，支持：</p>
<ul>
<li>单步调试</li>
<li>跳到下一个断点</li>
<li>断点</li>
<li>异常</li>
<li>访问变量</li>
</ul>
<p>在深入了解开发中的<em>模拟调试</em>之前，我们先去VS Code插件市场安装个<a href="https://marketplace.visualstudio.com/items?itemName=andreweinand.mock-debug">预构建版本</a>玩一玩，就像下面这样：</p>
<ul>
<li>打开VS Code的插件面板，输入&quot;mock&quot;并找到<strong>Mock Debug</strong>插件</li>
<li><strong>安装</strong>并<strong>重启</strong></li>
</ul>
<p>通过如下流程来启动<em>模拟调试</em>：</p>
<ul>
<li>新建一个空的文件夹<code>mock test</code>并在VS Code中打开</li>
<li>创建一个<code>readme.md</code>，在里面随便写点什么东西</li>
<li>切换到<strong>调试</strong>视图，点一下<strong>齿轮图标</strong></li>
<li>VS Code会让你选择一个&quot;环境&quot;，并将其作为默认的启动配置。这里选择&quot;Mock Debug&quot;。</li>
<li>点击绿色的<strong>开始</strong>按钮，然后开始调试</li>
</ul>
<p>至此，一个调试会话就开始了，你可以在<code>readme.md</code>文件中进行单步调试、打断点。如果某一行出现异常则会跳进该异常。</p>
<p><img src="https://media.githubusercontent.com/media/Microsoft/vscode-docs/master/api/extension-guides/images/debugger-extension/mock-debug.gif" alt="模拟运行调试工具" /></p>
<p>在使用<em>模拟调试</em>之前，我们建议你卸载掉<a href="https://marketplace.visualstudio.com/items?itemName=andreweinand.mock-debug">预构建版本</a>：</p>
<ul>
<li>切换到Extensions视图，然后单击<em>模拟调试</em>插件的齿轮图标</li>
<li>卸载该插件并重启VS Code</li>
</ul>
<h2 id="开发环境配置模拟调试"><a class="header" href="#开发环境配置模拟调试">开发环境配置模拟调试</a></h2>
<hr />
<p>现在让我们下载Mock Debug的源码，然后用VS Code进行开发吧：</p>
<pre><code class="language-bash">git clone https://github.com/Microsoft/vscode-mock-debug.git
cd vscode-mock-debug
npm install
</code></pre>
<p>用VS Code打开<code>vscode-mock-debug</code>项目</p>
<p>我们的项目里面有什么呢？</p>
<ul>
<li><code>package.json</code>是mock-debug插件的配置清单：
<ul>
<li>里面是mock-debug插件的<em>发布内容配置</em>清单</li>
<li><code>compile</code>和<code>watch</code>脚本会将Typescript源码编译到<code>out</code>文件夹中，然后<code>watch</code>脚本会追踪源码每个细微的修改</li>
<li><code>vscode-debugprotocol</code>，<code>vscode-debugadapter</code>和<code>vscode-debugadapter-testsupport</code>npm依赖包简化了基于node的调试适配器开发工作</li>
</ul>
</li>
<li><code>src/mockRuntime.ts</code>是一个<strong>模拟的</strong>运行时，仅仅包含一些简单的调试API</li>
<li><code>src/mockDebug.ts</code>是我们的主要代码，是它将<em>运行时</em>适配到<strong>调试适配器</strong>上。你可以在里面找到各种处理DAP请求的方式。</li>
<li>调试插件实现于调试适配器，所以你可以完全不使用创建普通插件的代码（比如：原来插件的代码运行在扩展主机环境中），但是mock-debug还是有个小小的<code>src/extension.ts</code>，这份代码里面阐释了调试器插件中<em>插件</em>部分的代码可以做些什么。</li>
</ul>
<p>现在构建项目，然后加载Mock Debug插件。选择<strong>调试侧边栏</strong>，加载 <strong>Extension</strong> 配置，然后按下<code>F5</code>。接下来，会启动插件的Typescript编译工作，将转换后的代码输出到<code>out</code>文件夹中，然后进行全量编译，再接着，<em>watcher</em>任务会启动以便侦听你的改动。</p>
<p>代码编译完成后，带有&quot;[Extension Development Host]&quot;（中文环境下是&quot;[扩展开发主机]&quot;）VS Code新窗口会自动打开，Mock Debug插件就运行在调试模式中了。在这个窗口中，打开<code>mock test</code>项目，打开里面的<code>readme.md</code>，然后直接按下<kbd>F5</kbd>启动调试会话，现在你就可以调试了！</p>
<p><img src="https://media.githubusercontent.com/media/Microsoft/vscode-docs/master/api/extension-guides/images/debugger-extension/debug-mock-session.png" alt="模拟调试会话" /></p>
<p>因为的你插件运行在 <em>调试模式</em> 中，所以你能在<code>src/extension.ts</code>里面打断点，不过就如上文所说，这个插件关于<em>插件</em>本身的代码是没有多少的，最有意思的代码运行在调试适配器里，它是一个独立的进程。</p>
<p>要想调试调试适配器本身，我们需要把它运行在调试模式里。最简单的办法就是将调试适配器以<em>服务器模式</em>运行，然后配置VS Code去连接它。在你的vscode-mock-debug项目中，重新在打开的调试侧边栏的配置下拉菜单中选择<em>Server</em>配置，按下旁边的绿色开始按钮。</p>
<p>因为我们已经启动了一个调试会话，所以VS Code 调试器UI现在会进入 <em>多会话</em> 模式，在**调用栈（CALL STACK）**视图中你现在可以看到2个调试会话—— <strong>Extension</strong> 和 <strong>Server</strong> 。</p>
<p><img src="https://media.githubusercontent.com/media/Microsoft/vscode-docs/master/api/extension-guides/images/debugger-extension/debugger-extension-server.png" alt="调试插件和服务器" /></p>
<p>现在我们可以同时调试插件和DA（调试适配器）了。到我们目前这一步还有个更快的方式，启动调试时选择<strong>Extension + Server</strong>配置就会自动加载这两个会话。</p>
<p>另外，调试插件和调试适配器更简单的方式会在<a href="extension-guides/debugger-extension.html#%E5%BC%80%E5%8F%91%E8%B0%83%E8%AF%95%E5%99%A8%E6%8F%92%E4%BB%B6%E7%9A%84%E5%85%B6%E4%BB%96%E6%96%B9%E5%BC%8F">下面</a>说明。</p>
<p>在<code>src/mockDebug.ts</code>中的<code>launchRequest(...)</code>最开始的地方打上断点，然后最后一步则是在你的mock test启动配置中添加<code>debugServer</code>属性和对应的端口值<code>4711</code>就完成了调试器和调试适配器的连接。</p>
<pre><code class="language-json">{
	&quot;version&quot;: &quot;0.2.0&quot;,
	&quot;configurations&quot;: [
		{
			&quot;type&quot;: &quot;mock&quot;,
			&quot;request&quot;: &quot;launch&quot;,
			&quot;name&quot;: &quot;mock test&quot;,
			&quot;program&quot;: &quot;${workspaceFolder}/readme.md&quot;,
			&quot;stopOnEntry&quot;: true,
			&quot;debugServer&quot;: 4711
		}
	]
}
</code></pre>
<p>如果你现在就加载这个调试配置，调试适配器不会以分离的进程启动，而是直接连接到已经存在的本地服务器端口4711上。现在你可以在<code>launchRequest</code>打断点了。</p>
<p>经过这样一连串的配置，你终于可以轻松地编辑、编译和调试Mock Debug插件了。</p>
<p>但是好戏才刚刚开始：你需要替换<code>src/mockDebug.ts</code>和<code>src/mockRuntime.ts</code>的中的调试适配器代码，让它可以和“真正的”调试器或者运行时通信。这项工作涉及到理解和实现调试适配器协议。</p>
<p>更多内容请查看<a href="https://microsoft.github.io/debug-adapter-protocol/overview#How_it_works">这里</a>。</p>
<h2 id="剖析调试器插件的packagejson"><a class="header" href="#剖析调试器插件的packagejson">剖析调试器插件的package.json</a></h2>
<hr />
<p>除了提供调试适配的特定实现之外，调试器插件还需要一个配置各种各样和调试相关的<code>package.json</code>。</p>
<p>所以下面我们进一步看看Mock Debug的<code>package.json</code>.</p>
<p>就像一般的VS Code插件，<code>package.json</code>声明了一些基础信息，如插件的<strong>name</strong> ，<strong>publisher</strong>，<strong>version</strong>等。其中配置<strong>categories</strong>字段可以让你的插件更容易在插件市场中被其他人发现。</p>
<pre><code class="language-json">{
	&quot;name&quot;: &quot;mock-debug&quot;,
	&quot;displayName&quot;: &quot;Mock Debug&quot;,
	&quot;version&quot;: &quot;0.24.0&quot;,
	&quot;publisher&quot;: &quot;...&quot;,
	&quot;description&quot;: &quot;Starter extension for developing debug adapters for VS Code.&quot;,
	&quot;author&quot;: {
		&quot;name&quot;: &quot;...&quot;,
		&quot;email&quot;: &quot;...&quot;
	},
	&quot;engines&quot;: {
		&quot;vscode&quot;: &quot;^1.17.0&quot;,
		&quot;node&quot;: &quot;^7.9.0&quot;
	},
	&quot;icon&quot;: &quot;images/mock-debug-icon.png&quot;,
	&quot;categories&quot;: [&quot;Debuggers&quot;],

	&quot;contributes&quot;: {
		&quot;breakpoints&quot;: [{ &quot;language&quot;: &quot;markdown&quot; }],
		&quot;debuggers&quot;: [
			{
				&quot;type&quot;: &quot;mock&quot;,
				&quot;label&quot;: &quot;Mock Debug&quot;,

				&quot;program&quot;: &quot;./out/mockDebug.js&quot;,
				&quot;runtime&quot;: &quot;node&quot;,

				&quot;configurationAttributes&quot;: {
					&quot;launch&quot;: {
						&quot;required&quot;: [&quot;program&quot;],
						&quot;properties&quot;: {
							&quot;program&quot;: {
								&quot;type&quot;: &quot;string&quot;,
								&quot;description&quot;: &quot;Absolute path to a text file.&quot;,
								&quot;default&quot;: &quot;${workspaceFolder}/${command:AskForProgramName}&quot;
							},
							&quot;stopOnEntry&quot;: {
								&quot;type&quot;: &quot;boolean&quot;,
								&quot;description&quot;: &quot;Automatically stop after launch.&quot;,
								&quot;default&quot;: true
							}
						}
					}
				},

				&quot;initialConfigurations&quot;: [
					{
						&quot;type&quot;: &quot;mock&quot;,
						&quot;request&quot;: &quot;launch&quot;,
						&quot;name&quot;: &quot;Ask for file name&quot;,
						&quot;program&quot;: &quot;${workspaceFolder}/${command:AskForProgramName}&quot;,
						&quot;stopOnEntry&quot;: true
					}
				],

				&quot;configurationSnippets&quot;: [
					{
						&quot;label&quot;: &quot;Mock Debug: Launch&quot;,
						&quot;description&quot;: &quot;A new configuration for launching a mock debug program&quot;,
						&quot;body&quot;: {
							&quot;type&quot;: &quot;mock&quot;,
							&quot;request&quot;: &quot;launch&quot;,
							&quot;name&quot;: &quot;${2:Launch Program}&quot;,
							&quot;program&quot;: &quot;^\&quot;\\${workspaceFolder}/${1:Program}\&quot;&quot;
						}
					}
				],

				&quot;variables&quot;: {
					&quot;AskForProgramName&quot;: &quot;extension.mock-debug.getProgramName&quot;
				}
			}
		]
	},

	&quot;activationEvents&quot;: [&quot;onDebug&quot;, &quot;onCommand:extension.mock-debug.getProgramName&quot;]
}
</code></pre>
<p>现在我们来看看调试器插件中的<code>contributes</code>部分。</p>
<p>首先，<strong>breakpoints</strong>配置部分列出了可以使用断点的语言列表，没有这个配置的话，就不可能在 Markdown文件中设置断点了。</p>
<p>接下来是<strong>debuggers</strong>部分，这里引入了一个类型是<code>mock</code>的调试器，用户可以在调试器加载配置中引用这个类型。可选属性<strong>label</strong>是这个调试器的名字，它会显示在UI上。</p>
<p>因为调试器插件使用了调试适配器，所以它的的关联路径得通过<strong>program</strong>属性配置。为了保证插件的自包含性（self-contained），这个应用必须在我们的插件文件夹中。按惯例，我们将这个应用放在<code>out</code>或者<code>bin</code>中，当然你也可以使用其他名称的文件夹存放。</p>
<p>因为VS Code运行在不同的平台上，我们需要确保DA程序也能够支持不同的平台。对于这点，我们提供了下列选项：</p>
<ol>
<li>如果程序在平台上的实现都是各自独立的，比如：这个程序的运行时支持所有平台，你可以在<strong>runtime</strong>属性中指明。
到目前为止，VS Code支持<code>node</code>和<code>moni</code>运行时，我们的Mock Debug就使用了这个方式。</li>
<li>如果你的DA在不同的平台上对应着不同的可执行程序，那么你可以这样使用<strong>program</strong>属性：</li>
</ol>
<pre><code class="language-json">&quot;debuggers&quot;: [{
    &quot;type&quot;: &quot;gdb&quot;,
    &quot;windows&quot;: {
        &quot;program&quot;: &quot;./bin/gdbDebug.exe&quot;,
    },
    &quot;osx&quot;: {
        &quot;program&quot;: &quot;./bin/gdbDebug.sh&quot;,
    },
    &quot;linux&quot;: {
        &quot;program&quot;: &quot;./bin/gdbDebug.sh&quot;,
    }
}]
</code></pre>
<ol start="3">
<li>组合上面两种方式也是可以的。下面的例子实现了在macOS和Linux上使用同一个mono应用，但是Windows上就不是。</li>
</ol>
<pre><code class="language-json">&quot;debuggers&quot;: [{
    &quot;type&quot;: &quot;mono&quot;,
    &quot;program&quot;: &quot;./bin/monoDebug.exe&quot;,
    &quot;osx&quot;: {
        &quot;runtime&quot;: &quot;mono&quot;
    },
    &quot;linux&quot;: {
        &quot;runtime&quot;: &quot;mono&quot;
    }
}]
</code></pre>
<p><strong>configurationAttributes</strong>声明了这个调试器的<code>launch.json</code>中的属性可以使用的协议。这个协议用于校验<code>launch.json</code>，同时支持编辑加载配置时的智能补全和悬停帮助。</p>
<p><strong>initialConfigurations</strong>定义了这个调试器的初始<code>launch.json</code>。当一个项目没有<code>launch.json</code>，然后用户打开了调试会话时，就会使用这个启动配置。然后VS Code会让用户选择一个调试环境，接着再创建对应的<code>launch.json</code>：</p>
<p><img src="https://media.githubusercontent.com/media/Microsoft/vscode-docs/master/api/extension-guides/images/debugger-extension/debug-init-config.png" alt="调试速选框" /></p>
<p>除了在<code>package.json</code>中静态定义<code>launch.json</code>的初始内容，你还可以使用<code>DebugConfigurationProvider</code>动态注入初始配置内容（详情见下<a href="extension-guides/debugger-extension.html#%E4%BD%BF%E7%94%A8DebugConfigurationProvider">使用DebugConfigurationProvider</a>）。</p>
<p><strong>configurationSnippets</strong>定义了编辑<code>launch.json</code>会为用户呈现的代码补全提示。同样，按约定<code>label</code>属性定义了调试环境的名称，所以当大量补全提示出现的时候，用户才能一眼认出自己想要的那个。</p>
<p><strong>variables</strong>配置，将“变量”绑定到了“命令”上。这些变量会出现在加载配置（launch.json）中，用法是**${command:xyz}**，调试会话启动后，其中的值会被命令中的返回值替换。</p>
<p><em>命令</em>实现在插件（而不是调试适配器）中，它可以由一句简单的表达式实现，也可以复杂到基于插件API和UI特性实现。Mock Debug将变量<code>AskForProgramName</code>绑定到了命令<code>extension.mock-debug.getProgramName</code>，这个命令的<a href="https://github.com/Microsoft/vscode-mock-debug/blob/606454ff3bd669867a38d9b2dc7b348d324a3f6b/src/extension.ts#L21-L26">实现</a>在<code>src/extension.ts</code>中，代码中的<code>showInputBox</code>允许用户为程序命名：</p>
<pre><code class="language-typescript">vscode.commands.registerCommand('extension.mock-debug.getProgramName', config =&gt; {
	return vscode.window.showInputBox({
		placeHolder: 'Please enter the name of a markdown file in the workspace folder',
		value: 'readme.md'
	});
});
</code></pre>
<p>现在加载配置（launch.json）中可以使用**${command:AskForProgramName}**中的值（文本类型）了。</p>
<h2 id="使用debugconfigurationprovider"><a class="header" href="#使用debugconfigurationprovider">使用DebugConfigurationProvider</a></h2>
<hr />
<p>如果你觉得<code>package.json</code>中和调试相关的发布内容配置不够你用，<code>DebugConfigurationProvider</code>可以动态控制调试插件下列方面的内容：</p>
<ul>
<li>动态生成launch.json中的配置。比如：根据工作区的信息生成一些配置。</li>
<li>在启动新的调试会话前，解析（或修改）加载配置。有了这个功能，你可以根据工作区的不同填入对应的配置默认值。</li>
</ul>
<p><code>src/extension.ts</code>中的<code>MockConfigurationProvider</code>实现了<code>resolveDebugConfiguration</code>，它会检测调试会话启动时是不是还没有launch.json文件，而且Markdown文件已经打开了。这种场景非常常见，用户已经打开了文件，他想要立刻启动调试而且不想要搞任何配置。</p>
<p>通过<code>vscode.debug.registerDebugConfigurationProvider</code>注册<em>调试配置供应器函数</em>，它一般在插件的<code>active</code>函数中。<code>DebugConfigurationProvider</code>需要尽早注册，一旦调试功能被使用到了，插件就应该启动。我们通过<code>package.json</code>中的<code>onDebug</code>事件轻松搞定这个需求：</p>
<pre><code class="language-json">&quot;activationEvents&quot;: [
    &quot;onDebug&quot;,
    // ...
],
</code></pre>
<p>在低开销的插件启动时（启动时不会花太多时间），这个机制会如预期工作。但是如果插件的启动开销较大（比如启动一个语言服务器），那么<code>onDebug</code>事件可能会对其他调试插件产生副作用，因为<code>onDebug</code>事件已经激活了其他插件，但是其他插件因为阻塞还来不及接收到具体的调试类型。</p>
<p>对于高开销的调试插件来说，更好的方法就是使用粒度更细的 激活事件：</p>
<ul>
<li><code>onDebugInitialConfigurations</code>会在<code>DebugConfigurationProvider</code>的<code>provideDebugConfigurations</code>调用前触发</li>
<li><code>onDebugResolve:type</code>会在<code>DebugConfigurationProvider</code>的<code>resolveDebugConfiguration</code>取得具体的调试类型前触发</li>
</ul>
<p>!&gt; **首要原则：**如果调试插件的开销很小，就用<code>onDebug</code>，根据<code>DebugConfigurationProvider</code>是否实现了<code>provideDebugConfigurations</code>或<code>resolveDebugConfiguration</code>，然后在对应的<code>onDebugInitialConfigurations</code>或者<code>onDebugResolve</code>中处理。</p>
<h2 id="发布调试器插件"><a class="header" href="#发布调试器插件">发布调试器插件</a></h2>
<hr />
<p>通过下面的步骤将你的调试适配器发布到市场上：</p>
<ul>
<li>更新<code>package.json</code>中的发布配置内容表明你调试适配器的功能和目标</li>
<li>参考<a href="extension-guides//working-with-extensions/publish-extension">发布插件</a>部分然后将你的插件上传到市场上</li>
</ul>
<h2 id="开发调试器插件的其他方式"><a class="header" href="#开发调试器插件的其他方式">开发调试器插件的其他方式</a></h2>
<hr />
<p>如我们所见，开发一个调试插件涉及到<em>一个普通插件</em>再加上一个调试适配器，它们分别运行在不同的会话中。VS Code支持这样的实现，但是简单的办法是还是把<em>插件</em>和调试适配器用一个程序实现，这样你就可以在一个调试会话中同时调试了。</p>
<p>实际上，只要你的调试适配器是基于Typescript/Javascript实现的，这个方法就都是可行的。基本的思路是把调试适配器实现为一个服务器，让<em>插件</em>去启动这个服务，再让VS Code连接上去，这样你就不用每个调试会话都启动一个新的调试适配器了。</p>
<p>Mock Debug的例子阐述了一个<a href="https://github.com/Microsoft/vscode-mock-debug/blob/6a2ef01b95bb22cdf55683f4d616cad501051510/src/extension.ts#L74-L98">DebugAdapterDescriptorFactory</a>可以怎样创建和<a href="https://github.com/Microsoft/vscode-mock-debug/blob/6a2ef01b95bb22cdf55683f4d616cad501051510/src/extension.ts#L32-L36">注册</a>一个基于服务器的调试适配器。通过将编译时的<a href="https://github.com/Microsoft/vscode-mock-debug/blob/6a2ef01b95bb22cdf55683f4d616cad501051510/src/extension.ts#L17"><code>EMBED_DEBUG_ADAPTER</code></a>配置设置为true启用这个特性。现在如果你用<strong>F5</strong>启动调试，你就不仅仅是在插件开发主机中打了断点，你也同时在调试适配器中打了同样的断点。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="markdown插件"><a class="header" href="#markdown插件">Markdown插件</a></h1>
<p>Markdown插件可以帮你扩展和加强VS Code内置的Markdown预览，包括改变预览的样式、添加新的Markdown语法。</p>
<h2 id="用css改变markdown预览样式"><a class="header" href="#用css改变markdown预览样式">用CSS改变Markdown预览样式</a></h2>
<hr />
<p>配置CSS可以改变markdown预览的布局和样式，在你的插件<code>pacakge.json</code>中注册<code>markdown.previewStyles</code><a href="extension-guides//references/contribution-points">发布内容配置</a>即可：</p>
<pre><code class="language-json">&quot;contributes&quot;: {
    &quot;markdown.previewStyles&quot;: [
        &quot;./style.css&quot;
    ]
}
</code></pre>
<p><code>markdown.previewStyles</code>类型是插件根目录下的文件列表。</p>
<p>配置的样式会在用户的<code>&quot;markdown.styles&quot;</code>之前，内置Markdown预览样式之后加载。</p>
<p><a href="https://marketplace.visualstudio.com/items?itemName=bierner.markdown-preview-github-styles">Markdown Preview GitHub Styling</a>是一个如何将Markdown预览变成像GitHub渲染风格的好例子，在GitHub上去查看<a href="https://github.com/mjbvz/vscode-github-markdown-preview-style">源码</a>吧</p>
<h2 id="使用markdown-it插件添加新语法"><a class="header" href="#使用markdown-it插件添加新语法">使用markdown-it插件添加新语法</a></h2>
<hr />
<p>VS Code Markdown预览支持<a href="https://spec.commonmark.org/">CommonMark规格</a>，插件可以通过一个<a href="https://github.com/markdown-it/markdown-it#syntax-extensions">markdown-it插件</a>添加新的Markdown语法。</p>
<p>首先，在你的插件<code>package.json</code>中配置<code>&quot;markdown.markdownItPlugins&quot;</code>：</p>
<pre><code class="language-json">&quot;contributes&quot;: {
    &quot;markdown.markdownItPlugins&quot;: true
}
</code></pre>
<p>然后在插件的主<code>activation</code>函数中，返回一个包含名<code>extendMarkdownIt</code>函数的对象。这个函数接收一个markdown-it实例，然后必须返回出新的markdown-it实例：</p>
<pre><code class="language-typescript">import * as vscode from 'vscode'

export function activate(context: vscode.ExtensionContext) {
    return {
        extendMarkdownIt(md: any) {
            return md.use(require('markdown-it-emoji'));
        }
    }
}
</code></pre>
<p>若想配置多个markdown-it插件，只需多次链式调用<code>use</code>声明即可。</p>
<pre><code class="language-typescript">return md.use(require('markdown-it-emoji')).use(require('markdown-it-hashtag'));
</code></pre>
<p>Markdown预览第一次显示时，配置了markdown-it的插件会变成懒加载激活。</p>
<p><a href="https://marketplace.visualstudio.com/items?itemName=bierner.markdown-emoji">markdown-emoji</a>插件展示了如何使用markdown-it添加emoji支持，你可以在GitHub上查看Emoji插件的<a href="https://github.com/mjbvz/vscode-markdown-emoji">源码</a>。</p>
<p>你可能还想了解：</p>
<ul>
<li>markdown-it插件开发者<a href="https://github.com/markdown-it/markdown-it/blob/master/docs/development.md">指南</a></li>
<li><a href="https://www.npmjs.com/browse/keyword/markdown-it-plugin">现成的markdown-it插件</a></li>
</ul>
<h2 id="用脚本添加进阶功能"><a class="header" href="#用脚本添加进阶功能">用脚本添加进阶功能</a></h2>
<hr />
<p>对于进阶特性，在插件中配置可运行的脚本：</p>
<pre><code class="language-json">&quot;contributes&quot;: {
    &quot;markdown.previewScripts&quot;: [
        &quot;./main.js&quot;
    ]
}
</code></pre>
<p>配置的脚本是异步加载的，每次内容变动还会重载。</p>
<p><a href="https://marketplace.visualstudio.com/items?itemName=bierner.markdown-mermaid">Markdown Preview Mermaid Support</a>插件展示了如何使用脚本添加<a href="https://knsv.github.io/mermaid/index.html">鱼骨图</a>和流程图预览。在<a href="https://github.com/mjbvz/vscode-markdown-mermaid">这里</a>查看插件源码。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="自定义编辑器-api"><a class="header" href="#自定义编辑器-api">自定义编辑器 API</a></h1>
<hr />
<p>自定义编辑器允许开发者创建完全定制化的可读写编辑器，它可以替代 VS Code 中标准的文本编辑器，编辑一些特殊类型的资源。比如说：</p>
<ul>
<li>预览资产(assests)文件，如直接在 VS Code 中查看3D 模型着色器</li>
<li>创建 WYSIWYG 编辑器，如 Markdown 或者 XAML</li>
<li>为 CSV、JSON或 XML 提供其他视觉渲染</li>
<li>为二进制文件或文本文件提供完全定制化的编辑体验</li>
</ul>
<p>本章我们将大致看下自定义编辑器的 API，并实现一个基本的自定义编辑器。我们还会看一眼自定义编辑器的两种类型以及他们的差别，你应该如何选择合适的编辑器。然后我们会走一遍基本的实现。</p>
<p>虽然自定义编辑器是个非常强力的新功能，但实现一个基本的自定义编辑器真没那么难！不过，如果你目前还在做 VS Code 上的第一个插件，你可能需要考虑一下等到自己足够熟悉 VS Code API 的基本内容之后，再深入到编辑器开发中来。自定义编辑器立足于非常多的 VS Code 概念之上——包括 <a href="extension-guides//extension-guides/webview">webviews</a> 和文本文档 —— 所以如果你同时在本章接受这些概念的话，压力就会有些大了。</p>
<p>不过，如果你觉得自己已经准备好构建一个很酷的自定义编辑器了，那么就让我们开始吧！确保你已经下载了 <a href="https://github.com/microsoft/vscode-extension-samples/tree/master/custom-editor-sample">自定义编辑器 示例</a>，我们的教程将跟随这个示例和文档逐步介绍自定义编辑器的相关 API。</p>
<h2 id="链接"><a class="header" href="#链接">链接</a></h2>
<hr />
<p><a href="https://github.com/microsoft/vscode-extension-samples/tree/master/custom-editor-sample">自定义编辑器 示例</a></p>
<h4 id="vs-code-api-用法"><a class="header" href="#vs-code-api-用法">VS Code API 用法</a></h4>
<ul>
<li><a href="https://code.visualstudio.com/api/references/vscode-api#window.registerCustomEditorProvider"><code>window.registerCustomEditorProvider</code></a></li>
<li><a href="https://code.visualstudio.com/api/references/vscode-api#CustomTextEditorProvider"><code>CustomTextEditorProvider</code></a></li>
</ul>
<h2 id="本-api-的基础"><a class="header" href="#本-api-的基础">本 API 的基础</a></h2>
<hr />
<p>自定义编辑器是特定类型资源文件的编辑视图，它会替换 VS Code 中的标准文本编辑器展示的位置。自定义编辑器分为两部分：用户可交互的<strong>视图</strong>和你的插件与底层资源文件进行交互的<strong>文档模型</strong>。</p>
<p>自定义编辑器的视图侧是通过 <a href="extension-guides//extension-guides/webview">webviews</a> 实现的，所以你可以通过标准的 HTML、CSS 和 JavaScript 构建用户体验。Webview 是不能直接访问 VS Code API 的，但是它可以通过插件进行双向通信。看看我们的 <a href="extension-guides//extension-guides/webview">webview 文档</a>，获取关于 webview 的最佳实践。</p>
<p>自定义编辑器的另外一部分是文档模型。这个模型是你的插件如何理解源（文件）以及如何相互工作的抽象。<code>CustomTextEditorProvider</code> 使用标准的 VS Code <a href="https://code.visualstudio.com/api/references/vscode-api#TextDocument">TextDocument</a>，它的文档模型和文件的所有变化都会被表达为 VS Code 中的标准文本编辑 API。<code>CustomReadonlyEditorProvider</code> 和 <code>CustomEditorProvider</code> 则需要你自己提供文档模型，所以你就拥有了非文本格式的文档编辑能力。</p>
<p>自定义编辑器对应的每个资源文件可能各需要一个文档模型，但有的时候多个编辑器实例（视图）可能会共用一个文档模型。比如，你可以想象一下你打开的文件包含了一个<code>CustomTextEditorProvider</code>，然后你运行了<strong>视图：拆分编辑器</strong>命令，这样一来，虽然<code>TextDocument</code>只有一个，因为另外一个视图中的内容只是源文件的一个副本，但是现在这个资源文件产生了两个 webview 视图。</p>
<h3 id="customeditor-vs-customtexteditor"><a class="header" href="#customeditor-vs-customtexteditor"><code>CustomEditor</code> vs <code>CustomTextEditor</code></a></h3>
<p>我们有两种自定义编辑器类型：自定义文本编辑器和自定义编辑器。两者的主要区别在于他们定义文档模型不同。</p>
<p><code>CustomTextEditorProvider</code> 使用 VS Code 标准的 <a href="https://code.visualstudio.com/api/references/vscode-api#TextDocument"><code>TextDocument</code></a> 作为数据模型。你可以对任意文本格式类型文件使用 <code>CustomTextEditor</code>。<code>CustomTextEditor</code> 相对另一种来说比较容易实现，因为 VS Code 已经知道怎么处理文本文件，以及实现了对应的操作，如保存、热退出文件恢复等。</p>
<p>而 <code>CustomEditorProvider</code> 有所不同，你的插件需要自己准备文档模型。这就意味着你可以把 <code>CustomEditor</code> 使用到二进制文件格式上，比如图片。但这也意味着你的插件的责任也很大，比如实现保存和备份。如果你的编辑器是只读的，你也可以跳过这些繁琐的功能，比如预览。</p>
<p>决定使用哪种类型的自定义编辑器很简单：如果你要处理文本格式的文件，使用<code>CustomTextEditorProvider</code>，二进制文件则使用<code>CustomEditorProvider</code>。</p>
<h3 id="发布内容配置"><a class="header" href="#发布内容配置">发布内容配置</a></h3>
<p><code>customEditors</code> 的<a href="extension-guides//references/contribution-points">发布内容配置</a> 配置了你的自定义插件何时在VS Code 中运行，VS Code 需要知道你的自定义编辑器是处理哪类文件的，以及编辑器的 ID。</p>
<p>下面是<a href="https://github.com/microsoft/vscode-extension-samples/tree/master/custom-editor-sample">自定义编辑器 示例</a>中 <code>customEditor</code> 的基本配置：</p>
<pre><code class="language-json">&quot;contributes&quot;: {
  &quot;customEditors&quot;: [
    {
      &quot;viewType&quot;: &quot;catEdit.catScratch&quot;,
      &quot;displayName&quot;: &quot;Cat Scratch&quot;,
      &quot;selector&quot;: [
        {
          &quot;filenamePattern&quot;: &quot;*.cscratch&quot;
        }
      ],
      &quot;priority&quot;: &quot;default&quot;
    }
  ]
}
</code></pre>
<p><code>customEditors</code> 是一个数组，所以你的插件可以配置多个自定义编辑器。让我们分别看看自定义编辑器的配置：</p>
<ul>
<li><code>viewType</code> - 自定义编辑器的唯一标识。这个字段告诉 VS Code 将你在 <code>package.json</code> 配置自定义编辑器绑定到代码实现中去。这个字段的值必须是唯一的，不要使用<code>&quot;viewType&quot;</code>的原生值，比如<code>&quot;preview&quot;</code>，你需要确保这个字段的值，和商店市场的所有插件的名字都没有重复，比如<code>&quot;viewType&quot;: &quot;myAmazingExtension.svgPreview&quot;</code></li>
<li><code>displayName</code> - 展示在 VS Code UI 中的编辑器名称。这个名称会显示在 VS Code 的 UI 中，比如下拉命令行的<strong>视图：使用...打开</strong>中</li>
<li><code>selector</code> - 确定哪类文件会激活自定义编辑器。<code>selector</code> 是一个或者多个 glob模式的数组。glob 模式会匹配文件的名称，文件匹配时则打开自定义编辑器。 比如 <code>文件名模式</code> 的一种模式 <code>*.png</code> 会触发所有 PNG 文件打开我们的自定义编辑器。你也可以创建更多的模式，匹配文件名，或者目录名，比如<code>**/translations/*.json</code></li>
<li><code>priority</code> - （可选）确定自定义编辑器的使用时机。这个字段控制合适使用特定的自定义编辑器。可选值有：
<ul>
<li><code>&quot;default&quot;</code> - 尝试对每个匹配<code>selector</code>的文件使用自定义编辑器。如果一个文件配置了多种自定义编辑器，用户需要选择使用哪个编辑器。</li>
<li><code>&quot;option&quot;</code> - 默认不使用自定义编辑器，不过用户可以将该类文件进行配置，用自定义编辑器打开</li>
</ul>
</li>
</ul>
<h3 id="自定义编辑器的激活"><a class="header" href="#自定义编辑器的激活">自定义编辑器的激活</a></h3>
<p>当用户打开了一个自定义编辑器，VS Code 会触发 <code>onCustomEditor:VIEW_TYPE</code> 激活事件。激活期间，你的插件必须调用 <code>registerCustomEditorProvider</code> 注册一个与预期 <code>viewType</code> 一致的自定义编辑器。</p>
<p>你一定要记住 <code>onCustomEditor</code> 只会在 VS Code 需要创建自定义编辑器实例的时候才会调用，如果 VS Code 只是展示自定义编辑器的一些信息，比如<strong>视图：使用...重新打开</strong>命令——你的插件不会被激活。</p>
<h2 id="自定义文本编辑器"><a class="header" href="#自定义文本编辑器">自定义文本编辑器</a></h2>
<hr />
<p>在自定义文本编辑器中，你可以控制文本文件的编辑功能。这类文件可以是纯文本文件、<a href="https://en.wikipedia.org/wiki/Comma-separated_values">CSV</a>、JSON 或者 XML。自定义文本编辑器使用 VS Code 标准 <a href="https://code.visualstudio.com/api/references/vscode-api#TextDocument">TextDocument</a> 作为文档模型。</p>
<p><a href="https://github.com/microsoft/vscode-extension-samples/tree/master/custom-editor-sample">自定义编辑器插件示例</a>包含了一个简单的自定义文本编辑器示例，这个示例支持 <em>猫猫草稿文件</em>（其实就是以<code>.cscratch</code> 后缀结尾的JSON文件）。VS Code 会在以下场景中自动调用你的插件——发现需要创建一个新的自定义编辑器示例时，当用户关闭标签——清理编辑器实例和文档模型时。</p>
<p>我们从用户打开自定义文本编辑器，插件进行视图配置开始，到用户关闭自定义文本编辑器，一步步深入到自定义编辑器的实际运作原理。</p>
<h3 id="自定义文本编辑器的生命周期"><a class="header" href="#自定义文本编辑器的生命周期">自定义文本编辑器的生命周期</a></h3>
<p>VS Code 处理自定义文本编辑器视图（webview）的视图组件生命周期和模型组件（<code>TextDocument</code>）的生命周期。VS Code 创建新的自定义编辑器实例会调用你的插件，或者用户关闭标签时，清理编辑器实例的时候会调用你的插件。</p>
<p>要在实践中理解这里面的工作机制，让我们从插件的视角看看用户打开/关闭一个自定义文本编辑器时，发生了什么：</p>
<h4 id="打开自定义文本编辑器"><a class="header" href="#打开自定义文本编辑器">打开自定义文本编辑器</a></h4>
<p>本示例使用<a href="https://github.com/microsoft/vscode-extension-samples/tree/master/custom-editor-sample">自定义编辑器插件示例</a>，下面是用户首次打开<code>.cscratch</code>文件的过程：</p>
<ol>
<li>VS Code 触发<code>onCustomEditor:catCustoms.catScratch</code>激活事件。如果我们的插件还未被激活，此时就会激活插件。在激活期间，我们的插件必须通过 <code>registerCustomEditorProvider</code> 为 <code>catCustoms.catScratch</code> 注册 <code>CustomTextEditorProvider</code>。</li>
<li>VS Code 然后会为已注册<code>CustomTextEditorProvider</code>的<code>catCustoms.catScratch</code> 调用 <code>resolveCustomTextEditor</code>。这个方法会获取当前打开资源的<code>TextDocument</code>以及<code>WebviewPanel</code>。插件必须为这个 Webview 面板提供初始化的 HTML 内容。</li>
</ol>
<p>一旦 <code>resolveCustomTextEditor</code> 执行并返回，我们的自定义编辑器就呈现给用户了。Webview 里展示的内容完全取决于你的插件。</p>
<p>每当打开一个自定义编辑器，上述过程都会重复发生，即使当用户分割自定义编辑器。每个自定义编辑器示例都包含它自己的 <code>WebviewPanel</code>，只是对于同一个资源文件，多个自定义编辑器之间会共用这个资源文件。记住：请把<code>TextDocument</code> 当做是资源文件的模型，而 webview 只是该模型的视图。</p>
<h4 id="关闭自定义文本编辑器"><a class="header" href="#关闭自定义文本编辑器">关闭自定义文本编辑器</a></h4>
<p>当用户关闭一个打开的自定义文本编辑器时，VS Code 会触发<code>WebviewPanel</code> 的 <code>WebviewPanel.onDidDispose</code> 事件。这时，你的插件需要释放当前编辑器占用的资源（事件监听、文件变动监听等等）。</p>
<p>当资源文件的最后一个自定义编辑器被关闭时，该资源文件的 <code>TextDocument</code> 也会被释放，因为此时不再有任何编辑器或者其他插件在占用该资源文件。你可以通过 <code>TextDocument.isClosed</code> 检查 <code>TextDocument</code> 是否被关闭。当 <code>TextDocument</code> 被关闭后，用自定义编辑器打开同一个资源文件会创建新的 <code>TextDocument</code>。</p>
<h3 id="同步-textdocument-的变化"><a class="header" href="#同步-textdocument-的变化">同步 TextDocument 的变化</a></h3>
<p>由于自定义编辑器使用 <code>TextDocument</code> 作为文档模型，因此当<strong>编辑事件</strong>发生时，编辑器需要更新 <code>TextDocument</code>，同样的，当 <code>TextDocument</code> 变化时，编辑器也需要同步更新自身。</p>
<h4 id="从视图到-textdocument"><a class="header" href="#从视图到-textdocument">从视图到 <code>TextDocument</code></a></h4>
<p>在自定义文本编辑器中的编辑形式是很多的，比如点击一个按钮，改动一些文本，拖动一些项目等等。不论用户何时编辑自定义文本编辑器中的内容，插件都需要更新 <code>TextDocument</code>。下面我们来看看 <em>猫猫草稿插件</em> 是怎么实现这个功能的：</p>
<ol>
<li>用户点击webview中的 <strong>添加草稿</strong> 按钮。webview <a href="extension-guides//extension-guides/webview?id=%E8%84%9A%E6%9C%AC%E5%92%8C%E4%BF%A1%E6%81%AF%E4%BC%A0%E9%80%92">会发送一条消息</a> 给插件。</li>
<li>插件接受到消息。然后插件更高效文档的内部模型（在猫猫草稿插件的例子里，就是会添加一个 JSON 的入口）。</li>
<li>插件创建一个 <code>WorkspaceEdit</code> 对 JSON 文档进行更新。这个编辑操作使用了 <code>vscode.workspace.applyEdit</code>。</li>
</ol>
<p>你的插件需要对工作区编辑导致的<strong>文档更新最小化</strong>。记住，如果你在处理例如 JSON 这样的语言文件，你的插件需要观察用户现有的格式约定（如空格 vs tab，缩进大小等等）</p>
<h4 id="从-textdocument-到-webviews"><a class="header" href="#从-textdocument-到-webviews">从 <code>TextDocument</code> 到 webviews</a></h4>
<p>当 <code>TextDocument</code> 变化时，你还需要确保所有的 webview 能正确响应文档模型的变化。<code>TextDocument</code> 会在撤销编辑、恢复编辑甚至撤销文件事发生改变；或被其他插件的 <code>WorkspaceEdit</code> 导致变化；或者用户在 VS Code 中打开一个默认文本编辑器时产生变化。下面我们来看看 <em>猫猫草稿插件</em> 是怎么实现这个功能的：</p>
<ol>
<li>在插件中，我们需要订阅<code>vscode.workspace.onDidChangeTextDocument</code> 事件。每当 <code>TextDocument</code> 产生变化时（包括我们自定义编程器的变化）都会触发这个事件。</li>
<li>当文档对象的变化进入到我们插件中，插件发送一个带着新的文档状态消息给 webview，然后 webview 会更新自身，并渲染更新过的文档对象。</li>
</ol>
<p>你一定要记住，自定义编辑器的任何编辑动作都会触发 <code>onDidChangeTextDocument</code>。确保你的插件不会进入更新循环，比如用户在 webview 中编辑，然后触发了onDidChangeTextDocument，接着webview 产生了更新，结果webview 更新之后又触发了你的插件，然后再一次发送<code>onDidChangeTextDocument</code>事件，如此循环。</p>
<p>同样你也要记住，如果你在处理注入 JSON、XML 这样的结构化语言，文档对象校验可能会出错。你的插件必须在错误发生时优雅降级，或者给用户展示一个错误提示，以便用户能够理解错误并及时修复。</p>
<p>最后，如果更新所有的 webview 开销太高，请考虑 <a href="https://davidwalsh.name/javascript-debounce-function">debouncing</a> 到 webview 的更新操作。</p>
<h2 id="自定义编辑器"><a class="header" href="#自定义编辑器">自定义编辑器</a></h2>
<hr />
<p>你可以使用 <code>CustomEditorProvider</code> 和 <code>CustomReadonlyEditorProvider</code> 创建二进制文件的自定义编辑器。通过这个 API，你可以完全掌控显示给用户的文件、如何编辑以及通过你的插件深入控制 <code>save</code> 操作和其他文件操作。如果你在为一个文本格式的文件构建编辑器，强烈建议你使用<a href="extension-guides/custom-editors.html#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8"><code>CustomTextEditor</code></a> ，在这种场景下，这个 API 实现起来更为简单。</p>
<h3 id="customdocument"><a class="header" href="#customdocument">CustomDocument</a></h3>
<p>在自定义编辑器中，你的插件需要使用 <code>CustomDocument</code> 自己实现文档模型。你的插件可以任意储存<code>CustomDocument</code>所需数据，来实现你的自定义编辑器，但这种自由度也意味着你需要自己实现基本的文档操作，比如在热退出场景下保存和备份文件数据。</p>
<p>每个打开的文件都有一个对应的 <code>CustomDocument</code>，用户可以针对单个资源文件打开多个编辑器，比如分割当前自定义编辑器——但是所有这些编辑器的底层 <code>CustomDocument</code> 都是相同的。</p>
<h3 id="自定义编辑器的生命周期"><a class="header" href="#自定义编辑器的生命周期">自定义编辑器的生命周期</a></h3>
<p><strong>为每个文档提供多编辑器支持</strong></p>
<p>默认，VS Code 只允许每个编辑器只能使用一个自定义文档（对象）。这个限制能够帮助开发者相对轻松地实现自定义编辑器，开发者无需关心多个自定义编辑器实例的同步问题。</p>
<p>如果你的插件能够支持上述能力，那么我们建议在注册自定义编辑器的时候将 <code>supportsMultipleEditorsPerDocument: true</code> 设置好，然后多编辑器示例就可以共用一个文档对象了。通过这个方式，你的自定义编辑器就能像 VS Code 的普通文本编辑器一样了。</p>
<p><strong>打开自定义编辑器</strong></p>
<p>当用户打开的文件匹配 <code>customEditor</code> 配置点的时候，VS Code 会触发一个 <code>onCustomEditor</code> <a href="extension-guides//references/activation-events">激活事件</a>然后调用给定视图类型的供应器函数。<code>CustomEditorProvider</code> 有两个作用：给自定义编辑器提供文档对象，以及提供编辑器自身。下面是<a href="https://github.com/microsoft/vscode-extension-samples/tree/master/custom-editor-sample">自定义编辑器插件示例</a> 中的 <code>catCustoms.pawDraw</code> 实际发生的事件过程：</p>
<ol>
<li>VS Code 触发 <code>onCustomEditor:catCustoms.pawDraw</code> 激活事件。如果当前不存在激活插件，则激活我们的插件。确保我们的插件在激活<code>catCustoms.pawDraw</code>期间已经注册了 <code>CustomReadonlyEditorProvider</code> 或者 <code>CustomEditorProvider</code>。</li>
<li>VS Code 通过注册给 <code>catCustoms.pawDraw</code> 的 <code>CustomReadonlyEditorProvider</code> 或者 <code>CustomEditorProvider</code> 调用 <code>CustomReadonlyEditorProvider</code>。在这个地方，我们的插件会获得资源的 uri 然后为资源返回一个新的 <code>CustomDocument</code>。此时，我们的插件应该为该资源文件创建文档的内部模型对象。这可能涉及读取和解析磁盘中的初始文件状态，以及初始化我们新的 <code>CustomDocument</code>。我们的插件可以实现 <code>CustomDocument</code> 创建一个新类来定义这个模型。记住整个初始化阶段都依赖插件。VS Code 不关心插件生成 <code>CustomDocument</code> 的任何信息。</li>
<li>VS Code 带上上述第二步的 <code>CustomDocument</code> 调用 <code>resolveCustomEditor</code>，然后生成一个新的 <code>WebviewPanel</code>。我们的插件必须给自定义编辑器提供完整的初始化内容。如果有需要的话，我们也可以保存 <code>WebviewPanel</code> 的引用，以便后续使用，比如调用内部命令。</li>
</ol>
<p>一旦 <code>resolveCustomEditor</code> 返回，我们的自定义编辑器就会展示给用户。</p>
<p>如果用户在另一个编辑组里面用我们的自定义编辑器打开了同一个文件——比如分割首个编辑器——那么插件的工作是一样的。这样一来，VS Code 只会调用 <code>resolveCustomEditor</code> 并传入我们打开首个编辑器所创建的 <code>CustomDocument</code>。</p>
<p><strong>关闭自定义编辑器</strong></p>
<p>假设同一个源文件，我们有两个打开的编辑器实例。当用户关闭所有编辑器时，VS Code 会通知我们的插件，然后我们就可以进行相关资源的释放工作了。</p>
<p>当关闭第一个编辑器时，VS Code 会触发被关闭编辑器 <code>WebviewPanel</code> 的 <code>WebviewPanel.onDidDispose</code>方法。这样我们就可以清理特定编辑器实例的相关资源了。</p>
<p>当第二个编辑器被关闭时，VS Code 也会调用 <code>WebviewPanel.onDidDispose</code> 方法。不过现在我们也在 <code>CustomDocument</code> 中关闭了所有编辑器。当 <code>CustomDocument</code> 中没有其他编辑器时，VS Code 会调用它的 <code>CustomDocument.dispose</code> 方法。我们插件的 <code>dispose</code> 实现了文档对象的所有相关资源清理工作。</p>
<p>如果用户重开了同一个资源文件，我们会新建一个 <code>CustomDocument</code> 然后重新走 <code>openCustomDocument</code>、<code>resolveCustomEditor</code> 流程。</p>
<h4 id="只读自定义编辑器"><a class="header" href="#只读自定义编辑器">只读自定义编辑器</a></h4>
<p>接下来，大部分支持编辑功能的自定义编辑器，可能听起来会有点矛盾，但是其中很多完全不需要编辑能力——想象一下图片预览功能，或者堆内存的可视化界面，这两个例子都需要使用自定义编辑器，但却完全不需要编辑功能。所以下面让我来介绍 <code>CustomReadonlyEditorProvider</code>。</p>
<p><code>CustomReadonlyEditorProvider</code> 允许你创建不需要编辑能力的自定义编辑器。这些编辑器可以有交互功能，但是不支持注入撤销和保存的功能。所以相比实现一个可编辑的编辑器，这个API 可以让你的工作简单很多。</p>
<h4 id="可编辑自定义编辑器的基础"><a class="header" href="#可编辑自定义编辑器的基础">可编辑自定义编辑器的基础</a></h4>
<p>可编辑的自定义编辑器让你有机会深入到标准的 VS Code 操作中去，比如撤销、恢复、保存和热退出。所以可编辑自定义编辑器非常强大，但这也意味着此类实现势必比实现一个可编辑自<strong>定义<em>文本</em>编辑器</strong>或者只读编辑器更复杂。</p>
<p>可读自定义编辑器通过 <code>CustomEditorProvider</code> 实现。这个接口扩展了 <code>CustomReadonlyEditorProvider</code>，所以你要自己实现比如 <code>openCustomDocument</code> 或 <code>resolveCustomEditor</code> 以及其他基本操作。让我们先来看看<code>CustomEditorProvider</code> 中的编辑部分。</p>
<h4 id="编辑"><a class="header" href="#编辑">编辑</a></h4>
<p>编辑会影响到可编辑自定义文档对象。这个编辑操作，可以是文本变化、图片旋转、生成列表等。编辑具体的行为和规范，完全由你的插件定义，但是 VS Code 需要知道“编辑”动作在何时发生。VS Code 会在 “编辑” 发生时将文档标记为“脏文档”，然后就会启动自动保存和备份功能了。</p>
<p>不论用户何时触发了自定义编辑器 webview 中的编辑操作，你的插件都需要触发 <code>CustomEditorProvider</code> 的 <code>onDidChangeCustomDocument</code> 事件。<code>onDidChangeCustomDocument</code> 依据你的自定义编辑器实现，会触发为两种事件类型：<code>CustomDocumentContentChangeEvent</code> 和 <code>CustomDocumentEditEvent</code>。</p>
<h4 id="customdocumentcontentchangeevent"><a class="header" href="#customdocumentcontentchangeevent">CustomDocumentContentChangeEvent</a></h4>
<p><code>CustomDocumentContentChangeEvent</code> 是一个基本编辑单元，它仅仅告诉 VS Code 文档被编辑了。</p>
<p>当插件从 <code>onDidChangeCustomDocument</code> 触发 <code>CustomDocumentContentChangeEvent</code> 之时， VS Code 会将相关文档标记为“变脏中”。此时，如果需要将文档恢复到“干净”状态，需要用户保存或者撤销操作。使用了 <code>CustomDocumentContentChangeEvent</code> 的编辑器不支持VS Code 的撤销/恢复操作。</p>
<h4 id="customdocumenteditevent"><a class="header" href="#customdocumenteditevent">CustomDocumentEditEvent</a></h4>
<p><code>CustomDocumentEditEvent</code> 则是一个允许撤销/恢复的复杂编辑操作。你应该在自定义编辑器中尽量使用 <code>CustomDocumentEditEvent</code>，如果无法实现撤销/恢复时再降级到<code>CustomDocumentContentChangeEvent</code>。</p>
<p><code>CustomDocumentContentChangeEvent</code> 包含下列字段：</p>
<ul>
<li><code>document</code> —— 正在编辑的 <code>CustomDocument</code> 对象</li>
<li><code>label</code> —— 可选文本，描述了“编辑”操作类型（比如“剪切”，“插入”……）</li>
<li><code>undo</code> —— 当编辑操作需要被撤销时，VS Code 调用的函数方法</li>
<li><code>redo</code> —— 当编辑操作需要被恢复时，VS Code 调用的函数方法</li>
</ul>
<p>当插件从 <code>onDidChangeCustomDocument</code> 触发 <code>CustomDocumentEditEvent</code> 时，VS Code 当相关文档标记为“脏文档”。如果需要将文档恢复到“干净”的状态，用户可以保存或者撤回操作，或者使用撤销/恢复，回到文档之前的状态。</p>
<p>当特定的编辑操作需要撤销或者重做时，编辑器中的 <code>undo</code> 和 <code>redo</code> 方法会被 VS Code 触发。VS Code 内部保存这编辑栈，所以你的插件触发了3 次<code>onDidChangeCustomDocument</code>编辑操作，比如说 <code>a</code>, <code>b</code>, <code>c</code>：</p>
<pre><code class="language-typescript">onDidChangeCustomDocument(a);
onDidChangeCustomDocument(b);
onDidChangeCustomDocument(c);
</code></pre>
<p>用户的下列操作会导致：</p>
<pre><code>undo — c.undo()
undo — b.undo()
redo — b.redo()
redo — c.redo()
redo — 哎呦, 没有更多编辑操作了
</code></pre>
<p>要实现撤销/恢复，你的插件必须更新相关自定义文档内部的状态，以及所有相关 webview 视图。要注意，你的同一个源文件可能对应着多个 webview！在更新视图时必须要保证数据的唯一性。比如说，一个图片有多个编辑器实例，他们必须展现同样的像素信息，但是每个编辑器实例应该有它们自己的缩放级别和 UI 状态。</p>
<h3 id="保存"><a class="header" href="#保存">保存</a></h3>
<p>当用户在编辑器中执行保存，你的插件需要将源文件当前状态写入磁盘。你的自定义编辑器该怎么做，取决于你插件的 <code>CustomDocument</code> 类型和你的插件内部如何追踪编辑。</p>
<p>保存的第一步就是获取数据流，然后写入磁盘。常用的方法包括：</p>
<ul>
<li>追溯资源状态，以后后续使用时快速地序列化。拿图片编辑器为例子，你可以将像素数据保存为 buffer。</li>
<li>上次保存操作之后记录用户编辑操作，以便生成新文件。再以图片编辑器为例子，如果想要更高效一些，我们可以追踪上次保存后的编辑操作，比如一系列的 <code>裁剪</code>、<code>旋转</code>、<code>缩放</code>等操作之后。当用户保存时，插件可以基于上次保存的文件立即应用这些操作来生成新文件。</li>
<li>保存来自自定义编辑器 <code>WebviewPanel</code> 中获取的文件数据。记住，即使自定义编辑器即使不可见也能够保存数据。因此，我面更建议你的插件在实现<code>保存</code>时不要依赖<code>WebviewPanel</code>。如果实在没办法，你可以使用<code>WebviewPanelOptions.retainContextWhenHidden</code>设置，这样 webview 会在不可见时保持存活，<code>retainContextWhenHidden</code> 会造成显著的内存消耗，因此你需要保守地使用它。</li>
</ul>
<p>在你获取资源的数据之后，通常还需要使用 <a href="https://code.visualstudio.com/api/references/vscode-api#FileSystem">workspace FS api</a> 把数据写到磁盘上。FS API 接收一个 <code>UInt8Array</code> 类型数据，这个 api 既可以写入字节码也可以写入纯文本格式文件。对于字节码数据，只要把字节数据放到 <code>UInt8Array</code>就行了。对于文本文件来说，用<code>Buffer</code>对文本进行转换之后就可以使用了：</p>
<pre><code class="language-typescript">const writeData = Buffer.from('my text data', 'utf8');
vscode.workspace.fs.writeFile(fileUri, writeData);
</code></pre>
<h2 id="下一步-8"><a class="header" href="#下一步-8">下一步</a></h2>
<p>如果你想要学习更多 VS Code 插件能力的相关知识，请参考下面的主题：</p>
<ul>
<li><a href="https://code.visualstudio.com/api">Extension API</a> - 学习完整的 VS Code 插件 API</li>
<li><a href="extension-guides//extension-capabilities/README">插件功能</a> - 学习其他扩展 VS Code 的方法</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="自定义数据插件"><a class="header" href="#自定义数据插件">自定义数据插件</a></h1>
<p><a href="https://github.com/microsoft/vscode-custom-data">自定义数据格式</a> 可帮助插件作者轻松地扩展 VS Code 的 HTML / CSS 语言支持能力，且不用多写一行代码。</p>
<p>通过以下两个<a href="extension-guides//references/contribution-points">配置点</a> 可以使用自定义数据：</p>
<ul>
<li><code>contributes.html.customData</code></li>
<li><code>contributes.css.customData</code></li>
</ul>
<p>比如，在插件的<code>package.json</code>中配置这两行之后：</p>
<pre><code class="language-json">{
  &quot;contributes&quot;: {
    &quot;html&quot;: {
      &quot;customData&quot;: [&quot;./html.html-data.json&quot;]
    },
    &quot;css&quot;: {
      &quot;customData&quot;: [&quot;./css.css-data.json&quot;]
    }
  }
}
</code></pre>
<p>VS Code 会根据这两个文件中定义的 HTML/CSS 实体，提供对应的语言支持能力，比如自动完成、悬停提示等。</p>
<p>你可以在 <a href="https://github.com/microsoft/vscode-extension-samples/tree/master/custom-data-sample">自定义数据示例</a> 中查看。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="概述-1"><a class="header" href="#概述-1">概述</a></h1>
<p>VS Code通过语言插件可以为各式各样的编程语言提供智能的编辑体验。VS Code并不含内置语言支持，不过提供了一整套支持富文本特性的API。
比如，<a href="https://github.com/Microsoft/vscode/tree/master/extensions/html">HTML</a>插件是一个可以为VS Code中的HTML文件提供语法高亮的插件。
类似的，当你输入<code>console.</code>时，智能补全会提示<code>log</code>，这是<a href="https://github.com/Microsoft/vscode/tree/master/extensions/typescript-language-features">Typescript Language Features</a>插件提供的。</p>
<p>语言特性大致可以分为下面两种：</p>
<h2 id="声明式语言特性"><a class="header" href="#声明式语言特性">声明式语言特性</a></h2>
<hr />
<p>定义在配置文件的语言功能称之为<em>编程式语言特性</em>，比如，<a href="https://github.com/Microsoft/vscode/tree/master/extensions/html">html</a>，<a href="https://github.com/Microsoft/vscode/tree/master/extensions/css">css</a>和<a href="https://github.com/Microsoft/vscode/tree/master/extensions/typescript-basics">typescript-基础支持</a>插件都打包在了VS Code中，所以提供了下列声明式语言特性：</p>
<ul>
<li>语法高亮</li>
<li>代码片段补全</li>
<li>括号匹配</li>
<li>自动闭合括号</li>
<li>括号识别</li>
<li>启动、关闭注释</li>
<li>自动缩进</li>
<li>代码折叠</li>
</ul>
<p>我们提供了3个指南供你开发语言插件的声明式特性：</p>
<ul>
<li><a href="language-extensions//language-extensions/syntax-highlight-guide">语法高亮指南</a>：VS Code 使用TextMate语法来高亮代码。这个指南将教你用简单的TextMate语法开发一个VS Code插件。</li>
<li><a href="language-extensions//language-extensions/snippet-guide">代码片段补全指南</a>： 这个指南教你怎么把代码片段打包进插件中。</li>
<li><a href="language-extensions//language-extensions/language-configuration-guide">语言配置指南</a>：VS Code允许插件为任何编程语言定义 <strong>语言配置</strong>。这个文件控制着基本的编辑功能，如开闭注释、括号匹配/识别，和(基础)代码折叠。</li>
</ul>
<h2 id="编程式语言特性"><a class="header" href="#编程式语言特性">编程式语言特性</a></h2>
<hr />
<p>编程式语言特性包括自动补全、错误检查和跳转到定义。这些功能一般通过<em>语言服务器</em>驱动，这个服务器会分析你的项目，然后提供对应的功能。最好的例子就是打包在VS Code中的<a href="https://github.com/Microsoft/vscode/tree/master/extensions/typescript-language-features"><code>typescript-language-features</code></a>插件，它利用<a href="https://github.com/Microsoft/TypeScript/wiki/Using-the-Language-Service-API">TypeScript Language Service</a>提供了诸如下面罗列的编程式语言特性：</p>
<ul>
<li>悬停信息（<a href="https://code.visualstudio.com/api/references/vscode-api#languages.registerHoverProvider">vscode.languages.registerHoverProvider</a>）</li>
<li>自动补全（<a href="https://code.visualstudio.com/api/references/vscode-api#languages.registerDefinitionProvider">vscode.languages.registerCompletionItemProvider</a>）</li>
<li>转跳到定义（<a href="https://code.visualstudio.com/api/references/vscode-api#languages.registerDefinitionProvider">vscode.languages.registerDefinitionProvider</a>）</li>
<li>错误检查</li>
<li>格式化</li>
<li>重构</li>
<li>代码折叠</li>
</ul>
<p>下面是<a href="language-extensions//language-extensions/programmatic-language-features">编程式语言特性</a>的完整列表。</p>
<p><img src="https://media.githubusercontent.com/media/Microsoft/vscode-docs/master/api/language-extensions/images/overview/multi-ls.png" alt="multi-ls" /></p>
<h2 id="语言服务器协议language-server-protocol"><a class="header" href="#语言服务器协议language-server-protocol">语言服务器协议（Language Server Protocol）</a></h2>
<hr />
<p><a href="https://microsoft.github.io/language-server-protocol/">语言服务器协议</a>将语言服务器（一个静态代码分析工具）和语言客户端（一般就是源代码）之间的通信进行了标准化，这样一来插件开发者就可以只写一次代码分析程序，然后在多个编辑器中重用了。</p>
<p>在<a href="language-extensions//language-extensions/programmatic-language-features">编程式语言特性</a>列表中，你可以找到所有VS Code的语言特性，以及它和<a href="https://microsoft.github.io/language-server-protocol/specification">语言服务器协议规格</a>之间的映射关系。</p>
<p>我们提供了一个非常详尽的指南，里面会告诉你怎么实现一个语言服务器插件：</p>
<ul>
<li><a href="language-extensions//language-extensions/language-server-extension-guide">语言服务器插件指南</a></li>
</ul>
<p><img src="https://media.githubusercontent.com/media/Microsoft/vscode-docs/master/api/language-extensions/images/overview/multi-editor.png" alt="multi-editor" /></p>
<h2 id="特殊功能"><a class="header" href="#特殊功能">特殊功能</a></h2>
<hr />
<h4 id="多目录工作区支持"><a class="header" href="#多目录工作区支持">多目录工作区支持</a></h4>
<p>当用户打开了一个<a href="https://code.visualstudio.com/docs/editor/multi-root-workspaces">多目录工作区</a>，你可能需要将你的语言服务器插件做相应的调整。这个主题探讨了几种多目录工作区的语言服务器的实现方法。
（译者注：官方可能尚未完成这个部分的文档）</p>
<h4 id="嵌入式语言"><a class="header" href="#嵌入式语言">嵌入式语言</a></h4>
<p>嵌入式语言在web开发中是非常常见的，比如HTML中的CSS/JS，JS/TS中的GraphQL。这个主题探讨了针对嵌入语言实现VS Code语言特性的各种方法。
（译者注：官方可能尚未完成这个部分的文档）</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="语法高亮"><a class="header" href="#语法高亮">语法高亮</a></h1>
<hr />
<p>语法高亮决定源代码的颜色和样式，它主要负责关键字（如javascript中的<code>if</code>，<code>for</code>）、字符串、注释、变量名等等语法的着色工作。</p>
<p>语法高亮由两部分工作组成：</p>
<ul>
<li><a href="language-extensions/syntax-highlight-guide.html#%E5%88%86%E8%AF%8D">分词</a>：将文本分割为一系列符号（包括单词和标点）</li>
<li><a href="language-extensions/syntax-highlight-guide.html#%E4%B8%BB%E9%A2%98%E5%8C%96">主题化</a>：然后根据主题或用户设置，对符号进行着色添加样式</li>
</ul>
<p>在本章开始之前，建议你先玩一下 <a href="language-extensions/syntax-highlight-guide.html#%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%A3%80%E6%9F%A5%E5%99%A8">作用域检查器</a> 工具看看文件中的符号都长什么样子，他们都应用了哪些主题样式。用内置主题（比如 Dark+）查看一份 TypeScript 文件，你就能同时看到语义高亮和语法高亮了。</p>
<h2 id="分词"><a class="header" href="#分词">分词</a></h2>
<hr />
<p>文本分词是指将文本打碎成一个个片段，并将每个片段根据符号类型（单词、标点等）进行分类。</p>
<p>VS Code 的分词引擎是通过 <a href="https://macromates.com/manual/en/language_grammars">TextMate</a> 驱动的。TextMate 语法是一套使用 plist(XML) 或 JSON 格式的结构化正则表达式集合。VS Code 则可通过 <code>grammar</code> 配置点进行语法配置。</p>
<p>TextMate 分词引擎和渲染引擎在同一个进程上运行，用户输入时，对应的<strong>符号</strong>也会实时更新。<strong>符号</strong>是语法高亮的最小单位，它将代码分为注释、字符串、正则等类型。</p>
<p>从1.43 版本开始，VS Code 也允许插件通过 <a href="https://code.visualstudio.com/api/references/vscode-api#DocumentSemanticTokensProvider">语义化分词供应器函数</a> 提供分词功能。语义供应器函数通常由语言服务器实现，它必须能够深入理解源代码，并且能够解析上下文的各类符号。比如，一个常量的名称应该在整个项目中都使用常量类型的语法高亮，而不是只在它声明的地方。</p>
<p>基于语义化分词的语法高亮，一般被认为是基于 TextMate 语言高亮的一个补充。语义化高亮是语法高亮的上层建筑。由于语言服务器通常都要花不少时间加载和分析项目，所以语义化高亮展现也可能会有所延迟。</p>
<p>本章侧重于介绍基于 TextMate 的分词和语法高亮，语义化分词高亮请查看<a href="language-extensions//language-extensions/semantic-highlight-guide">语义高亮</a>。</p>
<h3 id="textmate-语法"><a class="header" href="#textmate-语法">TextMate 语法</a></h3>
<p>VS Code使用<a href="https://macromates.com/manual/en/language_grammars">TextMate 语法</a>将文本分割成一个个符号。TextMate语法是<a href="https://macromates.com/manual/en/regular_expressions">Oniguruma正则表达式</a>的集合，一般是一份plist或者JSON格式的文件。你可以在<a href="https://www.apeth.com/nonblog/stories/textmatebundle.html">这里</a>找到更棒的介绍文档，在里面可以找到你感兴趣的TextMate语法。</p>
<h4 id="textmate符号和作用域"><a class="header" href="#textmate符号和作用域">TextMate符号和作用域</a></h4>
<p><strong>符号</strong>是由一门编程语言中最常见的一到几个字符组成的。符号包括运算符（如：<code>+</code>和<code>*</code>），变量名（如：<code>myVar</code>），或者字符串（如：<code>&quot;my string&quot;</code>）。</p>
<p>每个<strong>符号</strong>都有其作用域，作用域描述了这个<strong>符号</strong>的上下文。一个<strong>符号</strong>可被由<strong>点</strong>符号序列查找到，比如javascript中的<code>+</code>符号有这样的作用域<code>keyword.operator.arithmetic.js</code>。</p>
<p>主题会把颜色和样式映射到作用域上，这样一来就实现了语法高亮。TextMate提供了一些主题中<a href="https://macromates.com/manual/en/language_grammars">常用的作用域</a>，如果你想要尽可能全面地支持语法，最好从现成的主题中入手，避免重新编写主题。</p>
<p><strong>作用域</strong>支持嵌套，每个符号都会关联到它的父作用域上。下面的例子使用了<a href="language-extensions/syntax-highlight-guide.html#%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%A3%80%E6%9F%A5%E5%99%A8">作用域检查器</a>，可以清晰地看到javascript函数中的运算符<code>+</code>和它的作用域层级：</p>
<p><img src="https://code.visualstudio.com/assets/api/language-extensions/syntax-highlighting/scopes.png" alt="scopes" /></p>
<p>父作用域的信息也同样是主题中的一部分。当主题指定了作用域，该作用域下的所有符号都会进行对应的着色，除非主题里面对单个作用域有其特殊配置。</p>
<h3 id="配置基本语法"><a class="header" href="#配置基本语法">配置基本语法</a></h3>
<p>VS Code支持JSON格式的TextMate语法。你可以在<a href="language-extensions//references/contribution-points">发布内容配置</a>里面的<code>grammers</code>进行配置。</p>
<p>这个配置点可以配置的内容有：语言的id，顶层语法作用域的名称，语法文件的路径。下面是一个<code>abc</code>语言的语法配置文件：</p>
<pre><code class="language-json">{
	&quot;contributes&quot;: {
		&quot;languages&quot;: [
			{
				&quot;id&quot;: &quot;abc&quot;,
				&quot;extensions&quot;: [&quot;.abc&quot;]
			}
		],
		&quot;grammars&quot;: [
			{
				&quot;language&quot;: &quot;abc&quot;,
				&quot;scopeName&quot;: &quot;source.abc&quot;,
				&quot;path&quot;: &quot;./syntaxes/abc.tmGrammar.json&quot;
			}
		]
	}
}
</code></pre>
<p>这个语法文件本身包含了一个顶层规则，里面一般分为两个部分，<code>patterns</code>列出了程序(program)和<code>repository</code>的顶层元素。语法中的其他规则需要从<code>repository</code>中使用<code>{ &quot;include&quot;: &quot;#id&quot; }</code>引入。</p>
<p><code>abc</code>语法标记了字母<code>a</code>，<code>b</code>和<code>c</code>作为关键字，可以被括号包起来成为一个表达式。</p>
<pre><code class="language-json">{
	&quot;scopeName&quot;: &quot;source.abc&quot;,
	&quot;patterns&quot;: [{ &quot;include&quot;: &quot;#expression&quot; }],
	&quot;repository&quot;: {
		&quot;expression&quot;: {
			&quot;patterns&quot;: [{ &quot;include&quot;: &quot;#letter&quot; }, { &quot;include&quot;: &quot;#paren-expression&quot; }]
		},
		&quot;letter&quot;: {
			&quot;match&quot;: &quot;a|b|c&quot;,
			&quot;name&quot;: &quot;keyword.letter&quot;
		},
		&quot;paren-expression&quot;: {
			&quot;begin&quot;: &quot;\\(&quot;,
			&quot;end&quot;: &quot;\\)&quot;,
			&quot;beginCaptures&quot;: {
				&quot;0&quot;: { &quot;name&quot;: &quot;punctuation.paren.open&quot; }
			},
			&quot;endCaptures&quot;: {
				&quot;0&quot;: { &quot;name&quot;: &quot;punctuation.paren.close&quot; }
			},
			&quot;name&quot;: &quot;expression.group&quot;,
			&quot;patterns&quot;: [{ &quot;include&quot;: &quot;#expression&quot; }]
		}
	}
}
</code></pre>
<p>语法引擎会试着逐步将<code>expression</code>中的规则应用到文本中。比如下面这个简单的程序：</p>
<pre><code>a
(
    b
)
x
(
    (
        c
        xyz
    )
)
(
a
</code></pre>
<p>这个例子中的语法产生了下面的作用域列表（从左到右，从最佳匹配到最不匹配）</p>
<pre><code>a               keyword.letter, source.abc
(               punctuation.paren.open, expression.group, source.abc
    b           expression.group, source.abc
)               punctuation.paren.close, expression.group, source.abc
x               source.abc
(               punctuation.paren.open, expression.group, source.abc
    (           punctuation.paren.open, expression.group, expression.group, source.abc
        c       keyword.letter, expression.group, expression.group, source.abc
        xyz     expression.group, expression.group, source.abc
    )           punctuation.paren.close, expression.group, expression.group, source.abc
)               punctuation.paren.close, expression.group, source.abc
(               source.abc
a               keyword.letter, source.abc
</code></pre>
<p>注意文本匹配不是单一规则，比如字符串<code>xyz</code>，是包含在当前作用域中的。文件的最后一个括号在<code>expression.group</code>里面，因为不会匹配<code>end</code>规则。</p>
<h3 id="嵌入式语言-1"><a class="header" href="#嵌入式语言-1">嵌入式语言</a></h3>
<p>如果你的语法中需要在父语言中嵌入其他语言，比如HTML中的CSS，那么你可以使用<code>embeddedLanguages</code>配置，告诉VSCode怎么处理嵌入的语言。然后嵌入语言的括号匹配，注释，和其他基础语言功能都会正常运作。</p>
<p><code>embeddedLanguages</code>配置将嵌入语言的作用域映射到顶层语言的作用域上。下面里的例子里，<code>meta.embedded.block.javascript</code>作用域中的任何符号都会以javscript处理：</p>
<pre><code class="language-json">{
	&quot;contributes&quot;: {
		&quot;grammars&quot;: [
			{
				&quot;path&quot;: &quot;./syntaxes/abc.tmLanguage.json&quot;,
				&quot;scopeName&quot;: &quot;source.abc&quot;,
				&quot;embeddedLanguages&quot;: {
					&quot;meta.embedded.block.javascript&quot;: &quot;source.js&quot;
				}
			}
		]
	}
}
</code></pre>
<p>现在，如你对应用了<code>meta.embedded.block.javascript</code>的符号进行注释就会有正确的<code>//</code>javascript风格，如果你触发代码片段，也会提示对应的javascript片段。</p>
<h3 id="开发全新的语法插件"><a class="header" href="#开发全新的语法插件">开发全新的语法插件</a></h3>
<p>使用<a href="language-extensions//get-started/your-first-extension">VS Code的Yeoman模板</a>快速创建一个新的语法插件，运行<code>yo code</code>然后选择<code>New Language</code>：</p>
<p><img src="https://code.visualstudio.com/assets/api/language-extensions/syntax-highlighting/yo-new-language.png" alt="yo-new-language" /></p>
<p>Yeoman通过问问题的方式最后生成新的插件，对于创建语法插件最重要的几点就是：</p>
<ul>
<li><code>Language Id</code> - 这个语言的id</li>
<li><code>Language Name</code> - 友好的名称</li>
<li><code>Scope names</code> - TextMate根作用域名称</li>
</ul>
<p><img src="https://code.visualstudio.com/assets/api/language-extensions/syntax-highlighting/yo-new-language-questions.png" alt="yo-new-language-questions" /></p>
<p>生成器会假设你要同时对新语言定义好语言id和语法。如果你只是根据已有的语言创建新的语法，那么你只要填好目标语言的信息就好，然后一定要删除生成的<code>package.json</code>中的<code>languages</code>部分。</p>
<p>回答了一大堆问题之后，Yeoman会创建一个新的插件，其结构如下：</p>
<p><img src="https://code.visualstudio.com/assets/api/language-extensions/syntax-highlighting/generated-new-language-extension.png" alt="generated-new-language-extension" /></p>
<p>!&gt; 注意：如果你只是配置一个VS Code中已有语言的语法，记得删掉生成的<code>package.json</code>中的<code>languages</code>配置。</p>
<h4 id="迁移现成的textmate语法"><a class="header" href="#迁移现成的textmate语法">迁移现成的TextMate语法</a></h4>
<p><code>yo code</code>也快成帮你把已有的TextMate语法转成一个VS Code插件。使用<code>yo code</code>，选择<code>Language extension</code>，当询问是否从已有TextMate文件插件的时候，填入后缀为<code>.tmLanguage</code>或<code>.json</code>的TextMate语法文件。</p>
<p><img src="https://code.visualstudio.com/assets/api/language-extensions/syntax-highlighting/yo-convert.png" alt="yo-convert" /></p>
<h4 id="用yaml配置语法"><a class="header" href="#用yaml配置语法">用YAML配置语法</a></h4>
<p>随着语言日益复杂，你可能很快就会难以理解和维护你的json文件。如果你发现自己需要写很多正则表达式，或是需要添加大量解释语法层面的注释，你可能需要考虑使用yaml定义语法文件了。</p>
<p>Yaml语法和json有着同样的结构，但是它的语法更加精简，如多行字符串和注释。</p>
<p><img src="https://code.visualstudio.com/assets/api/language-extensions/syntax-highlighting/yaml-grammar.png" alt="yaml-grammar" /></p>
<p>VS Code只能加载json语法，所以yaml格式的语法文件必须最终转换成json文件。<a href="https://www.npmjs.com/package/js-yaml"><code>js-yaml</code>包</a>可以帮你完成这个任务：</p>
<pre><code class="language-bash"># Install js-yaml as a development only dependency in your extension
$ npm install js-yaml --save-dev

# Use the command line tool to convert the yaml grammar to json
$ npx js-yaml syntaxes/abc.tmLanguage.yaml &gt; syntaxes/abc.tmLanguage.json
</code></pre>
<h4 id="语法注入"><a class="header" href="#语法注入">语法注入</a></h4>
<p>你可以通过<em>语法注入</em>扩展一个现成的语法文件。<em>语法注入</em>就是常规的TextMate语法，<em>语法注入</em>的应用有：</p>
<ul>
<li>高亮注释中的关键字，如<code>TODO</code></li>
<li>对现有语法添加更明确的作用域信息</li>
<li>向Markdown中的代码区块添加语法高亮</li>
</ul>
<p><strong>创建一个基础语法注入</strong></p>
<p><em>语法注入</em>也是在<code>package.json</code>中配置的，不过这次不需要配置<code>language</code>，而是配置<code>injectTo</code>指明目需要注入的语言作用域列表。</p>
<p>在这个例子里，我们会新建一个非常简单的注入语法，对javascript注释中的<code>TODO</code>进行高亮。我们在<code>injectTo</code>中用<code>source.js</code>指向目标语言的作用域。</p>
<pre><code class="language-json">{
	&quot;contributes&quot;: {
		&quot;grammars&quot;: [
			{
				&quot;path&quot;: &quot;./syntaxes/injection.json&quot;,
				&quot;scopeName&quot;: &quot;todo-comment.injection&quot;,
				&quot;injectTo&quot;: [&quot;source.js&quot;]
			}
		]
	}
}
</code></pre>
<p>除了顶层的<code>injectionSelector</code>，语法本身就应该是标准的TextMate语法。<code>injectionSelector</code>是一个作用域选择器，它指明了<em>语法注入</em>生效的作用域。在我们的例子里，我们想要在所有<code>//</code>注释中的<code>TODO</code>高亮。使用<a href="language-extensions/syntax-highlight-guide.html#%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%A3%80%E6%9F%A5%E5%99%A8">作用域检查器</a>，我们会发现JavaScript的双斜杠存在作用域<code>comment.line.double-slash</code>，所以我们的注入选择器是<code>L:comment.line.double-slash</code>：</p>
<pre><code class="language-json">{
	&quot;scopeName&quot;: &quot;todo-comment.injection&quot;,
	&quot;injectionSelector&quot;: &quot;L:comment.line.double-slash&quot;,
	&quot;patterns&quot;: [
		{
			&quot;include&quot;: &quot;#todo-keyword&quot;
		}
	],
	&quot;repository&quot;: {
		&quot;todo-keyword&quot;: {
			&quot;match&quot;: &quot;TODO&quot;,
			&quot;name&quot;: &quot;keyword.todo&quot;
		}
	}
}
</code></pre>
<p>注入选择器中的<code>L:</code>代表注入的语法添加在现有语法规则的左边。也就是说我们注入的语法规则会在任何现有语法规则之前生效。</p>
<p><strong>嵌入语法</strong></p>
<p><em>语法注入</em>也可以用在嵌入语言中，在他们的父级语法中进行配置。就和普通的语法意义，<em>语法注入</em>也可以使用<code>embeddedLanguages</code>将嵌入语言的作用域映射到顶层的语言作用域上。</p>
<p>比如高亮JS字符串中的sql查询的插件，可以使用<code>embeddedLanguages</code>为字符串中所有匹配<code>meta.embedded.inline.sql</code>的符号应用sql语言的基本功能，比如括号匹配和片段选择。</p>
<pre><code class="language-json">{
	&quot;contributes&quot;: {
		&quot;grammars&quot;: [
			{
				&quot;path&quot;: &quot;./syntaxes/injection.json&quot;,
				&quot;scopeName&quot;: &quot;sql-string.injection&quot;,
				&quot;injectTo&quot;: [&quot;source.js&quot;],
				&quot;embeddedLanguages&quot;: {
					&quot;meta.embedded.inline.sql&quot;: &quot;source.sql&quot;
				}
			}
		]
	}
}
</code></pre>
<p><strong>符号类型和嵌入语言</strong></p>
<p>对于嵌入语言中的注入语言还会有个副作用，那就是VS Code把所有字符串（string）中的<em>符号</em>视为字符文本，而且把注释中的所有<em>符号</em>视为符号内容（token content）。
因此诸如括号匹配和自动补全在字符串和注释中是无法使用的，如果<em>嵌入语言</em>刚好出现在字符串或注释中，那么这些功能就无法在<em>嵌入语言</em>中使用。</p>
<p>想要重载这个行为，你需要使用<code>meta.embedded.*</code>作用域重置VS Code标记字符串和注释行为。最佳实践就是始终将嵌入语言放在<code>meta.embedded.*</code>作用域中，确保VS Code能够正确处理嵌入语言。</p>
<p>如果你无法为你的语法添加<code>meta.embedded.*</code>作用域，你可以在语法配置中用<code>tokenTypes</code>，指定<em>作用域</em>到内容模式（content mode）上。
下面的<code>tokenTypes</code>确保<code>my.sql.template.string</code>作用域中的任何内容都应视为代码：</p>
<pre><code class="language-json">{
	&quot;contributes&quot;: {
		&quot;grammars&quot;: [
			{
				&quot;path&quot;: &quot;./syntaxes/injection.json&quot;,
				&quot;scopeName&quot;: &quot;sql-string.injection&quot;,
				&quot;injectTo&quot;: [&quot;source.js&quot;],
				&quot;embeddedLanguages&quot;: {
					&quot;my.sql.template.string&quot;: &quot;source.sql&quot;
				},
				&quot;tokenTypes&quot;: {
					&quot;my.sql.template.string&quot;: &quot;other&quot;
				}
			}
		]
	}
}
</code></pre>
<h2 id="主题化"><a class="header" href="#主题化">主题化</a></h2>
<hr />
<p>主题化是把颜色和样式应用到<strong>符号</strong>的过程。色彩主题定义了主题化规则，但用户可以在<em>用户设置</em>中自定义主题化规则。</p>
<p><code>tokenColors</code> 定义了 TextMate 主题规则，它的语法和常用的 TextMate 主题是完全一样的。每份规则都定义了 TextMate 作用域选择器，并应用对应的颜色和样式。</p>
<p>解析符号的颜色或样式时，当前符号的<strong>作用域</strong>需要和规则中的<strong>选择器</strong>相匹配，然后找到最为匹配的样式属性（前景色、加粗、斜体、下划线）。</p>
<p><a href="language-extensions//extension-guides/color-theme">色彩主题</a> 章节介绍了如何创建新的色彩主题，语义化分词的主题化则在<a href="language-extensions//language-extensions/semantic-highlight-guide">语义高亮</a>中。</p>
<h2 id="作用域检查器"><a class="header" href="#作用域检查器">作用域检查器</a></h2>
<hr />
<p>VS Code自带的作用域检查器能帮你调试语法文件。它能显示当前位置<em>符号</em>作用域，以及应用在上面的主题规则和元信息。</p>
<p>在命令面板中输入<code>Developer: Inspect TM Scopes</code>或者<a href="https://code.visualstudio.com/docs/getstarted/keybindings">使用快捷键</a>启动<em>作用域检查器</em>。</p>
<pre><code class="language-json">{
	&quot;key&quot;: &quot;cmd+alt+shift+i&quot;,
	&quot;command&quot;: &quot;editor.action.inspectTMScopes&quot;
}
</code></pre>
<p><img src="https://code.visualstudio.com/assets/api/language-extensions/syntax-highlighting/scope-inspector.png" alt="scope-inspector" /></p>
<p>作用域检查器可以显示以下的信息：</p>
<ol>
<li>当前符号</li>
<li>关于符号的元信息，这些值都是计算后的值。如果你使用了嵌入语言，那么这里最重要的信息就是<code>language</code>和<code>token type</code>了</li>
<li>符号使用的主题规则。这里只显示当前应用的规则，而不显示被其他样式覆盖的规则。</li>
<li>完整的作用域列表，越往上作用域越明确。</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="语义高亮指南"><a class="header" href="#语义高亮指南">语义高亮指南</a></h1>
<hr />
<p>语义高亮是对<a href="language-extensions//language-extensions/syntax-highlight-guide">语法高亮</a>的一种补充。VS Code 的主要分词引擎是 TextMate 语法器。TextMate 使用正则表达式，并根据词法规则将文件分割成一系列的符号。</p>
<p>语言服务器将项目上下文的符号进行解析，使得语义服务器也能提供<strong>符号</strong>的相关信息。主题可以选择性地使用语义符号来提升语法高亮的体验。编辑器使用语义高亮优先于语法高亮。</p>
<p>下面是一个语义高亮的例子：</p>
<p>没有语义高亮：</p>
<p><img src="https://code.visualstudio.com/assets/api/language-extensions/semantic-highlighting/no-semantic-highlighting.png" alt="no-semantic-highlighting" /></p>
<p>有语义高亮：</p>
<p><img src="https://code.visualstudio.com/assets/api/language-extensions/semantic-highlighting/with-semantic-highlighting.png" alt="with-semantic-highlighting" /></p>
<p>注意下列颜色差异：</p>
<ul>
<li>第 10 行：<code>languageMode</code> 被着色为参数</li>
<li>第 11 行：<code>Range</code> 和 <code>Position</code> 被着色为“类”，<code>document</code> 被着色为参数</li>
<li>第 13 行：<code>getFoldingRanges</code> 着色为函数</li>
</ul>
<h2 id="语义分词供应器函数"><a class="header" href="#语义分词供应器函数">语义分词供应器函数</a></h2>
<hr />
<p>要实现语义高亮，插件需要使用文档的语言类型或文件名注册一个 <code>semantic token provider</code>。编辑器发现需要进行语义分词时，会向该供应器发起请求。</p>
<pre><code class="language-typescript">const tokenTypes = ['class', 'interface', 'enum', 'function', 'variable'];
const tokenModifiers = ['declaration', 'documentation'];
const legend = new vscode.SemanticTokensLegend(tokenTypes, tokenModifiers);

const provider: vscode.DocumentSemanticTokensProvider = {
  provideDocumentSemanticTokens(
    document: vscode.TextDocument
  ): vscode.ProviderResult&lt;vscode.SemanticTokens&gt; {
    // 分析文档，并返回语义符号

    const tokensBuilder = new vscode.SemanticTokensBuilder(legend);
    // 第一行的1-5个词，是类型声明
    tokensBuilder.push(
      new vscode.Range(new vscode.Position(1, 1), new vscode.Position(1, 5)),
      'class',
      ['declaration']
    );
    return tokensBuilder.build();
  }
};

const selector = { language: 'java', scheme: 'file' }; // 为所有本地的 Java 文档注册

vscode.languages.registerDocumentSemanticTokensProvider(selector, provider, legend);
</code></pre>
<p>语义分词供应器函数 API 为插件实现提供了两种方式：</p>
<ol>
<li><code>DocumentSemanticTokensProvider</code> - 将整个文档作为输入内容
<ul>
<li><code>provideDocumentSemanticTokens</code> - 为文档提供所有<strong>符号</strong></li>
<li><code>provideDocumentSemanticTokensEdits</code> - 对上次响应提供文档的所有<strong>符号</strong></li>
</ul>
</li>
<li><code>DocumentRangeSemanticTokensProvider</code> - 只作用于局部范围
<ul>
<li><code>provideDocumentRangeSemanticTokens</code> - 为局部文档提供所有<strong>符号</strong></li>
</ul>
</li>
</ol>
<p>每个被供应器函数返回的<strong>符号</strong>都会含有分类信息，分类信息中包含了符号的类型、修改的符号数量、符号的具体语言等。这个信息和 <a href="language-extensions//language-extensions/syntax-highlight-guide">语法高亮</a> 中的 TextMate 作用域生成的信息很像，不过它有自己专属的更干净的分类系统。</p>
<p>就如上例所示，这个供应器命名了类型和具体修改，这些东西随后就会被<code>SemanticTokensLegend</code>使用，<code>provide</code> api 将类型和具体修改作为下标返回给 legend。</p>
<h2 id="语义分词种类"><a class="header" href="#语义分词种类">语义分词种类</a></h2>
<hr />
<p>下面是一些VS Code 预定义的标准<strong>语义符号类型</strong>和<strong>语义符号修饰器</strong></p>
<p>标准类型和修饰器覆盖了很多语言中常见的概念，虽然很多语言都有自己的类型和修饰器术语，但是有了标准分类之后，主题开发者也能够根据这套标准实现跨语言的主题了。</p>
<p>标准语义符号类型：</p>
<div class="table-wrapper"><table><thead><tr><th>Id</th><th>描述</th></tr></thead><tbody>
<tr><td><code>namespace</code></td><td>声明或引用了一个命名空间、模块或包</td></tr>
<tr><td><code>class</code></td><td>声明或引用了一个“类”类型</td></tr>
<tr><td><code>enum</code></td><td>声明或引用了一个枚举类型</td></tr>
<tr><td><code>interface</code></td><td>声明或引用了一个接口类型</td></tr>
<tr><td><code>struct</code></td><td>声明或引用了一个结构类型</td></tr>
<tr><td><code>typeParameter</code></td><td>声明或引用了一个类型参数</td></tr>
<tr><td><code>type</code></td><td>声明或引用了一个未被上述类型提及的其他类型</td></tr>
<tr><td><code>parameter</code></td><td>声明或引用了一个函数或方法的参数</td></tr>
<tr><td><code>variable</code></td><td>声明或引用了一个本地或全局变量</td></tr>
<tr><td><code>property</code></td><td>声明或引用了一个成员属性，成员域或成员变量</td></tr>
<tr><td><code>enumMember</code></td><td>声明或引用了一个可枚举的属性、常量或成员</td></tr>
<tr><td><code>event</code></td><td>声明或引用了一个可枚举的属性</td></tr>
<tr><td><code>function</code></td><td>声明或引用了一个函数</td></tr>
<tr><td><code>method</code></td><td>声明或引用了一个函数或方法</td></tr>
<tr><td><code>macro</code></td><td>声明或引用了一个宏</td></tr>
<tr><td><code>label</code></td><td>声明或引用了一个标签</td></tr>
<tr><td><code>comment</code></td><td>表示注释</td></tr>
<tr><td><code>string</code></td><td>表示字符串字面量</td></tr>
<tr><td><code>keyword</code></td><td>表示语言关键字</td></tr>
<tr><td><code>number</code></td><td>表示数字字面量</td></tr>
<tr><td><code>regexp</code></td><td>表示正则表达式字面量</td></tr>
<tr><td><code>operator</code></td><td>表示操作符</td></tr>
</tbody></table>
</div>
<p>标准语义符号修饰符：</p>
<div class="table-wrapper"><table><thead><tr><th>Id</th><th>描述</th></tr></thead><tbody>
<tr><td><code>declaration</code></td><td>符号的声明</td></tr>
<tr><td><code>definition</code></td><td>符号的定义，比如文件头</td></tr>
<tr><td><code>readonly</code></td><td>只读变量或成员域，或称常量</td></tr>
<tr><td><code>static</code></td><td>类成员中的静态成员对象</td></tr>
<tr><td><code>deprecated</code></td><td>表示不再使用的符号</td></tr>
<tr><td><code>abstract</code></td><td>表示类型或成员方法是抽象的</td></tr>
<tr><td><code>async</code></td><td>被标记为异步的函数</td></tr>
<tr><td><code>modification</code></td><td>被引用变量的原始赋值位置</td></tr>
<tr><td><code>documentation</code></td><td>符号表示文档的位置</td></tr>
<tr><td><code>defaultLibrary</code></td><td>符号表示标准库</td></tr>
</tbody></table>
</div>
<p>必要之时，插件也可以定义新的类型和修饰符，或者通过<code>semanticTokenTypes</code> 和 <code>semanticTokenModifiers</code> 配置点创建现有类型的子类型。</p>
<pre><code class="language-json">{
  &quot;contributes&quot;: {
    &quot;semanticTokenTypes&quot;: [
      {
        &quot;id&quot;: &quot;templateType&quot;,
        &quot;superType&quot;: &quot;type&quot;,
        &quot;description&quot;: &quot;A template type.&quot;
      }
    ],
    &quot;semanticTokenModifiers&quot;: [
      {
        &quot;id&quot;: &quot;native&quot;,
        &quot;description&quot;: &quot;Annotates a symbol that is implemented natively&quot;
      }
    ]
  }
}
</code></pre>
<p>已配置的类型，可以声明它的父级类型，并继承其所有样式规则。</p>
<h2 id="主题化-1"><a class="header" href="#主题化-1">主题化</a></h2>
<hr />
<p>主题化是指将颜色和样式应用到 <strong>符号</strong> 的过程。色彩主题确定了主题化的规则，但是用户也可以通过用户设置来自定义主题规则。</p>
<p>使用 <code>semanticHighlighting</code> 时，色彩主题可以告诉编辑器是否展示<strong>语义符号</strong>。</p>
<p>如果启用的话，语义符号会优先于<code>semanticTokenColors</code>定义的语义符号规则使用：</p>
<pre><code class="language-json">{
  &quot;semanticTokenColors&quot;: {
    &quot;variable.readonly:java&quot;: &quot;#ff0000&quot;
  }
}
</code></pre>
<p><code>variable.readonly:java</code>被称为选择器，它的格式是<code>(*|tokenType)(.tokenModifier)*(:tokenLanguage)?</code></p>
<p>这是一个样式选择器的例子：</p>
<ul>
<li><code>&quot;*.declaration&quot;: { &quot;fontStyle&quot;: &quot;bold&quot; }</code> : 所有声明都标记为粗体</li>
<li><code>&quot;class:java&quot;: { &quot;foreground&quot;: &quot;#00ff00&quot; &quot;fontStyle&quot;: &quot;bold&quot; }</code> ：java 中的类</li>
</ul>
<p>如果没有匹配到任何规则，VS Code 会使用 <a href="language-extensions/semantic-highlight-guide.html#%E8%AF%AD%E4%B9%89%E5%88%86%E8%AF%8D%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%98%A0%E5%B0%84">语义分词作用域映射</a> 将当前语义符号解析为 TextMate 的作用域。然后这个作用域会根据TextMate 主题规则中的 <code>tokenColors</code> 进行匹配。</p>
<h2 id="语义分词作用域映射"><a class="header" href="#语义分词作用域映射">语义分词作用域映射</a></h2>
<hr />
<p>为了使语义高亮在没有任何定义语义规则的主题中能够降级使用，VS Code 维护了一个映射表，将语义符号选择器映射到 TextMate 作用域。</p>
<div class="table-wrapper"><table><thead><tr><th>语义符号选择器</th><th>降级 TextMate Scope</th></tr></thead><tbody>
<tr><td><code>namespace</code></td><td><code>entity.name.namespace</code></td></tr>
<tr><td><code>type</code></td><td><code>entity.name.type</code></td></tr>
<tr><td><code>type.defaultLibrary</code></td><td><code>support.type</code></td></tr>
<tr><td><code>struct</code></td><td><code>storage.type.struct</code></td></tr>
<tr><td><code>class</code></td><td><code>entity.name.type.class</code></td></tr>
<tr><td><code>class.defaultLibrary</code></td><td><code>support.class</code></td></tr>
<tr><td><code>interface</code></td><td><code>entity.name.type.interface</code></td></tr>
<tr><td><code>enum</code></td><td><code>entity.name.type.enum</code></td></tr>
<tr><td><code>function</code></td><td><code>entity.name.function</code></td></tr>
<tr><td><code>function.defaultLibrary</code></td><td><code>support.function</code></td></tr>
<tr><td><code>method</code></td><td><code>entity.name.function.member</code></td></tr>
<tr><td><code>macro</code></td><td><code>entity.name.function.macro</code></td></tr>
<tr><td><code>variable</code></td><td><code>variable.other.readwrite</code> , <code>entity.name.variable</code></td></tr>
<tr><td><code>variable.readonly</code></td><td><code>variable.other.constant</code></td></tr>
<tr><td><code>variable.readonly.defaultLibrary</code></td><td><code>support.constant</code></td></tr>
<tr><td><code>parameter</code></td><td><code>variable.parameter</code></td></tr>
<tr><td><code>property</code></td><td><code>variable.other.property</code></td></tr>
<tr><td><code>property.readonly</code></td><td><code>variable.other.constant.property</code></td></tr>
<tr><td><code>enumMember</code></td><td><code>variable.other.enummember</code></td></tr>
<tr><td><code>event</code></td><td><code>variable.other.event</code></td></tr>
</tbody></table>
</div>
<p>这份表可通过<code>semanticTokenScopes</code>配置点进行扩展。</p>
<p>我们来看两个例子</p>
<ul>
<li>当主题未定义语义符号的主题规则时，插件定义了自定义的符号类型和符号修饰器给 TextMate 作用域作为降级方案。</li>
</ul>
<pre><code class="language-json">{
  &quot;contributes&quot;: {
    &quot;semanticTokenScopes&quot;: [
      {
        &quot;scopes&quot;: {
          &quot;templateType&quot;: [&quot;entity.name.type.template&quot;]
        }
      }
    ]
  }
}
</code></pre>
<ul>
<li>TextMate 的供应器函数可以添加特定语言作用域，这样主题就可以针对特对语言实现具体的主题规则。</li>
</ul>
<pre><code class="language-json">{
  &quot;contributes&quot;: {
    &quot;semanticTokenScopes&quot;: [
      {
        &quot;language&quot;: &quot;typescript&quot;,
        &quot;scopes&quot;: {
          &quot;property.readonly&quot;: [&quot;variable.other.constant.property.ts&quot;]
        }
      }
    ]
  }
}

</code></pre>
<h2 id="试试看"><a class="header" href="#试试看">试试看</a></h2>
<hr />
<p>我们有一份 <a href="https://github.com/microsoft/vscode-extension-samples/tree/master/semantic-tokens-sample">语义符号示例</a> 展示了如何创建一个语义符号供应器函数。</p>
<p><a href="language-extensions//language-extensions/syntax-highlight-guide#%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%A3%80%E6%9F%A5%E5%99%A8">作用域检查器</a> 可以帮你查看一份源文件中展示了哪些语义符号，以及他们应用了什么规则。想要看到语义符号，你可以打开一个 TyepScript 文件，然后使用内置主题（比如 Dark+）。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="代码片段"><a class="header" href="#代码片段">代码片段</a></h1>
<p><a href="language-extensions//extensibility-reference/contribution-points#contributessnippets"><code>contributes.snippets</code></a>配置允许你将<em>代码片段</em>打包进VS Code插件中。</p>
<p><a href="https://code.visualstudio.com/docs/editor/userdefinedsnippets#_creating-your-own-snippets">创建代码片段</a>主题详细介绍了新建代码片段的全部内容。本篇指南只是告诉你关于打包<em>代码片段</em>的大体思路。比较推荐的做法是：</p>
<ul>
<li>用<code>Preferences: Configure User Snippets</code>命令创建和调试代码片段。</li>
<li>如果你觉得满意了，将整个JSON文件复制到插件目录下，起个名字比如说<code>snippets.json</code>文件。</li>
<li>将下列配置添加到你的<code>package.json</code>中</li>
</ul>
<pre><code class="language-json">{
	&quot;contributes&quot;: {
		&quot;snippets&quot;: [
			{
				&quot;language&quot;: &quot;javascript&quot;,
				&quot;path&quot;: &quot;./snippets.json&quot;
			}
		]
	}
}
</code></pre>
<p>本篇的源代码在<a href="https://github.com/Microsoft/vscode-extension-samples/tree/master/snippet-sample">https://github.com/Microsoft/vscode-extension-samples/tree/master/snippet-sample</a></p>
<p>?&gt; 提示：在<code>package.json</code>中添加如下分类，用户才能轻松找到你的插件。</p>
<pre><code class="language-json">{
	&quot;categories&quot;: [&quot;Snippets&quot;]
}
</code></pre>
<h2 id="使用textmate代码片段"><a class="header" href="#使用textmate代码片段">使用TextMate代码片段</a></h2>
<hr />
<p>你也可以用<a href="language-extensions//get-started/your-first-extension">yo code</a>将TextMate代码片段（.tmSnippets）直接添加到插件里去。生成器中的可选项<code>New Code Snippets</code>会帮你指向.tmSnippets的目录，它们最后都会一起打包到VS Code 插件里。生成器甚至还支持Sublime代码片段（.sublime-snippets）。</p>
<p>生成器最终输出的文件有两个：一份插件清单<code>package.json</code>，和一份转换为VS Code代码片段的<code>snippets.json</code>。</p>
<pre><code class="language-bash">.
├── snippets                    // VS Code integration
│   └── snippets.json           // The JSON file w/ the snippets
└── package.json                // extension's manifest
</code></pre>
<p>把生成的代码片段文件夹复制到你的<code>.vscode/extensions</code>下的新文件夹中，然后重启VS Code。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="语言配置"><a class="header" href="#语言配置">语言配置</a></h1>
<p>通过<a href="language-extensions//extensibility-reference/contribution-points#contributeslanguages"><code>contributes.languages</code></a>发布内容配置，你可以配置以下<em>声明式语言特性</em>：</p>
<ul>
<li>启用/关闭注释</li>
<li>定义括号</li>
<li>自动闭合符号</li>
<li>自动环绕符号</li>
<li>代码折叠</li>
<li>单词匹配</li>
<li>缩进规则</li>
</ul>
<p><a href="https://github.com/Microsoft/vscode-extension-samples/tree/master/language-configuration-sample">语言配置示例</a>中配置JavaScript文件中的编辑功能。本篇指南会详细解释<code>language-configuration.json</code>中的内容：</p>
<p>!&gt; <strong>注意</strong>：如果你的语言配置文件以**<code>language-configuration.json</code>**结尾，那么VS Code会帮你添加代码补全和校验功能。</p>
<pre><code class="language-json">{
	&quot;comments&quot;: {
		&quot;lineComment&quot;: &quot;//&quot;,
		&quot;blockComment&quot;: [&quot;/*&quot;, &quot;*/&quot;]
	},
	&quot;brackets&quot;: [[&quot;{&quot;, &quot;}&quot;], [&quot;[&quot;, &quot;]&quot;], [&quot;(&quot;, &quot;)&quot;]],
	&quot;autoClosingPairs&quot;: [
		{ &quot;open&quot;: &quot;{&quot;, &quot;close&quot;: &quot;}&quot; },
		{ &quot;open&quot;: &quot;[&quot;, &quot;close&quot;: &quot;]&quot; },
		{ &quot;open&quot;: &quot;(&quot;, &quot;close&quot;: &quot;)&quot; },
		{ &quot;open&quot;: &quot;'&quot;, &quot;close&quot;: &quot;'&quot;, &quot;notIn&quot;: [&quot;string&quot;, &quot;comment&quot;] },
		{ &quot;open&quot;: &quot;\&quot;&quot;, &quot;close&quot;: &quot;\&quot;&quot;, &quot;notIn&quot;: [&quot;string&quot;] },
		{ &quot;open&quot;: &quot;`&quot;, &quot;close&quot;: &quot;`&quot;, &quot;notIn&quot;: [&quot;string&quot;, &quot;comment&quot;] },
		{ &quot;open&quot;: &quot;/**&quot;, &quot;close&quot;: &quot; */&quot;, &quot;notIn&quot;: [&quot;string&quot;] }
	],
	&quot;autoCloseBefore&quot;: &quot;;:.,=}])&gt;` \n\t&quot;,
	&quot;surroundingPairs&quot;: [
		[&quot;{&quot;, &quot;}&quot;],
		[&quot;[&quot;, &quot;]&quot;],
		[&quot;(&quot;, &quot;)&quot;],
		[&quot;'&quot;, &quot;'&quot;],
		[&quot;\&quot;&quot;, &quot;\&quot;&quot;],
		[&quot;`&quot;, &quot;`&quot;]
	],
	&quot;folding&quot;: {
		&quot;markers&quot;: {
			&quot;start&quot;: &quot;^\\s*//\\s*#?region\\b&quot;,
			&quot;end&quot;: &quot;^\\s*//\\s*#?endregion\\b&quot;
		}
	},
	&quot;wordPattern&quot;: &quot;(-?\\d*\\.\\d\\w*)|([^\\`\\~\\!\\@\\#\\%\\^\\&amp;\\*\\(\\)\\-\\=\\+\\[\\{\\]\\}\\\\\\|\\;\\:\\'\\\&quot;\\,\\.\\&lt;\\&gt;\\/\\?\\s]+)&quot;,
	&quot;indentationRules&quot;: {
		&quot;increaseIndentPattern&quot;: &quot;^((?!\\/\\/).)*(\\{[^}\&quot;'`]*|\\([^)\&quot;'`]*|\\[[^\\]\&quot;'`]*)$&quot;,
		&quot;decreaseIndentPattern&quot;: &quot;^((?!.*?\\/\\*).*\\*/)?\\s*[\\}\\]].*$&quot;
	}
}
</code></pre>
<h2 id="启用关闭注释"><a class="header" href="#启用关闭注释">启用/关闭注释</a></h2>
<hr />
<p>VS Code提供了切换注释开关的命令：</p>
<ul>
<li><strong>Toggle Line Comment</strong></li>
<li><strong>Toggle Block Comment</strong></li>
</ul>
<p>分别来配置<code>comments.lineComment</code>控制块注释和<code>comments.blockComment</code>控制行注释。</p>
<pre><code class="language-json">{
	&quot;comments&quot;: {
		&quot;lineComment&quot;: &quot;//&quot;,
		&quot;blockComment&quot;: [&quot;/*&quot;, &quot;*/&quot;]
	}
}
</code></pre>
<h2 id="定义括号"><a class="header" href="#定义括号">定义括号</a></h2>
<hr />
<p>你在VS Code中将鼠标移动到一个括号边上时，VS Code会自动高亮对应的括号。</p>
<pre><code class="language-json">{
	&quot;brackets&quot;: [[&quot;{&quot;, &quot;}&quot;], [&quot;[&quot;, &quot;]&quot;], [&quot;(&quot;, &quot;)&quot;]]
}
</code></pre>
<p>另外，当你运行<strong>Go to Bracket</strong>或<strong>Select to Bracket</strong>时，VS Code会自动使用你的定义找到最近、最匹配的括号。</p>
<h2 id="自动闭合符号"><a class="header" href="#自动闭合符号">自动闭合符号</a></h2>
<hr />
<p>当你输入<code>'</code>时，VS Code会自动帮你补全另一个单引号然后将光标放在引号中间，我们来看看是怎么做的：</p>
<pre><code class="language-json">{
	&quot;autoClosingPairs&quot;: [
		{ &quot;open&quot;: &quot;{&quot;, &quot;close&quot;: &quot;}&quot; },
		{ &quot;open&quot;: &quot;[&quot;, &quot;close&quot;: &quot;]&quot; },
		{ &quot;open&quot;: &quot;(&quot;, &quot;close&quot;: &quot;)&quot; },
		{ &quot;open&quot;: &quot;'&quot;, &quot;close&quot;: &quot;'&quot;, &quot;notIn&quot;: [&quot;string&quot;, &quot;comment&quot;] },
		{ &quot;open&quot;: &quot;\&quot;&quot;, &quot;close&quot;: &quot;\&quot;&quot;, &quot;notIn&quot;: [&quot;string&quot;] },
		{ &quot;open&quot;: &quot;`&quot;, &quot;close&quot;: &quot;`&quot;, &quot;notIn&quot;: [&quot;string&quot;, &quot;comment&quot;] },
		{ &quot;open&quot;: &quot;/**&quot;, &quot;close&quot;: &quot; */&quot;, &quot;notIn&quot;: [&quot;string&quot;] }
	]
}
</code></pre>
<p>配置<code>notIn</code>键（key）可以在你需要的时候关闭这个功能。比如你在写下面的代码：</p>
<pre><code class="language-javascript">// ES6's Template String
`ES6's Template String`;
</code></pre>
<p>此时单引号就不会闭合。</p>
<p>用户可以使用<code>editor.autoClosingQuotes</code>和<code>editor.autoClosingBrackets</code>设置<em>自动闭合符号</em>的行为。</p>
<h4 id="在xxx前闭合符号"><a class="header" href="#在xxx前闭合符号">在XXX前闭合符号</a></h4>
<p>如果符号的右边有空白，那么VS Code默认会启用符号闭合，所以当你在JSX代码中输入<code>{</code>时，符号并不会闭合：</p>
<pre><code class="language-javascript">const Component = () =&gt;
  &lt;div className={&gt;
                  ^ VS Code默认不会闭合此处的括号
  &lt;/div&gt;
</code></pre>
<p>但是你可以用下面的定义覆盖默认行为：</p>
<pre><code class="language-json">{
	&quot;autoCloseBefore&quot;: &quot;;:.,=}])&gt;` \n\t&quot;
}
</code></pre>
<p>现在如果你在<code>&gt;</code>前面输入<code>{</code>，VS Code会自动补全<code>}</code>。</p>
<h2 id="自动环绕符号"><a class="header" href="#自动环绕符号">自动环绕符号</a></h2>
<hr />
<p>当你选择了一堆文本然后输入左括号时，VS Code会对选中内容外围加上对应的括号。这个功能叫做<em>自动环绕符号</em>，你可以参考下面的代码指定这项功能：</p>
<pre><code class="language-json">{
	&quot;surroundingPairs&quot;: [
		[&quot;{&quot;, &quot;}&quot;],
		[&quot;[&quot;, &quot;]&quot;],
		[&quot;(&quot;, &quot;)&quot;],
		[&quot;'&quot;, &quot;'&quot;],
		[&quot;\&quot;&quot;, &quot;\&quot;&quot;],
		[&quot;`&quot;, &quot;`&quot;]
	]
}
</code></pre>
<p>注意用户可以通过<code>editor.autoSurround</code>设置<em>自动环绕符号</em>的行为。</p>
<h2 id="代码折叠"><a class="header" href="#代码折叠">代码折叠</a></h2>
<hr />
<p>在VS Code中有三种代码折叠类型：</p>
<ul>
<li>缩进折叠：这是VS Code中默认的缩进行为，当两行内容有着相同的缩进级别时，你就可以看到折叠标记了。</li>
<li>语言配置折叠：当VS Code发现<code>folding.markers</code>同时定义了<code>start</code>和<code>end</code>时，对应区域内就会出现折叠标记。下述配置会对<code>//#region</code>和<code>//#endregionJSON</code>区域创建代码折叠标记：</li>
</ul>
<pre><code class="language-json">{
	&quot;folding&quot;: {
		&quot;markers&quot;: {
			&quot;start&quot;: &quot;^\\s*//\\s*#?region\\b&quot;,
			&quot;end&quot;: &quot;^\\s*//\\s*#?endregion\\b&quot;
		}
	}
}
</code></pre>
<ul>
<li>语言服务器折叠：语言服务器获取到<a href="https://microsoft.github.io/language-server-protocol/specification#textDocument_foldingRange">textDocument/foldingRange</a>请求中的代码折叠列表数据，VS Code之后根据这份列表创建折叠标记。通过语言服务器协议学习更多关于<a href="language-extensions//language-extensions/programmatic-language-features">程序性语言特性</a>。</li>
</ul>
<h2 id="单词匹配"><a class="header" href="#单词匹配">单词匹配</a></h2>
<hr />
<p><code>wordPattern</code>定义了程序语言中<em>单词</em>单位。因此当你使用词语相关的命令，如：<strong>Move cursor to word start</strong>（<kbd>Ctrl+Left</kbd>）或者<strong>Move cursor to word end</strong>（<kbd>Ctrl+Right</kbd>）时，编辑器会根据正则寻找单词边界。</p>
<pre><code class="language-json">{
	&quot;wordPattern&quot;: &quot;(-?\\d*\\.\\d\\w*)|([^\\`\\~\\!\\@\\#\\%\\^\\&amp;\\*\\(\\)\\-\\=\\+\\[\\{\\]\\}\\\\\\|\\;\\:\\'\\\&quot;\\,\\.\\&lt;\\&gt;\\/\\?\\s]+)&quot;
}
</code></pre>
<h2 id="缩进规则"><a class="header" href="#缩进规则">缩进规则</a></h2>
<hr />
<p><code>indentationRules</code>定义了编辑器应该如何调整当前行或你粘贴、输入、移动的下一行缩进。</p>
<pre><code class="language-json">{
	&quot;indentationRules&quot;: {
		&quot;increaseIndentPattern&quot;: &quot;^((?!\\/\\/).)*(\\{[^}\&quot;'`]*|\\([^)\&quot;'`]*|\\[[^\\]\&quot;'`]*)$&quot;,
		&quot;decreaseIndentPattern&quot;: &quot;^((?!.*?\\/\\*).*\\*/)?\\s*[\\)\\}\\]].*$&quot;
	}
}
</code></pre>
<p>比如，<code>if (true) {</code>匹配<code>increasedIndentPattern</code>，然后如果你在<code>{</code>后面按下<kbd>Enter</kbd>后，编辑器会自动缩进一次，你如代码看起来会像这样：</p>
<pre><code class="language-javascript">if (true) {
	console.log();
</code></pre>
<p>如果没有设置缩进规则，当行尾以开符号结尾时编辑器会左缩进，以闭合符号结尾时右缩进。这里的<em>开闭符号</em>由<code>brackets</code>定义。</p>
<p>注意<code>editor.formatOnPaste</code>是由<a href="https://code.visualstudio.com/api/references/vscode-api#DocumentRangeFormattingEditProvider">DocumentRangeFormattingEditProvider</a>控制，而不由自动缩进控制。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="程序性语言特性"><a class="header" href="#程序性语言特性">程序性语言特性</a></h1>
<p>程序性语言特性是由<a href="https://code.visualstudio.com/api/references/vscode-api#languages"><code>vscode.languages.*</code></a>API提供的一系列智能编辑功能。在VS Code中有两种实现动态语言特性的途径。我们先以<a href="language-extensions/programmatic-language-features.html#%E6%98%BE%E7%A4%BA%E6%82%AC%E6%B5%AE%E6%8F%90%E7%A4%BA">悬停提示</a>为例：</p>
<pre><code class="language-typescript">vscode.languages.registerHoverProvider('javascript', {
	provideHover(document, position, token) {
		return {
			contents: ['Hover Content']
		};
	}
});
</code></pre>
<p>正如你所见，代码中<a href="https://code.visualstudio.com/api/references/vscode-api#languages.registerHoverProvider"><code>vscode.languages.registerHoverProvider</code></a>API可以很方便地在JS文件中提供悬停提示的内容。这个插件激活后，只要你悬停到了JS代码上，VS Code就会查询全部对JS注册了的<a href="https://code.visualstudio.com/api/references/vscode-api#HoverProvider"><code>HoverProvider</code></a>然后在悬浮提示框中显示对应内容。你可以查看下面的<a href="language-extensions/programmatic-language-features.html#%E8%AF%AD%E8%A8%80%E5%8A%9F%E8%83%BD%E5%88%97%E8%A1%A8">语言功能列表</a>，里面包含了VS Code API / LSP实现的语言功能。</p>
<p>那么一种实现就是使用了<a href="https://microsoft.github.io/language-server-protocol/">语言服务器协议</a>的语言服务器。它的实现方式如下：</p>
<ul>
<li>一个为JS同时提供语言客户端和语言服务器的插件</li>
<li>语言客户端就像普通插件一样，运行于Node.js插件主机环境中。这个插件激活后，会启动另一个进程——语言服务器，然后两者通过<a href="https://microsoft.github.io/language-server-protocol/">语言服务器协议</a>进行通信。</li>
<li>你悬停到JS代码上</li>
<li>VS Code通知语言客户端</li>
<li>语言客户端向语言服务器发起请求，索要悬停的返回结果，最后再送回给VS Code</li>
<li>VS Code将结果展示在悬浮框中</li>
</ul>
<p>这个过程可能看起来有些复杂，但是这么做主要有两个好处：</p>
<ul>
<li>语言服务器可以用任何语言实现</li>
<li>语言服务器可以被多个编辑器重用，提供更加智能的编辑体验</li>
</ul>
<p>深入指南，请移步至<a href="language-extensions//language-extensions/language-server-extension-guide">语言服务器插件指南</a></p>
<h2 id="语言功能列表"><a class="header" href="#语言功能列表">语言功能列表</a></h2>
<hr />
<div class="table-wrapper"><table><thead><tr><th>VS Code API</th><th>LSP method</th></tr></thead><tbody>
<tr><td><a href="https://code.visualstudio.com/api/references/vscode-api#languages.createDiagnosticCollection"><code>createDiagnosticCollection</code></a></td><td><a href="https://microsoft.github.io/language-server-protocol/specification#textDocument_publishDiagnostics">PublishDiagnostics</a></td></tr>
<tr><td><a href="https://code.visualstudio.com/api/references/vscode-api#languages.registerCompletionItemProvider"><code>registerCompletionItemProvider</code></a></td><td><a href="https://microsoft.github.io/language-server-protocol/specification#textDocument_completion">Completion</a> &amp; <a href="https://microsoft.github.io/language-server-protocol/specification#completionItem_resolve">Completion Resolve</a></td></tr>
<tr><td><a href="https://code.visualstudio.com/api/references/vscode-api#languages.registerHoverProvider"><code>registerHoverProvider</code></a></td><td><a href="https://microsoft.github.io/language-server-protocol/specification#textDocument_hover">Hover</a></td></tr>
<tr><td><a href="https://code.visualstudio.com/api/references/vscode-api#languages.registerSignatureHelpProvider"><code>registerSignatureHelpProvider</code></a></td><td><a href="https://microsoft.github.io/language-server-protocol/specification#textDocument_signatureHelp">SignatureHelp</a></td></tr>
<tr><td><a href="https://code.visualstudio.com/api/references/vscode-api#languages.registerDefinitionProvider"><code>registerDefinitionProvider</code></a></td><td><a href="https://microsoft.github.io/language-server-protocol/specification#textDocument_definition">Definition</a></td></tr>
<tr><td><a href="https://code.visualstudio.com/api/references/vscode-api#languages.registerTypeDefinitionProvider"><code>registerTypeDefinitionProvider</code></a></td><td><a href="https://microsoft.github.io/language-server-protocol/specification#textDocument_typeDefinition">TypeDefinition</a></td></tr>
<tr><td><a href="https://code.visualstudio.com/api/references/vscode-api#languages.registerImplementationProvider"><code>registerImplementationProvider</code></a></td><td><a href="https://microsoft.github.io/language-server-protocol/specification#textDocument_implementation">Implementation</a></td></tr>
<tr><td><a href="https://code.visualstudio.com/api/references/vscode-api#languages.registerReferenceProvider"><code>registerReferenceProvider</code></a></td><td><a href="https://microsoft.github.io/language-server-protocol/specification#textDocument_references">References</a></td></tr>
<tr><td><a href="https://code.visualstudio.com/api/references/vscode-api#languages.registerDocumentHighlightProvider"><code>registerDocumentHighlightProvider</code></a></td><td><a href="https://microsoft.github.io/language-server-protocol/specification#textDocument_documentHighlight">DocumentHighlight</a></td></tr>
<tr><td><a href="https://code.visualstudio.com/api/references/vscode-api#languages.registerDocumentSymbolProvider"><code>registerDocumentSymbolProvider</code></a></td><td><a href="https://microsoft.github.io/language-server-protocol/specification#textDocument_documentSymbol">DocumentSymbol</a></td></tr>
<tr><td><a href="https://code.visualstudio.com/api/references/vscode-api#languages.registerCodeActionsProvider"><code>registerCodeActionsProvider</code></a></td><td><a href="https://microsoft.github.io/language-server-protocol/specification#textDocument_codeAction">CodeAction</a></td></tr>
<tr><td><a href="https://code.visualstudio.com/api/references/vscode-api#languages.registerCodeLensProvider"><code>registerCodeLensProvider</code></a></td><td><a href="https://microsoft.github.io/language-server-protocol/specification#textDocument_codeLens">CodeLens</a> &amp; <a href="https://microsoft.github.io/language-server-protocol/specification#codeLens_resolve">CodeLens Resolve</a></td></tr>
<tr><td><a href="https://code.visualstudio.com/api/references/vscode-api#languages.registerDocumentLinkProvider"><code>registerDocumentLinkProvider</code></a></td><td><a href="https://microsoft.github.io/language-server-protocol/specification#textDocument_documentLink">DocumentLink</a> &amp; <a href="https://microsoft.github.io/language-server-protocol/specification#documentLink_resolve">DocumentLink</a></td></tr>
<tr><td><a href="https://code.visualstudio.com/api/references/vscode-api#languages.registerDocumentColorProvider"><code>registerColorProvider</code></a></td><td><a href="https://microsoft.github.io/language-server-protocol/specification#textDocument_documentColor">DocumentColor</a> &amp; <a href="https://microsoft.github.io/language-server-protocol/specification#textDocument_colorPresentation">Color Presentation</a></td></tr>
<tr><td><a href="https://code.visualstudio.com/api/references/vscode-api#languages.registerDocumentFormattingEditProvider"><code>registerDocumentFormattingEditProvider</code></a></td><td><a href="https://microsoft.github.io/language-server-protocol/specification#textDocument_formatting">Formatting</a></td></tr>
<tr><td><a href="https://code.visualstudio.com/api/references/vscode-api#languages.registerDocumentRangeFormattingEditProvider"><code>registerDocumentRangeFormattingEditProvider</code></a></td><td><a href="https://microsoft.github.io/language-server-protocol/specification#textDocument_rangeFormatting">RangeFormatting</a></td></tr>
<tr><td><a href="https://code.visualstudio.com/api/references/vscode-api#languages.registerOnTypeFormattingEditProvider"><code>registerOnTypeFormattingEditProvider</code></a></td><td><a href="https://microsoft.github.io/language-server-protocol/specification#textDocument_onTypeFormatting">OnTypeFormatting</a></td></tr>
<tr><td><a href="https://code.visualstudio.com/api/references/vscode-api#languages.registerRenameProvider"><code>registerRenameProvider</code></a></td><td><a href="https://microsoft.github.io/language-server-protocol/specification#textDocument_rename">Rename</a> &amp; <a href="https://microsoft.github.io/language-server-protocol/specification#textDocument_prepareRename">Prepare Rename</a></td></tr>
<tr><td><a href="https://code.visualstudio.com/api/references/vscode-api#languages.registerFoldingRangeProvider"><code>registerFoldingRangeProvider</code></a></td><td><a href="https://microsoft.github.io/language-server-protocol/specification#textDocument_foldingRange">FoldingRange</a></td></tr>
</tbody></table>
</div>
<h2 id="提供诊断信息"><a class="header" href="#提供诊断信息">提供诊断信息</a></h2>
<hr />
<p>诊断信息是提示代码问题的一种方式。</p>
<p><img src="https://media.githubusercontent.com/media/Microsoft/vscode-docs/master/api/language-extensions/images/language-support/diagnostics.gif" alt="diagnostics" /></p>
<h5 id="语言服务器协议"><a class="header" href="#语言服务器协议">语言服务器协议</a></h5>
<p>语言服务器需要向客户端发送<code>textDocument/publishDiagnostics</code>信息，这个信息中包含了诊断信息url的数组。</p>
<p>!&gt; **注意：**客户端不会主动向服务端请求信息，需要服务器将诊断信息推送到客户端。</p>
<h5 id="直接实现"><a class="header" href="#直接实现">直接实现</a></h5>
<pre><code class="language-typescript">let diagnosticCollection: vscode.DiagnosticCollection;

export function activate(ctx: vscode.ExtensionContext): void {
  ...
  ctx.subscriptions.push(getDisposable());
  diagnosticCollection = vscode.languages.createDiagnosticCollection('go');
  ctx.subscriptions.push(diagnosticCollection);
  ...
}

function onChange() {
  let uri = document.uri;
  check(uri.fsPath, goConfig).then(errors =&gt; {
    diagnosticCollection.clear();
    let diagnosticMap: Map&lt;string, vscode.Diagnostic[]&gt; = new Map();
    errors.forEach(error =&gt; {
      let canonicalFile = vscode.Uri.file(error.file).toString();
      let range = new vscode.Range(error.line-1, error.startColumn, error.line-1, error.endColumn);
      let diagnostics = diagnosticMap.get(canonicalFile);
      if (!diagnostics) { diagnostics = []; }
      diagnostics.push(new vscode.Diagnostic(range, error.msg, error.severity));
      diagnosticMap.set(canonicalFile, diagnostics);
    });
    diagnosticMap.forEach((diags, file) =&gt; {
      diagnosticCollection.set(vscode.Uri.parse(file), diags);
    });
  })
}
</code></pre>
<blockquote>
<p><strong>基础实现</strong></p>
<p>只对打开的编辑器提供诊断，保证至少在每次保存文件时诊断一次。诊断信息最好能随编辑器的文档内容变化触发。</p>
</blockquote>
<blockquote>
<p><strong>进阶实现</strong></p>
<p>不仅仅为打开的编辑器提供诊断，而是诊断当前打开的文件目录中的所有资源，不论文件是被打开还是关闭。</p>
</blockquote>
<h2 id="提供补全建议"><a class="header" href="#提供补全建议">提供补全建议</a></h2>
<hr />
<p>代码补全可以给用户提供内容感知建议。</p>
<p><img src="https://media.githubusercontent.com/media/Microsoft/vscode-docs/master/api/language-extensions/images/language-support/code-completion.gif" alt="code-completion" /></p>
<h5 id="语言服务器协议-1"><a class="header" href="#语言服务器协议-1">语言服务器协议</a></h5>
<p>在接收响应的<code>initialize</code>方法中，你的语言服务器需要声明它是否能提供补全，以及它是否支持动态计算补全项的<code>completionItem\resolve</code>方法。</p>
<pre><code class="language-json">{
    ...
    &quot;capabilities&quot; : {
        &quot;completionProvider&quot; : {
            &quot;resolveProvider&quot;: &quot;true&quot;,
            &quot;triggerCharacters&quot;: [ '.' ]
        }
        ...
    }
}
</code></pre>
<h5 id="直接实现-1"><a class="header" href="#直接实现-1">直接实现</a></h5>
<pre><code class="language-typescript">class GoCompletionItemProvider implements vscode.CompletionItemProvider {
    public provideCompletionItems(
        document: vscode.TextDocument, position: vscode.Position, token: vscode.CancellationToken):
        Thenable&lt;vscode.CompletionItem[]&gt; {
    ...
    }
}

export function activate(ctx: vscode.ExtensionContext): void {
    ...
    ctx.subscriptions.push(getDisposable());
    ctx.subscriptions.push(
        vscode.languages.registerCompletionItemProvider(
            GO_MODE, new GoCompletionItemProvider(), '.', '\&quot;'));
    ...
}
</code></pre>
<blockquote>
<p><strong>基础实现</strong></p>
<p>不支持本功能</p>
</blockquote>
<blockquote>
<p><strong>进阶实现</strong></p>
<p>当用户挑选补全项时，动态计算补全项的相关信息，这条信息会浮现在补全项旁边。</p>
</blockquote>
<h2 id="显示悬浮提示"><a class="header" href="#显示悬浮提示">显示悬浮提示</a></h2>
<hr />
<p>悬浮信息会展示在鼠标光标的下方，为用户提供符号/对象的相关信息，一般展示关于符号的类型和描述。</p>
<p><img src="https://media.githubusercontent.com/media/Microsoft/vscode-docs/master/api/language-extensions/images/language-support/hovers.gif" alt="hovers" /></p>
<h5 id="语言服务器协议-2"><a class="header" href="#语言服务器协议-2">语言服务器协议</a></h5>
<p>为了响应请求<code>initialize</code>方法，语言服务器需要声明它能提供这项功能。</p>
<pre><code class="language-json">{
    ...
    &quot;capabilities&quot; : {
        &quot;hoverProvider&quot; : &quot;true&quot;,
        ...
    }
}
</code></pre>
<p>另外，你的语言服务器还要能够响应<code>textDocument/hover</code>请求。</p>
<h5 id="直接实现-2"><a class="header" href="#直接实现-2">直接实现</a></h5>
<pre><code class="language-typescript">class GoHoverProvider implements HoverProvider {
    public provideHover(
        document: TextDocument, position: Position, token: CancellationToken):
        Thenable&lt;Hover&gt; {
    ...
    }
}

export function activate(ctx: vscode.ExtensionContext): void {
    ...
    ctx.subscriptions.push(
        vscode.languages.registerHoverProvider(
            GO_MODE, new GoHoverProvider()));
    ...
}
</code></pre>
<blockquote>
<p><strong>基础实现</strong>
显示符号的类型和相关文档描述。</p>
</blockquote>
<blockquote>
<p><strong>进阶实现</strong>
对方法名进行着色，就像你的源码一样</p>
</blockquote>
<h2 id="函数和方法签名"><a class="header" href="#函数和方法签名">函数和方法签名</a></h2>
<hr />
<p>当用户输入函数和方法时，显示调用该方法的相关信息。</p>
<p><img src="https://media.githubusercontent.com/media/Microsoft/vscode-docs/master/api/language-extensions/images/language-support/signature-help.gif" alt="signature-help" /></p>
<h5 id="语言服务器协议-3"><a class="header" href="#语言服务器协议-3">语言服务器协议</a></h5>
<p>为了响应请求<code>initialize</code>方法，语言服务器需要声明它能提供这项功能。</p>
<pre><code class="language-json">{
    ...
    &quot;capabilities&quot; : {
        &quot;signatureHelpProvider&quot; : {
            &quot;triggerCharacters&quot;: [ '(' ]
        }
        ...
    }
}
</code></pre>
<p>另外，你的语言服务器还要能够响应<code>textDocument/signatureHelp</code>请求。</p>
<h5 id="直接实现-3"><a class="header" href="#直接实现-3">直接实现</a></h5>
<pre><code class="language-typescript">class GoSignatureHelpProvider implements SignatureHelpProvider {
    public provideSignatureHelp(
        document: TextDocument, position: Position, token: CancellationToken):
        Promise&lt;SignatureHelp&gt; {
    ...
    }
}

export function activate(ctx: vscode.ExtensionContext): void {
    ...
    ctx.subscriptions.push(
        vscode.languages.registerSignatureHelpProvider(
            GO_MODE, new GoSignatureHelpProvider(), '(', ','));
    ...
}
</code></pre>
<blockquote>
<p><strong>基础实现</strong></p>
<p>签名帮助需要包含参数的相关文档。</p>
</blockquote>
<blockquote>
<p><strong>进阶实现</strong></p>
<p>无</p>
</blockquote>
<h2 id="符号定义"><a class="header" href="#符号定义">符号定义</a></h2>
<hr />
<p>允许用户查看变量/函数/方法的定义。</p>
<p><img src="https://media.githubusercontent.com/media/Microsoft/vscode-docs/master/api/language-extensions/images/language-support/goto-definition.gif" alt="goto-definition" /></p>
<h5 id="语言服务器协议-4"><a class="header" href="#语言服务器协议-4">语言服务器协议</a></h5>
<p>为了响应请求<code>initialize</code>方法，语言服务器需要声明它能提供这项功能。</p>
<pre><code class="language-json">{
    ...
    &quot;capabilities&quot; : {
        &quot;definitionProvider&quot; : &quot;true&quot;
        ...
    }
}
</code></pre>
<p>另外，你的语言服务器还要能够响应<code>textDocument/definition</code>请求。</p>
<h5 id="直接实现-4"><a class="header" href="#直接实现-4">直接实现</a></h5>
<pre><code class="language-typescript">lass GoDefinitionProvider implements vscode.DefinitionProvider {
    public provideDefinition(
        document: vscode.TextDocument, position: vscode.Position, token: vscode.CancellationToken):
        Thenable&lt;vscode.Location&gt; {
    ...
    }
}

export function activate(ctx: vscode.ExtensionContext): void {
    ...
    ctx.subscriptions.push(
        vscode.languages.registerDefinitionProvider(
            GO_MODE, new GoDefinitionProvider()));
    ...
}
</code></pre>
<blockquote>
<p><strong>基础实现</strong></p>
<p>如果符号有多个定义，你可以显示多条定义。</p>
</blockquote>
<blockquote>
<p><strong>进阶实现</strong></p>
<p>无</p>
</blockquote>
<h2 id="查找符号的全部引用"><a class="header" href="#查找符号的全部引用">查找符号的全部引用</a></h2>
<hr />
<p>允许用户在当前编辑器直接查看变量/函数/方法的定义的源代码。</p>
<p><img src="https://media.githubusercontent.com/media/Microsoft/vscode-docs/master/api/language-extensions/images/language-support/find-references.gif" alt="find-references" /></p>
<h5 id="语言服务器协议-5"><a class="header" href="#语言服务器协议-5">语言服务器协议</a></h5>
<p>为了响应请求<code>initialize</code>方法，语言服务器需要声明它能提供这项功能。</p>
<pre><code class="language-json">{
    ...
    &quot;capabilities&quot; : {
        &quot;referencesProvider&quot; : &quot;true&quot;
        ...
    }
}
</code></pre>
<p>另外，你的语言服务器还要能够响应<code>textDocument/references</code>请求。</p>
<h5 id="直接实现-5"><a class="header" href="#直接实现-5">直接实现</a></h5>
<pre><code class="language-typescript">class GoReferenceProvider implements vscode.ReferenceProvider {
    public provideReferences(
        document: vscode.TextDocument, position: vscode.Position,
        options: { includeDeclaration: boolean }, token: vscode.CancellationToken):
        Thenable&lt;vscode.Location[]&gt; {
    ...
    }
}

export function activate(ctx: vscode.ExtensionContext): void {
    ...
    ctx.subscriptions.push(
        vscode.languages.registerReferenceProvider(
            GO_MODE, new GoReferenceProvider()));
    ...
}
</code></pre>
<blockquote>
<p><strong>基础实现</strong></p>
<p>为所有引用返回引用位置（资源的url和范围）</p>
</blockquote>
<blockquote>
<p><strong>进阶实现</strong></p>
<p>无</p>
</blockquote>
<h2 id="高亮匹配符号"><a class="header" href="#高亮匹配符号">高亮匹配符号</a></h2>
<hr />
<p>允许用户在打开的编辑器中查看某个符号的全部匹配项。</p>
<p><img src="https://media.githubusercontent.com/media/Microsoft/vscode-docs/master/api/language-extensions/images/language-support/document-highlights.gif" alt="document-highlights" /></p>
<h5 id="语言服务器协议-6"><a class="header" href="#语言服务器协议-6">语言服务器协议</a></h5>
<p>为了响应请求<code>initialize</code>方法，语言服务器需要声明它能提供这项功能。</p>
<pre><code class="language-json">{
    ...
    &quot;capabilities&quot; : {
        &quot;documentHighlightProvider&quot; : &quot;true&quot;
        ...
    }
}
</code></pre>
<p>另外，你的语言服务器还要能够响应<code>textDocument/documentHighlight</code>请求。</p>
<h5 id="直接实现-6"><a class="header" href="#直接实现-6">直接实现</a></h5>
<pre><code class="language-typescript">class GoDocumentHighlightProvider implements vscode.DocumentHighlightProvider {
    public provideDocumentHighlights(
        document: vscode.TextDocument, position: vscode.Position, token: vscode.CancellationToken):
        vscode.DocumentHighlight[] | Thenable&lt;vscode.DocumentHighlight[]&gt;;
    ...
    }
}

export function activate(ctx: vscode.ExtensionContext): void {
    ...
    ctx.subscriptions.push(
        vscode.languages.registerDocumentHighlightProvider(
            GO_MODE, new GoDocumentHighlightProvider()));
    ...
}
</code></pre>
<blockquote>
<p><strong>基础实现</strong></p>
<p>返回引用文档</p>
</blockquote>
<blockquote>
<p><strong>进阶实现</strong></p>
<p>无</p>
</blockquote>
<h2 id="显示当前文档中的符号定义"><a class="header" href="#显示当前文档中的符号定义">显示当前文档中的符号定义</a></h2>
<hr />
<p>允许用户在打开的编辑器中快速跳转到任何符号定义。</p>
<p><img src="https://media.githubusercontent.com/media/Microsoft/vscode-docs/master/api/language-extensions/images/language-support/document-symbols.gif" alt="document-symbols" /></p>
<h5 id="语言服务器协议-7"><a class="header" href="#语言服务器协议-7">语言服务器协议</a></h5>
<p>为了响应请求<code>initialize</code>方法，语言服务器需要声明它能提供这项功能。</p>
<pre><code class="language-json">{
    ...
    &quot;capabilities&quot; : {
        &quot;documentSymbolProvider&quot; : &quot;true&quot;
        ...
    }
}
</code></pre>
<p>另外，你的语言服务器还要能够响应<code>textDocument/documentSymbol</code>请求。</p>
<h5 id="直接实现-7"><a class="header" href="#直接实现-7">直接实现</a></h5>
<pre><code class="language-typescript">class GoDocumentSymbolProvider implements vscode.DocumentSymbolProvider {
    public provideDocumentSymbols(
        document: vscode.TextDocument, token: vscode.CancellationToken):
        Thenable&lt;vscode.SymbolInformation[]&gt; {
    ...
    }
}

export function activate(ctx: vscode.ExtensionContext): void {
    ...
    ctx.subscriptions.push(
        vscode.languages.registerDocumentSymbolProvider(
            GO_MODE, new GoDocumentSymbolProvider()));
    ...
}
</code></pre>
<blockquote>
<p><strong>基础实现</strong></p>
<p>返回文档中的所有符号。将符号分类，如变量、函数、类、方法等。</p>
</blockquote>
<blockquote>
<p><strong>进阶实现</strong></p>
<p>无</p>
</blockquote>
<h2 id="显示文件夹中的符号定义"><a class="header" href="#显示文件夹中的符号定义">显示文件夹中的符号定义</a></h2>
<hr />
<p>允许用户在打开的文件夹（工作区）中快速跳转到任何符号定义。</p>
<p><img src="https://media.githubusercontent.com/media/Microsoft/vscode-docs/master/api/language-extensions/images/language-support/workspace-symbols.gif" alt="workspace-symbols" /></p>
<h5 id="语言服务器协议-8"><a class="header" href="#语言服务器协议-8">语言服务器协议</a></h5>
<p>为了响应请求<code>initialize</code>方法，语言服务器需要声明它能提供这项功能。</p>
<pre><code class="language-json">{
    ...
    &quot;capabilities&quot; : {
        &quot;workspaceSymbolProvider&quot; : &quot;true&quot;
        ...
    }
}
</code></pre>
<p>另外，你的语言服务器还要能够响应<code>workspace/symbol</code>请求。</p>
<h5 id="直接实现-8"><a class="header" href="#直接实现-8">直接实现</a></h5>
<pre><code class="language-typescript">class GoWorkspaceSymbolProvider implements vscode.WorkspaceSymbolProvider {
    public provideWorkspaceSymbols(
        query: string, token: vscode.CancellationToken):
        Thenable&lt;vscode.SymbolInformation[]&gt; {
    ...
    }
}

export function activate(ctx: vscode.ExtensionContext): void {
    ...
    ctx.subscriptions.push(
        vscode.languages.registerWorkspaceSymbolProvider(
            new GoWorkspaceSymbolProvider()));
    ...
}
</code></pre>
<blockquote>
<p><strong>基础实现</strong></p>
<p>返回文件夹中所有匹配的符号。将符号分类，如变量、函数、类、方法等。</p>
</blockquote>
<blockquote>
<p><strong>进阶实现</strong></p>
<p>无</p>
</blockquote>
<h2 id="处理错误和警告"><a class="header" href="#处理错误和警告">处理错误和警告</a></h2>
<hr />
<p>为用户提供处理错误和警告的办法。如果有更正操作可用，就会在那个错误边上显示一个小灯泡。当用户点击灯泡的时候，会显示出操作列表。</p>
<p><img src="https://media.githubusercontent.com/media/Microsoft/vscode-docs/master/api/language-extensions/images/language-support/quick-fixes.gif" alt="quick-fixes" /></p>
<h5 id="语言服务器协议-9"><a class="header" href="#语言服务器协议-9">语言服务器协议</a></h5>
<p>为了响应请求<code>initialize</code>方法，语言服务器需要声明它能提供这项功能。</p>
<pre><code class="language-json">{
    ...
    &quot;capabilities&quot; : {
        &quot;codeActionProvider&quot; : &quot;true&quot;
        ...
    }
}
</code></pre>
<p>另外，你的语言服务器还要能够响应<code>textDocument/codeAction</code>请求。</p>
<h5 id="直接实现-9"><a class="header" href="#直接实现-9">直接实现</a></h5>
<pre><code class="language-typescript">class GoCodeActionProvider implements vscode.CodeActionProvider {
    public provideCodeActions(
        document: vscode.TextDocument, range: vscode.Range,
        context: vscode.CodeActionContext, token: vscode.CancellationToken):
        Thenable&lt;vscode.Command[]&gt; {
    ...
    }
}

export function activate(ctx: vscode.ExtensionContext): void {
    ...
    ctx.subscriptions.push(
        vscode.languages.registerCodeActionsProvider(
            GO_MODE, new GoCodeActionProvider()));
    ...
}
</code></pre>
<blockquote>
<p><strong>基础实现</strong></p>
<p>为错误/警告提供更正操作。</p>
</blockquote>
<blockquote>
<p><strong>进阶实现</strong></p>
<p>提供源码级别的操作，如重构、提取方法等。</p>
</blockquote>
<h2 id="codelens---为源代码提供更多操作"><a class="header" href="#codelens---为源代码提供更多操作">CodeLens - 为源代码提供更多操作</a></h2>
<hr />
<p>为用户弹出一个可以操作、包含上下文信息的分隔弹出框。</p>
<p><img src="https://media.githubusercontent.com/media/Microsoft/vscode-docs/master/api/language-extensions/images/language-support/code-lens.gif" alt="code-lens" /></p>
<h5 id="语言服务器协议-10"><a class="header" href="#语言服务器协议-10">语言服务器协议</a></h5>
<p>为了响应请求<code>initialize</code>方法，语言服务器需要声明它能提供这项功能，以及它是否支持将<code>codeLens\resolve</code>方法绑定到CodeLens的命令上。</p>
<pre><code class="language-json">{
    ...
    &quot;capabilities&quot; : {
        &quot;codeLensProvider&quot; : {
            &quot;resolveProvider&quot;: &quot;true&quot;
        }
        ...
    }
}
</code></pre>
<p>另外，你的语言服务器还要能够响应<code>textDocument/codeLens</code>请求。</p>
<h5 id="直接实现-10"><a class="header" href="#直接实现-10">直接实现</a></h5>
<pre><code class="language-typescript">class GoCodeLensProvider implements vscode.CodeLensProvider {
    public provideCodeLenses(document: TextDocument, token: CancellationToken):
        CodeLens[] | Thenable&lt;CodeLens[]&gt; {
    ...
    }

    public resolveCodeLens?(codeLens: CodeLens, token: CancellationToken):
         CodeLens | Thenable&lt;CodeLens&gt; {
    ...
    }
}

export function activate(ctx: vscode.ExtensionContext): void {
    ...
    ctx.subscriptions.push(
        vscode.languages.registerCodeLensProvider(
            GO_MODE, new GoCodeLensProvider()));
    ...
}
</code></pre>
<blockquote>
<p><strong>基础实现</strong></p>
<p>为文档提供CodeLens结果。</p>
</blockquote>
<blockquote>
<p><strong>进阶实现</strong></p>
<p>将Codelens结果绑定到响应<code>codeLens/resolve</code>的命令上。</p>
</blockquote>
<h2 id="颜色拾取器"><a class="header" href="#颜色拾取器">颜色拾取器</a></h2>
<hr />
<p>允许用户在文件中预览和修改颜色。</p>
<p><img src="https://media.githubusercontent.com/media/Microsoft/vscode-docs/master/api/language-extensions/images/language-support/color-decorators.png" alt="color-decorators" /></p>
<h5 id="语言服务器协议-11"><a class="header" href="#语言服务器协议-11">语言服务器协议</a></h5>
<p>为了响应请求<code>initialize</code>方法，语言服务器需要声明它能提供这项功能。</p>
<pre><code class="language-json">{
    ...
    &quot;capabilities&quot; : {
        &quot;colorProvider&quot; : &quot;true&quot;
        ...
    }
}
</code></pre>
<p>另外，你的语言服务器还要能够响应<code>textDocument/documentColor</code>和<code>textDocument/colorPresentation</code>请求。</p>
<h5 id="直接实现-11"><a class="header" href="#直接实现-11">直接实现</a></h5>
<pre><code class="language-typescript">class GoColorProvider implements vscode.DocumentColorProvider {
    public provideDocumentColors(
        document: vscode.TextDocument, token: vscode.CancellationToken):
        Thenable&lt;vscode.ColorInformation[]&gt; {
    ...
    }
    public provideColorPresentations(
        color: Color, context: { document: TextDocument, range: Range }, token: vscode.CancellationToken):
        Thenable&lt;vscode.ColorPresentation[]&gt; {
    ...
    }
}

export function activate(ctx: vscode.ExtensionContext): void {
    ...
    ctx.subscriptions.push(
        vscode.languages.registerColorProvider(
            GO_MODE, new GoColorProvider()));
    ...
}
</code></pre>
<blockquote>
<p><strong>基础实现</strong></p>
<p>返回文档中的全部颜色引用。在颜色面板岁支持色彩格式（如rgb(...)，hsl(...)）</p>
</blockquote>
<blockquote>
<p><strong>进阶实现</strong></p>
<p>无</p>
</blockquote>
<h2 id="格式化代码"><a class="header" href="#格式化代码">格式化代码</a></h2>
<hr />
<p>提供整个文档的代码格式化支持。</p>
<p><img src="https://media.githubusercontent.com/media/Microsoft/vscode-docs/master/api/language-extensions/images/language-support/format-document.gif" alt="format-document" /></p>
<h5 id="语言服务器协议-12"><a class="header" href="#语言服务器协议-12">语言服务器协议</a></h5>
<p>为了响应请求<code>initialize</code>方法，语言服务器需要声明它能提供这项功能。</p>
<pre><code class="language-json">{
    ...
    &quot;capabilities&quot; : {
        &quot;documentFormattingProvider&quot; : &quot;true&quot;
        ...
    }
}
</code></pre>
<p>另外，你的语言服务器还要能够响应<code>textDocument/formatting</code>请求。</p>
<h5 id="直接实现-12"><a class="header" href="#直接实现-12">直接实现</a></h5>
<pre><code class="language-typescript">class GoDocumentFormatter implements vscode.DocumentFormattingEditProvider {
    public formatDocument(document: vscode.TextDocument):
        Thenable&lt;vscode.TextEdit[]&gt; {
    ...
    }
}

export function activate(ctx: vscode.ExtensionContext): void {
    ...
    ctx.subscriptions.push(
        vscode.languages.registerDocumentFormattingEditProvider(
            GO_MODE, new GoDocumentFormatter()));
    ...
}
</code></pre>
<blockquote>
<p><strong>基础实现</strong></p>
<p>不提供格式化支持</p>
</blockquote>
<blockquote>
<p><strong>进阶实现</strong></p>
<p>你应该尽量减少代码格式化的影响。稍有不慎，诊断功能就可能失效。</p>
</blockquote>
<h2 id="格式化选中区域"><a class="header" href="#格式化选中区域">格式化选中区域</a></h2>
<hr />
<p>为用户选中区域提供代码格式化支持。</p>
<p><img src="https://media.githubusercontent.com/media/Microsoft/vscode-docs/master/api/language-extensions/images/language-support/format-document-range.gif" alt="format-document-range" /></p>
<h5 id="语言服务器协议-13"><a class="header" href="#语言服务器协议-13">语言服务器协议</a></h5>
<p>为了响应请求<code>initialize</code>方法，语言服务器需要声明它能提供这项功能。</p>
<pre><code class="language-json">{
    ...
    &quot;capabilities&quot; : {
        &quot;documentRangeFormattingProvider&quot; : &quot;true&quot;
        ...
    }
}
</code></pre>
<p>另外，你的语言服务器还要能够响应<code>textDocument/rangeFormatting</code>请求。</p>
<h5 id="直接实现-13"><a class="header" href="#直接实现-13">直接实现</a></h5>
<pre><code class="language-typescript">class GoDocumentRangeFormatter implements vscode.DocumentRangeFormattingEditProvider{
    public provideDocumentRangeFormattingEdits(
        document: vscode.TextDocument, range: vscode.Range,
        options: vscode.FormattingOptions, token: vscode.CancellationToken):
        Thenable&lt;vscode.TextEdit[]&gt;;
    ...
    }
}

export function activate(ctx: vscode.ExtensionContext): void {
    ...
    ctx.subscriptions.push(
        vscode.languages.registerDocumentRangeFormattingEditProvider(
            GO_MODE, new GoDocumentRangeFormatter()));
    ...
}
</code></pre>
<blockquote>
<p><strong>基础实现</strong></p>
<p>不提供格式化支持</p>
</blockquote>
<blockquote>
<p><strong>进阶实现</strong></p>
<p>你应该尽量减少代码格式化的影响。稍有不慎，诊断功能就可能失效。</p>
</blockquote>
<h2 id="随用户输入格式化代码"><a class="header" href="#随用户输入格式化代码">随用户输入格式化代码</a></h2>
<hr />
<p>支持用户输入时动态调整文本格式。</p>
<p>!&gt; **注意：**用户<a href="https://code.visualstudio.com/docs/getstarted/settings">设置</a>中的<code>editor.formatOnType</code>控制着本功能。</p>
<p><img src="https://media.githubusercontent.com/media/Microsoft/vscode-docs/master/api/language-extensions/images/language-support/format-on-type.gif" alt="format-on-type" /></p>
<h5 id="语言服务器协议-14"><a class="header" href="#语言服务器协议-14">语言服务器协议</a></h5>
<p>为了响应请求<code>initialize</code>方法，语言服务器需要声明它能提供这项功能。服务器还得告诉客户端哪些字符需要被格式化，<code>moreTriggerCharacters</code>是可选的。</p>
<pre><code class="language-json">{
    ...
    &quot;capabilities&quot; : {
        &quot;documentOnTypeFormattingProvider&quot; : {
            &quot;firstTriggerCharacter&quot;: &quot;}&quot;,
            &quot;moreTriggerCharacter&quot;: [&quot;;&quot;, &quot;,&quot;]
        }
        ...
    }
}
</code></pre>
<p>另外，你的语言服务器还要能够响应<code>textDocument/onTypeFormatting</code>请求。</p>
<h5 id="直接实现-14"><a class="header" href="#直接实现-14">直接实现</a></h5>
<pre><code class="language-typescript">class GoOnTypingFormatter implements vscode.OnTypeFormattingEditProvider{
    public provideOnTypeFormattingEdits(
        document: vscode.TextDocument, position: vscode.Position,
        ch: string, options: vscode.FormattingOptions, token: vscode.CancellationToken):
        Thenable&lt;vscode.TextEdit[]&gt;;
    ...
    }
}

export function activate(ctx: vscode.ExtensionContext): void {
    ...
    ctx.subscriptions.push(
        vscode.languages.registerOnTypeFormattingEditProvider(
            GO_MODE, new GoOnTypingFormatter()));
    ...
}
</code></pre>
<blockquote>
<p><strong>基础实现</strong></p>
<p>不提供格式化支持</p>
</blockquote>
<blockquote>
<p><strong>进阶实现</strong></p>
<p>你应该尽量减少代码格式化的影响。稍有不慎，诊断功能就可能失效。</p>
</blockquote>
<h2 id="重命名符号"><a class="header" href="#重命名符号">重命名符号</a></h2>
<hr />
<p>允许用户重命名符号，并更新对应符号的全部引用。</p>
<p><img src="https://media.githubusercontent.com/media/Microsoft/vscode-docs/master/api/language-extensions/images/language-support/rename.gif" alt="rename" /></p>
<h5 id="语言服务器协议-15"><a class="header" href="#语言服务器协议-15">语言服务器协议</a></h5>
<p>为了响应请求<code>initialize</code>方法，语言服务器需要声明它能提供这项功能。</p>
<pre><code class="language-json">{
    ...
    &quot;capabilities&quot; : {
        &quot;renameProvider&quot; : &quot;true&quot;
        ...
    }
}
</code></pre>
<p>另外，你的语言服务器还要能够响应<code>textDocument/rename</code>请求。</p>
<h5 id="直接实现-15"><a class="header" href="#直接实现-15">直接实现</a></h5>
<pre><code class="language-typescript">class GoRenameProvider implements vscode.RenameProvider {
    public provideRenameEdits(
        document: vscode.TextDocument, position: vscode.Position,
        newName: string, token: vscode.CancellationToken):
        Thenable&lt;vscode.WorkspaceEdit&gt; {
    ...
    }
}

export function activate(ctx: vscode.ExtensionContext): void {
    ...
    ctx.subscriptions.push(
        vscode.languages.registerRenameProvider(
            GO_MODE, new GoRenameProvider()));
    ...
}
</code></pre>
<blockquote>
<p><strong>基础实现</strong></p>
<p>不提供本功能支持。</p>
</blockquote>
<blockquote>
<p><strong>进阶实现</strong></p>
<p>返回工作区中全部需要生效的编辑区，比如当一个符号在项目的各个地方都被引用时。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="示例语言服务器"><a class="header" href="#示例语言服务器">示例：语言服务器</a></h1>
<p>就如你在<a href="language-extensions//language-extensions/programmatic-language-features">程序性语言特性</a>章节所见，实现语言特性的直接方式是使用<code>languages.*</code>API。但是语言服务器不同，它是另一种语言插件的实现方式。</p>
<p>本章将：</p>
<ul>
<li>解释语言服务器插件的好处</li>
<li>手把手教你实现一个语言服务器<a href="https://github.com/Microsoft/vscode-languageserver-node"><code>Microsoft/vscode-languageserver-node</code></a>，你觉得啰嗦的话，也可以直接看<a href="https://github.com/Microsoft/vscode-extension-samples/tree/master/lsp-sample">lsp-sample</a>源码。</li>
</ul>
<h2 id="为什么使用语言服务器"><a class="header" href="#为什么使用语言服务器">为什么使用语言服务器？</a></h2>
<hr />
<p>语言服务器是一种可以提升语言编辑体验的特殊VS Code插件。有了语言服务器，你可以实现如自动补全、错误检查（诊断）、转跳到定义等等其他VS Code<a href="language-extensions//language-extensions/programmatic-language-features">语言特性</a>。</p>
<p>但是在VS Code中实现语言功能会面临三个问题：</p>
<p>第一，语言服务器一般是用他们自己原生的语言实现的，那么如何与VS Code中的Node.js运行时整合起来就是一个问题。</p>
<p>其二，语言服务器一般都是高消耗的。比如检查文件，语言服务器需要解析大量的文件，构建起抽象语法树然后进行静态分析。这些操作会吃掉很多CPU和内存，但是与此同时VS Code的性能不能受到任何影响。</p>
<p>第三，通常为多个编辑器开发不同的语言插件需要花费大量精力。对于语言插件开发者来说，他们需要根据不同编辑器各自的API来实现插件。而从编辑器的角度来讲，他们也不能指望语言工具API统一。最终导致了为<code>N</code>种编辑器实现<code>M</code>种语言需要花费<code>N*M</code>的工作和精力。</p>
<p>为了解决这些问题，微软提供了<a href="https://microsoft.github.io/language-server-protocol">语言服务器协议(Language Server Protocol)</a>意图为语言插件和编辑器提供社区规范。这样一来，语言服务器就可以用任何一种语言来实现，用协议通讯也避免了插件在主进程中运行的高开销。而且任何LSP兼容的语言插件，都能和LSP兼容的代码编辑器整合起来，LSP是语言插件开发者和第三方编辑器的共赢方案。</p>
<p><img src="https://code.visualstudio.com/assets/api/language-extensions/language-server-extension-guide/lsp-languages-editors.png" alt="lsp-languages-editors" /></p>
<p>在本章，我们将：</p>
<ul>
<li>根据<a href="https://github.com/Microsoft/vscode-languageserver-node">Node SDK</a>，学习如何在VS Code中新建一个语言服务器插件</li>
<li>学习如何运行、调试、记录日志和测试语言服务器插件</li>
<li>为你提供更多进阶的语言服务器</li>
</ul>
<p>?&gt; <strong>译者注</strong>：本文及其他章节所涉及的<strong>LSP</strong>全为Language Server Protocol的缩写。<strong>语言服务器协议</strong>是VS Code为了调试、分析语言的自带的中间层协议。众所周知，VS Code本身只是一个编辑器，它不含任何编程语言的功能和运行时（javascript和typescript除外），而是将语言的各种特性交给了插件创作者自由实现。</p>
<h2 id="实现你自己的语言服务器"><a class="header" href="#实现你自己的语言服务器">实现你自己的语言服务器</a></h2>
<hr />
<p>在VS Code中，一个语言服务器有两个部分：</p>
<ul>
<li><strong>语言客户端</strong>：一个由Javascript/Typescript组成的普通插件，这个插件能使用所有的<a href="language-extensions//references/vscode-api">VS Code 命名空间API</a>。</li>
<li><strong>语言服务器</strong>：运行在单独进程中的语言分析工具。</li>
</ul>
<p>语言服务器运行在单独的进程有两个好处：</p>
<ul>
<li>只要能通过LSP通信，语言分析工具可以用任何语言实现。</li>
<li>语言分析工具一般非常消耗CPU和内存，在单独的进程中运行能避免大性能开销</li>
</ul>
<p>下面是一个运行了2个<strong>语言服务器插件</strong>的示意图。HTML语言客户端和PHP语言客户端是常见的VS Code插件。两个客户端都用LSP与各自对应的语言服务器进行通信——即使PHP语言服务器是用PHP写的，但是仍然能通过LSP与PHP语言客户端建立起通信。</p>
<p><img src="https://code.visualstudio.com/assets/api/language-extensions/language-server-extension-guide/lsp-illustration.png" alt="lsp-illustration" /></p>
<p>本篇将指引你学习如何用我们的<a href="https://github.com/Microsoft/vscode-languageserver-node">Node SDK</a>构建一个语言客户端/服务器。剩下的内容都建立在你已经了解VS Code<a href="language-extensions//">插件开发</a>的基础之上。</p>
<h2 id="示例一个简单的纯文本语言服务器"><a class="header" href="#示例一个简单的纯文本语言服务器">示例：一个简单的纯文本语言服务器</a></h2>
<hr />
<p>让我们首先实现一个简单的语言服务器插件吧，这个插件的功能是自动补全、诊断纯文本文件。我们会同时学习客户端/服务端的配置。
如果你想直接上手代码：</p>
<ul>
<li><a href="https://github.com/Microsoft/vscode-extension-samples/tree/master/lsp-sample">lsp-sample</a>：本篇教程的主要源代码，有大量注释</li>
<li><a href="https://github.com/Microsoft/vscode-extension-samples/tree/master/lsp-multi-server-sample">lsp-multi-server-sample</a>：<strong>lsp-sample</strong>的进阶版本，同样有大量注释，支持<a href="https://code.visualstudio.com/docs/editor/multi-root-workspaces">多目录工作区</a>特性的语言服务器实例。</li>
</ul>
<p>复制<a href="https://github.com/Microsoft/vscode-extension-samples">Microsoft/vscode-extension-samples</a>然后打开示例：</p>
<pre><code class="language-bash">&gt; git clone https://github.com/microsoft/vscode-extension-samples.git
&gt; cd vscode-extension-samples/lsp-sample
&gt; npm install
&gt; npm run compile
&gt; code .
</code></pre>
<p>安装完所有依赖然后打开<strong>lsp-sample</strong>工作，里面包含客户端和服务器的代码。下面是一个整体的<strong>lsp-sample</strong>目录结构：</p>
<pre><code>.
├── client // 语言客户端
│   ├── src
│   │   ├── test // 语言客户端 / 服务器 的端到端测试
│   │   └── extension.ts // 语言客户端入口
├── package.json // 插件配置清单
└── server // 语言服务器
    └── src
        └── server.ts // 语言服务器入口
</code></pre>
<h2 id="什么是language-client"><a class="header" href="#什么是language-client">什么是'Language Client'</a></h2>
<hr />
<p>我们先看看<code>/package.json</code>，这个文件描述了语言客户端的能力。里面有3个有趣的部分：</p>
<p>首先看看<a href="language-extensions//references/activation-events">activationEvents</a>：</p>
<pre><code class="language-json">&quot;activationEvents&quot;: [
    &quot;onLanguage:plaintext&quot;
]
</code></pre>
<p>这个部分告诉VS Code只要打开纯文本文件之后就立刻激活插件（例如：打开一个<code>.txt</code>文件）</p>
<p>下一步看看<a href="language-extensions//extensibility-reference/contribution-points#contributesconfiguration">configuration</a>部分：</p>
<pre><code class="language-json">&quot;configuration&quot;: {
    &quot;type&quot;: &quot;object&quot;,
    &quot;title&quot;: &quot;Example configuration&quot;,
    &quot;properties&quot;: {
		&quot;languageServerExample.maxNumberOfProblems&quot;: {
			&quot;scope&quot;: &quot;resource&quot;,
            &quot;type&quot;: &quot;number&quot;,
            &quot;default&quot;: 100,
            &quot;description&quot;: &quot;Controls the maximum number of problems produced by the server.&quot;
        }
    }
}
</code></pre>
<p>这个部分配置了用户可以自定义的<code>configuration</code>，用户通过这个配置可以在<strong>设置</strong>中对你的插件做一些修改。这并不是本节重点，稍后示例将通过代码呈现——插件如何在设置变动后将<strong>修改后的配置</strong>应用到我们的语言服务器上。</p>
<p>真正的语言客户端代码和对应的<code>package.json</code>在<code>/client</code>文件夹中。<code>package.json</code>最有趣的部分是<code>vscode</code>插件主机API和<code>vscode-languageclient</code>这两个依赖库。</p>
<pre><code class="language-json">&quot;engines&quot;: {
    &quot;vscode&quot;: &quot;^1.43.0&quot;
},
&quot;dependencies&quot;: {
    &quot;vscode-languageclient&quot;: &quot;^6.1.3&quot;
}
</code></pre>
<p>正如上面所说，客户端实现就是一个普通的VS Code插件，它有使用全部VS Code API的能力。</p>
<p>下面是extension.ts文件的对应内容，也是<strong>lsp-sample</strong>插件的入口：</p>
<pre><code class="language-typescript">import * as path from 'path';
import { workspace, ExtensionContext } from 'vscode';

import {
	LanguageClient,
	LanguageClientOptions,
	ServerOptions,
	TransportKind
} from 'vscode-languageclient';

let client: LanguageClient;

export function activate(context: ExtensionContext) {
	// 服务器由node实现
	let serverModule = context.asAbsolutePath(
		path.join('server', 'out', 'server.js')
	);
	// 为服务器提供debug选项
	// --inspect=6009: 运行在Node's Inspector mode，这样VS Code就能调试服务器了
	let debugOptions = { execArgv: ['--nolazy', '--inspect=6009'] };

	// 如果插件运行在调试模式那么就会使用debug server options
	// 不然就使用run options
	let serverOptions: ServerOptions = {
		run: { module: serverModule, transport: TransportKind.ipc },
		debug: {
			module: serverModule,
			transport: TransportKind.ipc,
			options: debugOptions
		}
	};

	// 控制语言客户端的选项
	let clientOptions: LanguageClientOptions = {
		// 注册纯文本服务器
		documentSelector: [{ scheme: 'file', language: 'plaintext' }],
		synchronize: {
			// 当文件变动为'.clientrc'中那样时，通知服务器
			fileEvents: workspace.createFileSystemWatcher('**/.clientrc')
		}
	};
    // 创建语言客户端并启动
	client = new LanguageClient(
		'languageServerExample',
		'Language Server Example',
		serverOptions,
		clientOptions
	);

	// 启动客户端，这也同时启动了服务器
	client.start();
}

export function deactivate(): Thenable&lt;void&gt; {
	if (!client) {
		return undefined;
	}
	return client.stop();
}

</code></pre>
<h2 id="什么是language-server"><a class="header" href="#什么是language-server">什么是'Language Server'</a></h2>
<hr />
<p>?&gt; **小提示：**本节从Github仓库中克隆下来的'server'代码是已经完成的版本，如果你需要跟随本节的步骤循序渐进，你可以新建一个<code>server.ts</code>或者修改克隆的代码。</p>
<p>在这个例子中，服务器是Typescript实现的，由Node.js运行。因为VS Code自带Node.js运行时，所以你无需安装其他依赖，除非你对运行时有特别要求。</p>
<p>这个语言服务器的源码在<code>/server</code>中。比较重要的<code>pacakge.json</code>部分是：</p>
<pre><code class="language-json">&quot;dependencies&quot;: {
    &quot;vscode-languageserver&quot;: &quot;^6.1.1&quot;,
    &quot;vscode-languageserver-textdocument&quot;: &quot;^1.0.1&quot;
}
</code></pre>
<p>这行依赖会下载<code>vscode-languageserver</code>库。</p>
<p>下面是一个服务器的实现，提供了简单的纯文本管理——VS Code会向服务器发送一个文件的全部内容。</p>
<pre><code class="language-typescript">import {
  createConnection,
  TextDocuments,
  Diagnostic,
  DiagnosticSeverity,
  ProposedFeatures,
  InitializeParams,
  DidChangeConfigurationNotification,
  CompletionItem,
  CompletionItemKind,
  TextDocumentPositionParams,
  TextDocumentSyncKind,
  InitializeResult
} from 'vscode-languageserver';

import { TextDocument } from 'vscode-languageserver-textdocument';

// 创建一个服务器连接。使用Node的IPC作为传输方式。
// 也包含所有的预览、建议等LSP特性
let connection = createConnection(ProposedFeatures.all);

// 创建一个简单的文本管理器。
// 文本管理器只支持全文本同步。
let documents: TextDocuments&lt;TextDocument&gt; = new TextDocuments(TextDocument);

let hasConfigurationCapability: boolean = false;
let hasWorkspaceFolderCapability: boolean = false;
let hasDiagnosticRelatedInformationCapability: boolean = false;

connection.onInitialize((params: InitializeParams) =&gt; {
	let capabilities = params.capabilities;

	// 客户端是否支持`workspace/configuration`请求?
	// 如果不是的话，降级到使用全局设置
	hasConfigurationCapability = !!(
      capabilities.workspace &amp;&amp; !!capabilities.workspace.configuration
	);
	hasWorkspaceFolderCapability = !!(
		capabilities.workspace &amp;&amp; !!capabilities.workspace.workspaceFolders
	);
	hasDiagnosticRelatedInformationCapability = !!(
		capabilities.textDocument &amp;&amp;
		capabilities.textDocument.publishDiagnostics &amp;&amp;
		capabilities.textDocument.publishDiagnostics.relatedInformation
	);

	const result: InitializeResult = {
		capabilities: {
			textDocumentSync: TextDocumentSyncKind.Incremental,
			// Tell the client that this server supports code completion.
			completionProvider: {
				resolveProvider: true
			}
		}
	};

	if (hasWorkspaceFolderCapability) {
		result.capabilities.workspace = {
			workspaceFolders: {
				supported: true
			}
		};
	}

	return result;
});

connection.onInitialized(() =&gt; {
	if (hasConfigurationCapability) {
		// 为所有配置Register for all configuration changes.
		connection.client.register(
			DidChangeConfigurationNotification.type,
			undefined
		);
	}
	if (hasWorkspaceFolderCapability) {
		connection.workspace.onDidChangeWorkspaceFolders(_event =&gt; {
			connection.console.log('Workspace folder change event received.');
		});
	}
});

// 配置示例
interface ExampleSettings {
	maxNumberOfProblems: number;
}

// 当客户端不支持`workspace/configuration`请求时，使用global settings
// 请注意，在这个例子中服务器使用的客户端并不是问题所在，而是这种情况还可能发生在其他客户端身上。
const defaultSettings: ExampleSettings = { maxNumberOfProblems: 1000 };
let globalSettings: ExampleSettings = defaultSettings;

// 对所有打开的文档配置进行缓存
let documentSettings: Map&lt;string, Thenable&lt;ExampleSettings&gt;&gt; = new Map();

connection.onDidChangeConfiguration(change =&gt; {
	if (hasConfigurationCapability) {
		// 重置所有已缓存的文档配置
		documentSettings.clear();
	} else {
		globalSettings = &lt;ExampleSettings&gt;(
			(change.settings.languageServerExample || defaultSettings)
		);
	}

	// 重新验证所有打开的文本文档
	documents.all().forEach(validateTextDocument);
});

function getDocumentSettings(resource: string): Thenable&lt;ExampleSettings&gt; {
	if (!hasConfigurationCapability) {
		return Promise.resolve(globalSettings);
	}
	let result = documentSettings.get(resource);
	if (!result) {
		result = connection.workspace.getConfiguration({
			scopeUri: resource,
			section: 'languageServerExample'
		});
		documentSettings.set(resource, result);
	}
	return result;
}

// 只对打开的文档保留设置
documents.onDidClose(e =&gt; {
	documentSettings.delete(e.document.uri);
});

// 文档的文本内容发生了改变。
// 这个事件在文档第一次打开或者内容变动时才会触发。
documents.onDidChangeContent(change =&gt; {
	validateTextDocument(change.document);
});

async function validateTextDocument(textDocument: TextDocument): Promise&lt;void&gt; {
	// 在这个简单的示例中，每次校验运行时我们都获取一次配置
	let settings = await getDocumentSettings(textDocument.uri);

	// 校验器如果检测到连续超过2个以上的大写字母则会报错
	let text = textDocument.getText();
	let pattern = /\b[A-Z]{2,}\b/g;
	let m: RegExpExecArray | null;

    let problems = 0;
	let diagnostics: Diagnostic[] = [];
	while ((m = pattern.exec(text)) &amp;&amp; problems &lt; settings.maxNumberOfProblems) {
		problems++;
		let diagnosic: Diagnostic = {
			severity: DiagnosticSeverity.Warning,
			range: {
				start: textDocument.positionAt(m.index),
				end: textDocument.positionAt(m.index + m[0].length)
			},
			message: `${m[0]} is all uppercase.`,
			source: 'ex'
		};
		if (hasDiagnosticRelatedInformationCapability) {
			diagnosic.relatedInformation = [
				{
					location: {
						uri: textDocument.uri,
						range: Object.assign({}, diagnosic.range)
					},
					message: 'Spelling matters'
				},
				{
					location: {
						uri: textDocument.uri,
						range: Object.assign({}, diagnosic.range)
					},
					message: 'Particularly for names'
				}
			];
		}
		diagnostics.push(diagnosic);
	}
    // 将错误处理结果发送给VS Code
	connection.sendDiagnostics({ uri: textDocument.uri, diagnostics });
}

connection.onDidChangeWatchedFiles(_change =&gt; {
	// 监测VS Code中的文件变动
	connection.console.log('We received an file change event');
});

// 这个处理函数提供了初始补全项列表
connection.onCompletion(
	(_textDocumentPosition: TextDocumentPositionParams): CompletionItem[] =&gt; {
	// 传入的变量包含了文本请求代码补全的位置。
	// 在这个示例中我们忽略了这个信息，总是提供相同的补全选项。
	return [
		{
			label: 'TypeScript',
			kind: CompletionItemKind.Text,
			data: 1
		},
		{
			label: 'JavaScript',
			kind: CompletionItemKind.Text,
			data: 2
		}
		];
	}
);

// 这个函数为补全列表的选中项提供了更多信息
connection.onCompletionResolve(
	(item: CompletionItem): CompletionItem =&gt; {
		if (item.data === 1) {
			item.detail = 'TypeScript details';
			item.documentation = 'TypeScript documentation';
		} else if (item.data === 2) {
			item.detail = 'JavaScript details';
			item.documentation = 'JavaScript documentation';
		}
		return item;
	}
);

// 让文档管理器监听文档的打开，变动和关闭事件。
documents.listen(connection);

// 连接后启动监听
connection.listen();

</code></pre>
<h2 id="添加一个简单的语法校验器"><a class="header" href="#添加一个简单的语法校验器">添加一个简单的语法校验器</a></h2>
<hr />
<p>为了给服务器添加文本校验，我们给text document manager添加一个listener然后在文本变动时调用，接下来就交给服务器去判断调用校验器的最佳时机了。在我们的示例中，服务器的功能是校验纯文本然后给所有大写单词进行标记。对应的代码片段：</p>
<pre><code class="language-typescript">// 文本文件的内容改变时。文档首次打开或者文档内容修改时会触发这个事件。
documents.onDidChangeContent(async change =&gt; {
  let textDocument = change.document;
  // 这个简单示例中，每次校验时我们都获取一次设置
  let settings = await getDocumentSettings(textDocument.uri);

  // 校验器会检查所有的大写单词是否超过 2 个字母
  let text = textDocument.getText();
  let pattern = /\b[A-Z]{2,}\b/g;
  let m: RegExpExecArray | null;

  let problems = 0;
  let diagnostics: Diagnostic[] = [];
  while ((m = pattern.exec(text)) &amp;&amp; problems &lt; settings.maxNumberOfProblems) {
    problems++;
    let diagnostic: Diagnostic = {
      severity: DiagnosticSeverity.Warning,
      range: {
        start: textDocument.positionAt(m.index),
        end: textDocument.positionAt(m.index + m[0].length)
      },
      message: `${m[0]} is all uppercase.`,
      source: 'ex'
    };
    if (hasDiagnosticRelatedInformationCapability) {
      diagnostic.relatedInformation = [
        {
          location: {
            uri: textDocument.uri,
            range: Object.assign({}, diagnostic.range)
          },
          message: 'Spelling matters'
        },
        {
          location: {
            uri: textDocument.uri,
            range: Object.assign({}, diagnostic.range)
          },
          message: 'Particularly for names'
        }
      ];
    }
    diagnostics.push(diagnostic);
  }

  // 将诊断信息发送给 VS Code
  connection.sendDiagnostics({ uri: textDocument.uri, diagnostics });
});
</code></pre>
<h2 id="诊断提示和小技巧"><a class="header" href="#诊断提示和小技巧">诊断提示和小技巧</a></h2>
<hr />
<ul>
<li>如果出错的开始点和结束点在同一个位置，VS Code会在那个单词的位置上打上波浪线</li>
<li>如果你想要把波浪线加到行未为止，就把<code>end position</code>设置为<code>Number.MAX_VALUE</code></li>
</ul>
<p>运行语言服务器步骤：</p>
<ol>
<li>通过快捷键(<kbd>Ctrl+Shift+B</kbd>)启动build任务。这个任务会把客户端和服务器端都编译掉。</li>
<li>打开调试侧边栏，选择<code>启动客户端</code>加载配置，然后按<code>开始调试</code>按钮启动<code>扩展开发主机</code>。</li>
<li>在根目录下新建一个'test.txt'文件，然后粘贴下述内容：</li>
</ol>
<pre><code>TypeScript lets you write JavaScript the way you really want to.
TypeScript is a typed superset of JavaScript that compiles to plain JavaScript.
ANY browser. ANY host. ANY OS. Open Source.
</code></pre>
<p><code>扩展开发主机</code>实例看起来像是这样：</p>
<p><img src="https://code.visualstudio.com/assets/api/language-extensions/language-server-extension-guide/validation.png" alt="validation" /></p>
<h2 id="调试客户端和服务端"><a class="header" href="#调试客户端和服务端">调试客户端和服务端</a></h2>
<hr />
<p>调试客户端代码就像调试普通插件一样简单。在代码中打上断点，然后按<kbd>F5</kbd>启动插件调试。</p>
<p><img src="https://code.visualstudio.com/assets/api/language-extensions/language-server-extension-guide/debugging-client.png" alt="debugging-client" /></p>
<p>因为服务器是由<code>LanguageClient</code>启动的，我们需要附加一个<em>调试器</em>给运行中的服务器。为了做到这一点，切换到<strong>调试</strong>侧边栏，选择加载配置<code>Attach to Server</code>然后按<kbd>F5</kbd>启动调试（要保证server已经启动哦，也就是上面一步），看起来会像这样：</p>
<p><img src="https://code.visualstudio.com/assets/api/language-extensions/language-server-extension-guide/debugging-server.png" alt="debugging-server" /></p>
<h2 id="为语言服务器加上日志"><a class="header" href="#为语言服务器加上日志">为语言服务器加上日志</a></h2>
<hr />
<p>如果你是用<code>vscode-languageclient</code>实现的客户端，你可以配置<code>[langId].trace.server</code>指示客户端在<code>output(输出)</code>面板中显示通信日志。</p>
<p>对于<strong>Isp-sample</strong>你能在<code>&quot;languageServerExample.trace.server&quot;: &quot;verbose&quot;</code>进行配置。现在看看&quot;Language Server Example&quot;频道，你应该能看到这些日志：</p>
<p><img src="https://code.visualstudio.com/assets/api/language-extensions/language-server-extension-guide/lsp-log.png" alt="lsp-log" /></p>
<p>因为语言服务器通信会非常啰嗦（5s的正常使用会产生5000行日志），因此我们提供了一个可视化和可筛选的日志工具。你可以先从频道中保存所有的日志，然后在<a href="https://microsoft.github.io/language-server-protocol/inspector/">语言服务器协议检查器</a>中加载。</p>
<p><img src="https://code.visualstudio.com/assets/api/language-extensions/language-server-extension-guide/lsp-inspector.png" alt="lsp-inspector" /></p>
<h2 id="在服务器中设置configuration"><a class="header" href="#在服务器中设置configuration">在服务器中设置Configuration</a></h2>
<hr />
<p>当我们写插件的客户端部分的时候，我们已经定义了一个控制最大问题报告数的配置。所以我们也可以在服务器中写一段读取客户端配置的代码：</p>
<pre><code class="language-typescript">function getDocumentSettings(resource: string): Thenable&lt;ExampleSettings&gt; {
	if (!hasConfigurationCapability) {
		return Promise.resolve(globalSettings);
	}
	let result = documentSettings.get(resource);
	if (!result) {
		result = connection.workspace.getConfiguration({
			scopeUri: resource,
			section: 'languageServerExample'
		});
		documentSettings.set(resource, result);
	}
	return result;
}
</code></pre>
<p>现在唯一要做的事情就是在服务器端中监听用户修改的设置变动，然后重新验证已经打开的文本文件。为了重用文本变动事件的处理函数，我们把代码提取到<code>validateTextDocument</code>函数中，然后新建一个<code>maxNumberOfProblems</code>变量：</p>
<pre><code class="language-typescript">async function validateTextDocument(textDocument: TextDocument): Promise&lt;void&gt; {
	// 在这个简单的示例中，每次校验运行时我们都获取一次配置
	let settings = await getDocumentSettings(textDocument.uri);

	// 校验器如果检测到连续超过2个以上的大写字母则会报错
	let text = textDocument.getText();
	let pattern = /\b[A-Z]{2,}\b/g;
	let m: RegExpExecArray;

	let problems = 0;
	let diagnostics: Diagnostic[] = [];
	while ((m = pattern.exec(text)) &amp;&amp; problems &lt; settings.maxNumberOfProblems) {
		problems++;
		let diagnosic: Diagnostic = {
			severity: DiagnosticSeverity.Warning,
			range: {
				start: textDocument.positionAt(m.index),
				end: textDocument.positionAt(m.index + m[0].length)
			},
			message: `${m[0]} is all uppercase.`,
			source: 'ex'
		};
		if (hasDiagnosticRelatedInformationCapability) {
			diagnosic.relatedInformation = [
				{
					location: {
						uri: textDocument.uri,
						range: Object.assign({}, diagnosic.range)
					},
					message: 'Spelling matters'
				},
				{
					location: {
						uri: textDocument.uri,
						range: Object.assign({}, diagnosic.range)
					},
					message: 'Particularly for names'
				}
			];
		}
		diagnostics.push(diagnosic);
	}

	// 将错误处理结果发送给VS Code
	connection.sendDiagnostics({ uri: textDocument.uri, diagnostics });
}
</code></pre>
<p>添加一个<em>通知处理函数</em>监听配置文件变动。</p>
<pre><code class="language-typescript">connection.onDidChangeConfiguration(change =&gt; {
	if (hasConfigurationCapability) {
		// 重置所有文档设置的缓存
		documentSettings.clear();
	} else {
		globalSettings = &lt;ExampleSettings&gt;(
			(change.settings.languageServerExample || defaultSettings)
		);
	}

	// 重新验证所有打开的文本文档
	documents.all().forEach(validateTextDocument);
});
</code></pre>
<p>再次启动客户端，然后把设置中的<code>maximum report</code>改为1，就能看到：</p>
<p><img src="https://code.visualstudio.com/assets/api/language-extensions/language-server-extension-guide/validationOneProblem.png" alt="validationOneProblem" /></p>
<h2 id="添加其他语言特性"><a class="header" href="#添加其他语言特性">添加其他语言特性</a></h2>
<hr />
<p>第一个有趣的东西是，语言服务器通常会实现成文档校验器，从这个点来说，即使一个linter也算一个语言服务器，所以VS Code中的linter通常都是作为语言服务器实现的（参照<a href="https://github.com/Microsoft/vscode-eslint">eslint</a>和<a href="https://github.com/Microsoft/vscode-jshint">jslint</a>）。但是语言服务器还能做得更多，他们能提供代码不全，查找所有匹配项或者转跳到定义。下面的代码展示了为服务器添加代码补全的功能，它提供了2个建议单词&quot;TypeScript&quot;和&quot;JavaScript&quot;。</p>
<pre><code class="language-typescript">// 这个处理函数提供了初始补全项列表
connection.onCompletion(
	(_textDocumentPosition: TextDocumentPositionParams): CompletionItem[] =&gt; {
		// 传入的变量包含了文本请求代码补全的位置。
		// 在这个示例中我们忽略了这个信息，总是提供相同的补全选项。
		return [
			{
				label: 'TypeScript',
				kind: CompletionItemKind.Text,
				data: 1
			},
			{
				label: 'JavaScript',
				kind: CompletionItemKind.Text,
				data: 2
			}
		];
	}
);

// 这个函数为补全列表的选中项提供了更多信息
connection.onCompletionResolve(
	(item: CompletionItem): CompletionItem =&gt; {
		if (item.data === 1) {
			(item.detail = 'TypeScript details'),
				(item.documentation = 'TypeScript documentation');
		} else if (item.data === 2) {
			(item.detail = 'JavaScript details'),
				(item.documentation = 'JavaScript documentation');
		}
		return item;
	}
);
</code></pre>
<p><code>data</code>字段用于鉴别处理函数中传入的补全项。这个属性对协议来说是透明的，因为底层协议信息传输是基于JSON的，因此data字段只能保留从JSON序列化而来的数据。</p>
<p>那么现在只缺告诉VS Code服务器能提供代码补全请求。为了做到点，将对应标记添加到初始化函数中：</p>
<pre><code class="language-typescript">connection.onInitialize((params): InitializeResult =&gt; {
	...
	return {
		capabilities: {
			...
			// 告诉客户端，服务器支持代码补全
			completionProvider: {
				resolveProvider: true
			}
		}
	};
});
</code></pre>
<p>下面的截屏显示了运行在纯文本文件中的补全代码：</p>
<p><img src="https://code.visualstudio.com/assets/api/language-extensions/language-server-extension-guide/codeComplete.png" alt="codeComplete" /></p>
<h2 id="测试语言服务器"><a class="header" href="#测试语言服务器">测试语言服务器</a></h2>
<hr />
<p>为了创建一个高质量的语言服务器，我们需要构建一个能覆盖到它所有功能点的测试套件。有两种常见的测试服务器的方式：</p>
<ul>
<li>单元测试：如果你想测试特定的功能点，这是一个非常有用的方式，模拟数据然后发送进去。VC Code的<a href="https://github.com/Microsoft/vscode-html-languageservice">HTML</a>/<a href="https://github.com/Microsoft/vscode-css-languageservice">CSS</a>/<a href="https://github.com/Microsoft/vscode-json-languageservice">JSON</a>语言服务器就采用了这种测试方式。LSP的npm模块包也是用这种方式。在<a href="https://github.com/Microsoft/vscode-languageserver-node/blob/master/protocol/src/test/connection.test.ts">这里</a>查看更多使用npm协议模块的单元测试。</li>
<li>端到端测试：就像<a href="language-extensions//extension-authoring/testing-extensions.html">VS Code 插件测试</a>一样，这个方式的好处是通过运行VS Code实例，打开文件，激活语言服务器/客户端然后执行<a href="language-extensions//references/commands">VS Code命令</a>来测试的，如果你配置了文件、设置和依赖（如<code>node_modules</code>）以及难以模拟数据的时候，你应该优先考虑这种模式，流行的<a href="https://github.com/Microsoft/vscode-python">Python</a>插件就采用了这种测试方式。</li>
</ul>
<p>你可以用任何你喜欢的测试框架做单元测试。这里我们只介绍如何对语言服务器插件进行端到端测试。</p>
<p>打开<code>.vscode/launch.json</code>，你能找到<code>E2E</code>测试目标：</p>
<pre><code class="language-json">{
	&quot;name&quot;: &quot;Language Server E2E Test&quot;,
	&quot;type&quot;: &quot;extensionHost&quot;,
	&quot;request&quot;: &quot;launch&quot;,
	&quot;runtimeExecutable&quot;: &quot;${execPath}&quot;,
	&quot;args&quot;: [
		&quot;--extensionDevelopmentPath=${workspaceRoot}&quot;,
		&quot;--extensionTestsPath=${workspaceRoot}/client/out/test&quot;,
		&quot;${workspaceRoot}/client/testFixture&quot;
	],
	&quot;stopOnEntry&quot;: false,
	&quot;sourceMaps&quot;: true,
	&quot;outFiles&quot;: [&quot;${workspaceRoot}/client/out/test/**/*.js&quot;]
}
</code></pre>
<p>如果你运行了这个测试目标，它会打开一个VS Code实例和一个叫做<code>client/testFixtur</code>的激活工作区。VS Code然后会执行所有<code>client/src/test</code>中的测试。一点调试的小提示，你可以在<code>client/src/test</code>的Typescript文件中添加断点。</p>
<p>我们再来看看<code>completion.test.ts</code>文件：</p>
<pre><code class="language-typescript">import * as vscode from 'vscode';
import * as assert from 'assert';
import { getDocUri, activate } from './helper';

describe('Should do completion', () =&gt; {
	const docUri = getDocUri('completion.txt');

	it('Completes JS/TS in txt file', async () =&gt; {
		await testCompletion(docUri, new vscode.Position(0, 0), {
			items: [
				{ label: 'JavaScript', kind: vscode.CompletionItemKind.Text },
				{ label: 'TypeScript', kind: vscode.CompletionItemKind.Text }
			]
		});
	});
});

async function testCompletion(
	docUri: vscode.Uri,
	position: vscode.Position,
	expectedCompletionList: vscode.CompletionList
) {
	await activate(docUri);

	// 执行 `vscode.executeCompletionItemProvider` 命令，模拟激活代码补全功能
	const actualCompletionList = (await vscode.commands.executeCommand(
		'vscode.executeCompletionItemProvider',
		docUri,
		position
	)) as vscode.CompletionList;

	assert.equal(actualCompletionList.items.length, expectedCompletionList.items.length);
	expectedCompletionList.items.forEach((expectedItem, i) =&gt; {
		const actualItem = actualCompletionList.items[i];
		assert.equal(actualItem.label, expectedItem.label);
		assert.equal(actualItem.kind, expectedItem.kind);
	});
}
</code></pre>
<p>在这个测试中，我们：</p>
<ul>
<li>激活了插件</li>
<li>带上了一个URI和位置模拟信息，然后运行了<code>vscode.executeCompletionItemProvider</code>去触发补全</li>
<li>断言返回的补全项是不是达到了我们的预期</li>
</ul>
<p>我们再深入一点看看<code>activate(docURI)</code>函数。它被定义在<code>client/src/test/helper.ts</code>中：</p>
<pre><code class="language-typescript">import * as vscode from 'vscode';
import * as path from 'path';

export let doc: vscode.TextDocument;
export let editor: vscode.TextEditor;
export let documentEol: string;
export let platformEol: string;

/**
 * 激活 vscode.lsp-sample 插件
 */
export async function activate(docUri: vscode.Uri) {
	// extensionId来自于package.json中的`publisher.name`
	const ext = vscode.extensions.getExtension('vscode.lsp-sample');
	await ext.activate();
	try {
		doc = await vscode.workspace.openTextDocument(docUri);
		editor = await vscode.window.showTextDocument(doc);
		await sleep(2000); // 等待服务器激活
	} catch (e) {
		console.error(e);
	}
}

async function sleep(ms: number) {
	return new Promise(resolve =&gt; setTimeout(resolve, ms));
}
</code></pre>
<p>在激活部分，我们：</p>
<ul>
<li>用<code>publisher.name</code> <code>extensionId</code>在<code>package.json</code>中获取到了插件</li>
<li>打开特定的文档，然后显示在文本编辑区</li>
<li>休眠2秒，确保启动了语言服务器</li>
</ul>
<p>准备好之后，我们可以运行对应语言特性的<a href="language-extensions//extensibility-reference/vscode-api-commands.html">VS Code命令</a>，然后对结果进行断言测试。
这还有一个关于诊断特性的测试实现，如果你感兴趣，可以查看这个文件<code>client/src/test/diagnostics.test.ts</code></p>
<h2 id="进阶主题"><a class="header" href="#进阶主题">进阶主题</a></h2>
<hr />
<p>到目前为止，本篇教程提供了：</p>
<ul>
<li>一个简短的<strong>语言服务器</strong>和<strong>语言服务器协议</strong>概览</li>
<li>VS Code中的语言服务器插件架构</li>
<li>实现了一个<strong>Isp-sample</strong>插件，和如何开发、调试、检查和测试语言服务器</li>
</ul>
<h4 id="更多语言服务器特性"><a class="header" href="#更多语言服务器特性">更多语言服务器特性</a></h4>
<p>除了代码补全之外，VS Code还支持下列特性：</p>
<ul>
<li>文档高亮：高亮文本中的符号</li>
<li>悬停：为选中的文本符号提供悬停信息</li>
<li>Signature Help：为选中的文本提供提供Signature Help</li>
<li>转跳到定义：为选中的文本符号提供定义转跳</li>
<li>转跳到类型定义：为选中的文本符号提供类型/接口定义转跳</li>
<li>转跳到实现：为选中的文本符号提供实现转跳</li>
<li>引用查找：从整个项目中查找选中文本符号的引用</li>
<li>列出文件符号：列出文本文件中的全部符号</li>
<li>列出工作区符号：列出整个项目中的符号</li>
<li>执行代码：在给定文件和范围的条件下运行命令（通常如：美化、重构）</li>
<li>CodeLens: 为给定文件计算 CodeLens 统计数据</li>
<li>文件格式化：包括整个文件的格式化，部分文本格式化和根据类型格式化</li>
<li>重命名：重命名整个项目内的某些符号</li>
<li>文件链接：计算和解析文件中的链接</li>
<li>文件色彩：计算和解析文件中的色彩，并提供编辑器内的取色器</li>
</ul>
<p><a href="language-extensions//language-extensions/programmatic-language-features">程序性语言特性</a>章节详细介绍了上述的语言特性，并且告诉我们如何通过下述(<strong>两者之一</strong>)去实现它们：</p>
<ul>
<li>语言服务器协议</li>
<li>直接使用VS Code的可拓展性API</li>
</ul>
<h2 id="增量文本同步更新"><a class="header" href="#增量文本同步更新">增量文本同步更新</a></h2>
<hr />
<p>在<code>vscode-languageserver</code>模块中，我们做了一个简单的<code>text document manager</code>同步VS Code和语言服务器。</p>
<p>但是这种方式有两个缺点：</p>
<ul>
<li>文件变动时，会重复地发送整个文本数据，这个传递的数据量相当可观。</li>
<li>现有的库通常都支持增量文本更新，不可避免地，我们会进行不必要的转换和创建抽象语法树。</li>
</ul>
<p>LSP因此直接提供了增量文本更新的API。</p>
<p>现在我们要通过增加3个通知函数实现我们的增量文本更新：</p>
<ul>
<li>onDidOpenTextDocument：当文件打开后调用</li>
<li>onDidChangeTextDocument：当文本变动后调用</li>
<li>onDidCloseTextDocument：当文件关闭后调用</li>
</ul>
<p>下面的代码片段展示了怎么在通信中挂上这些通知函数钩子，在初始化时因如何返回函数：</p>
<pre><code class="language-typescript">connection.onInitialize((params): InitializeResult =&gt; {
	...
	return {
		capabilities: {
			// 启用文档增量更新同步
			textDocumentSync: TextDocumentSyncKind.Incremental,
			...
		}
	};
});

connection.onDidOpenTextDocument((params) =&gt; {
	// 当文档打开后触发，params.uri提供了文档的唯一地址。如果文档储存在硬盘上，那么就会是一个file类型的URI
	// params.text——提供了文档一开始的内容
});

connection.onDidChangeTextDocument((params) =&gt; {
	// 文档的文本内容发生了改变时触发。
	// params.uri提供了文档的唯一地址。
	// params.contentChanges 包含文档的变动内容
});

connection.onDidCloseTextDocument((params) =&gt; {
	// 文档关闭后触发。
	// params.uri提供了文档的唯一地址。
});
</code></pre>
<h4 id="直接用vs-code-api实现语言特性"><a class="header" href="#直接用vs-code-api实现语言特性">直接用VS Code API实现语言特性</a></h4>
<p>语言服务器有这么多好处，只是用来提供VS Code编辑扩展能力就显得有些大材小用了。下面的例子里，我们使用<code>vscode.languages.register[LANGUAGE_FEATURE]Provider</code>选项为某类文件提供一些简单的语言服务器特性。</p>
<p><a href="https://github.com/Microsoft/vscode-extension-samples/tree/master/completions-sample">completions-sample</a>是一个使用<code>vscode.languages.registerCompletionItemProvider</code>为纯文本添加代码片段的例子。</p>
<p>更多例子请参阅<a href="https://github.com/Microsoft/vscode-extension-samples">https://github.com/Microsoft/vscode-extension-samples</a></p>
<h4 id="语言服务器的容错解析器"><a class="header" href="#语言服务器的容错解析器">语言服务器的容错解析器</a></h4>
<p>大多数时候，编辑器中的代码都是不完整的，甚至语法都是错的，但是开发人员肯定希望自动补全等语言功能保持正常工作。因此，容错解析器就显得十分必要：解析器仍能从不完整的代码中创建有意义的AST，然后语言服务器根据这份AST提供服务。</p>
<p>我们之前在VS Code中做过PHP的支持，我们意识到PHP官方解析器并没有自带容错，而且也不能直接在语言服务器中直接重用。所以我们一起努力做了<a href="https://github.com/Microsoft/tolerant-php-parser"> Microsoft/tolerant-php-parser</a>，并留下了详细的<a href="https://github.com/Microsoft/tolerant-php-parser/blob/master/docs/HowItWorks.md">笔记</a>，或许能帮上需要容错解析器的语言服务器作者。</p>
<h2 id="faq-1"><a class="header" href="#faq-1">FAQ</a></h2>
<ul>
<li>
<p><strong>问：当我试着向debug添加服务器的时候，我得到了&quot;cannot connect to runtime process (timeout after 5000ms)&quot;的信息？</strong></p>
<p>答：如果服务器没有运行你还强行添加debbuger的时候，会出现这个超时问题，你也可能需要关闭服务器中的断点。</p>
</li>
<li>
<p><strong>问：虽然我看完了<a href="https://microsoft.github.io/language-server-protocol/">LSP Specification</a>，但是我还有很多问题解决不了，我可以在哪获得帮助？</strong></p>
<p>答：可以在<a href="https://github.com/Microsoft/language-server-protocol">https://github.com/Microsoft/language-server-protocol</a>中开issue。</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="嵌入语言"><a class="header" href="#嵌入语言">嵌入语言</a></h1>
<hr />
<p>VS Code 为编程语言提供了丰富的功能。就如你在 <a href="language-extensions//language-extensions/language-server-extension-guide">语言服务器</a> 中看到的那样，语言服务器可以支持任何编程语言。但要支持嵌入的语言，我们还要做更多工作。</p>
<p>时至今日，嵌入语言日与俱增，比如：</p>
<ul>
<li>HTML 中的 JavaScript 和 CSS</li>
<li>JavaScript 中的 JSX</li>
<li>模板语法，比如 Vue，Handlebars 和 Razor</li>
<li>PHP 中的 HTML</li>
</ul>
<p>本篇指南着重于实现嵌入语言的各种语言功能。如果你只是对嵌入语言的语法高亮感兴趣，请参考<a href="language-extensions//language-extensions/syntax-highlight-guide">语法高亮指南</a>。</p>
<p>本指南包含两个示例，它们介绍了 2 种构建嵌入语言服务器的方法——<strong>语言服务</strong>和<strong>请求转发</strong>。我们将学习这两个示例，并了解它们各自的优点和缺点。</p>
<p>示例代码见下：</p>
<ul>
<li><a href="https://github.com/microsoft/vscode-extension-samples/tree/master/lsp-embedded-language-service">嵌入语言服务器（语言服务实现）</a></li>
<li><a href="https://github.com/microsoft/vscode-extension-samples/tree/master/lsp-embedded-request-forwarding">嵌入语言服务器（请求转发实现）</a></li>
</ul>
<p>我们先看看我们要构建的嵌入语言服务器实现的效果：</p>
<p><img src="https://code.visualstudio.com/assets/api/language-extensions/embedded-languages/embedded-lsp-sample.gif" alt="embedded languages" /></p>
<p>两个示例都分别配置了一个新的语言——<code>html1</code>。你可以创建一个<code>.html1</code>文件，然后测试下列功能：</p>
<ul>
<li>HTML 标签的自动填充</li>
<li><code>&lt;style&gt;</code>标签中 CSS 的自动填充功能</li>
<li>CSS 语法诊断（仅在<strong>语言服务</strong>实现中可用）</li>
</ul>
<h2 id="语言服务"><a class="header" href="#语言服务">语言服务</a></h2>
<hr />
<p><strong>语言服务</strong>是实现了<a href="https://code.visualstudio.com/api/language-extensions/programmatic-language-features">程序性语言功能</a>的库。<strong>语言服务器</strong>可嵌入到语言服务中，解决嵌入语言的各类问题。</p>
<p>下面是 VS Code 为 HTML 提供的功能大纲：</p>
<ul>
<li>内建的 <a href="https://github.com/microsoft/vscode/tree/master/extensions/html">html 插件</a> 只提供了语法高亮和 HTML 的语言配置能力</li>
<li>内建的 <a href="https://github.com/microsoft/vscode/tree/master/extensions/html-language-features">html 语言功能插件</a>包含 HTML 语言服务器，为 HTML 提供程序性语言特性</li>
<li>HTML 语言服务器使用 <a href="https://github.com/microsoft/vscode-html-languageservice">vscode-html-languageservice</a> 支持 HTML</li>
<li>CSS 语言服务器使用 <a href="https://github.com/microsoft/vscode-css-languageservice">vscode-css-languageservice</a> 支持 HTML 中的 CSS</li>
</ul>
<p>HTML 语言服务器分析 HTML 文档，将其分解为<strong>语言域</strong>，然后使用对应的<strong>语言服务</strong>处理语言服务器的请求。</p>
<p>比如：</p>
<ul>
<li><code>&lt;|</code> 的自动补全请求，HTML 语言服务器使用 HTML 语言服务提供 HTML 的自动补全。</li>
<li><code>&lt;style&gt;.foo { | }&lt;/style&gt;</code> 的自动补全请求，HTML 语言服务器则使用 CSS 语言服务器提供 CSS 补全功能。</li>
</ul>
<p>现在让我们在 <a href="https://github.com/microsoft/vscode-extension-samples/tree/master/lsp-embedded-language-service">lsp-embedded-language-service</a> 示例中检验一下。</p>
<h3 id="语言服务示例"><a class="header" href="#语言服务示例">语言服务示例</a></h3>
<p>!&gt; 注意: 本示例假设你已经掌握了 <a href="https://code.visualstudio.com/api/language-extensions/programmatic-language-features">程序性语言特性</a> 和 <a href="language-extensions//language-extensions/language-server-extension-guide">语言服务器</a> 这2章内容。本示例构建于 <a href="https://github.com/microsoft/vscode-extension-samples/tree/master/lsp-sample">lsp-sample</a></p>
<p>与 <a href="https://github.com/microsoft/vscode-extension-samples/tree/master/lsp-sample">lsp-sample</a> 相同的是，本示例的客户端代码都是一样的。</p>
<p>我们刚刚在上面提到了，服务器会将文档切分为不同的<strong>语言域</strong>，然后分别处理对应的嵌入内容。</p>
<p>我看个简单示例</p>
<pre><code class="language-html">&lt;div&gt;&lt;/div&gt;
&lt;style&gt;.foo { }&lt;/style&gt;
</code></pre>
<p>这个例子里，服务器检测到<code>&lt;style&gt;</code>标签，然后将 <code>.foo{ }</code> 标记为 <strong>CSS 域</strong>。</p>
<p>特定位置产生的自动补全请求，服务器会遵循下列逻辑返回响应对象：</p>
<ul>
<li>如果当前位置属于**“域”**
<ul>
<li>为域中的语言生成一份虚拟文档，其他域则使用空白符填充</li>
</ul>
</li>
<li>如果当前位置不属于任何**“域”**
<ul>
<li>使用 HTML 虚拟文档处理，所有域都视为空白符</li>
</ul>
</li>
</ul>
<p>比如，当我在下列光标位置使用自动补全</p>
<pre><code class="language-html">&lt;div&gt;&lt;/div&gt;
&lt;style&gt;.foo { | }&lt;/style&gt;
</code></pre>
<p>服务器会现当前位置在**“域”**中，然后生成一个虚拟 CSS 文档，该文档包含下面的内容（█ 表示空白符）</p>
<pre><code class="language-html">███████████
███████.foo { | }████████
</code></pre>
<p>服务器随后使用 <code>vscode-css-languageservice</code> 分析该文档，然后计算出一个自动补全项的列表。因为现在内容不包含 HTML 了，所以 CSS 语言服务器就可以轻松地处理了。通过将非CSS 内容替换为空白符，我们就不用手动处理语言事件发生的具体位置和偏移位置了。</p>
<p>处理补全请求的服务端代码：</p>
<pre><code class="language-typescript">connection.onCompletion(async (textDocumentPosition, token) =&gt; {
  const document = documents.get(textDocumentPosition.textDocument.uri);
  if (!document) {
    return null;
  }

  const mode = languageModes.getModeAtPosition(document, textDocumentPosition.position);
  if (!mode || !mode.doComplete) {
    return CompletionList.create();
  }
  const doComplete = mode.doComplete!;

  return doComplete(document, textDocumentPosition.position);
});
</code></pre>
<p>CSS 模型则负责处理落入 CSS 域的所有语言服务器请求</p>
<pre><code class="language-typescript">export function getCSSMode(
  cssLanguageService: CSSLanguageService,
  documentRegions: LanguageModelCache&lt;HTMLDocumentRegions&gt;
): LanguageMode {
  return {
    getId() {
      return 'css';
    },
    doComplete(document: TextDocument, position: Position) {
      // Get virtual CSS document, with all non-CSS code replaced with whitespace
      const embedded = documentRegions.get(document).getEmbeddedDocument('css');
      // Compute a response with vscode-css-languageservice
      const stylesheet = cssLanguageService.parseStylesheet(embedded);
      return cssLanguageService.doComplete(embedded, position, stylesheet);
    }
  };
}
</code></pre>
<p>这是个处理嵌入语言非常简单有效的办法。但是这个方法也有很多问题：</p>
<ul>
<li>你需要持续更新维护<strong>语言服务器</strong>依赖的<strong>语言服务</strong></li>
<li>你的<strong>语言服务器</strong>很难引入一个非同语言实现的<strong>语言服务</strong>。比如用 PHP 实现的 PHP 语言服务器很难接入 TypeScript实现的 <code>vscode-css-languageservice</code>。</li>
</ul>
<p>别急，我们马上来实现 <code>请求转发</code> 解决上面的问题。</p>
<h2 id="请求转发"><a class="header" href="#请求转发">请求转发</a></h2>
<hr />
<p>简单来说，请求转发和语言服务的工作机制是类似的。请求转发方法，也接收语言服务器的请求，计算虚拟文档，然后返回结果。</p>
<p>主要的不同点在于：</p>
<ul>
<li>语言服务使用<strong>库</strong>去响应语言语言服务器，而请求转发则把请求发送回 VS Code 查询所有的语言服务器，然后转发它们的处理结果。</li>
<li>分发工作由语言客户端处理，而不是语言服务器</li>
</ul>
<p>我们再来看下这个例子：</p>
<pre><code class="language-html">&lt;div&gt;&lt;/div&gt;
&lt;style&gt;.foo { | }&lt;/style&gt;
</code></pre>
<p>补全工作的流程像这样：</p>
<ul>
<li>语言客户端为<code>embedded-content</code> 注册一个虚拟文本文档供应器函数（<code>workspace.registerTextDocumentContentProvider</code>）</li>
<li>语言服务器劫取<code>&lt;FILE_URI&gt;</code>的补全请求</li>
<li>语言服务器确定请求位置落入 <strong>CSS 域</strong></li>
<li>语言服务器构建一个新的 URI，比如 <code>embedded-content://css/&lt;FILE_URI&gt;.css</code></li>
<li>然后服务器调用 <code>commands.executeCommand('vscode.executeCompletionItemProvider', ...)</code>
<ul>
<li>VS Code 的 CSS 语言服务器响应该请求</li>
<li>虚拟文本文档供应器函数，给 CSS 语言服务器提供虚拟文档内容，其中所有非 CSS 的代码都已经被替换为空白符</li>
<li>语言客户端接收到 VS Code 的响应，然后返回该响应</li>
</ul>
</li>
</ul>
<p>这样一来，即使我们的代码不包含 CSS 处理库，也能够完成 CSS 的自动补全。而且 VS Code 更新 CSS 语言服务器的时候，我们的插件不用改动一行代码也获得了最新的 CSS 支持。</p>
<p>现在，我们来看看示例代码：</p>
<h3 id="请求转发示例"><a class="header" href="#请求转发示例">请求转发示例</a></h3>
<p>!&gt; 注意: 本示例假设你已经掌握了 <a href="https://code.visualstudio.com/api/language-extensions/programmatic-language-features">程序性语言特性</a> 和 <a href="language-extensions//language-extensions/language-server-extension-guide">语言服务器</a> 这2章内容。本示例构建于 <a href="https://github.com/microsoft/vscode-extension-samples/tree/master/lsp-sample">lsp-sample</a></p>
<p>建立文档 URI 和它们对应虚拟文档的映射，根据这个映射提供对应的请求：</p>
<pre><code class="language-typescript">const virtualDocumentContents = new Map&lt;string, string&gt;();

workspace.registerTextDocumentContentProvider('embedded-content', {
  provideTextDocumentContent: uri =&gt; {
    // 移除前置 `/` 和结尾的 `.css`，获取原始 URI
    const originalUri = uri.path.slice(1).slice(0, -4);
    const decodedUri = decodeURIComponent(originalUri);
    return virtualDocumentContents.get(decodedUri);
  }
});
</code></pre>
<p>通过使用语言客户端的<code>middleware</code>，我们劫持了自动补全请求：</p>
<pre><code class="language-typescript">let clientOptions: LanguageClientOptions = {
  documentSelector: [{ scheme: 'file', language: 'html' }],
  middleware: {
    provideCompletionItem: async (document, position, context, token, next) =&gt; {
      // 如果不在 `&lt;style&gt;`中, 不使用请求转发
      if (
        !isInsideStyleRegion(
          htmlLanguageService,
          document.getText(),
          document.offsetAt(position)
        )
      ) {
        return await next(document, position, context, token);
      }

      const originalUri = document.uri.toString();
      virtualDocumentContents.set(
        originalUri,
        getCSSVirtualContent(htmlLanguageService, document.getText())
      );

      const vdocUriString = `embedded-content://css/${encodeURIComponent(originalUri)}.css`;
      const vdocUri = Uri.parse(vdocUriString);
      return await commands.executeCommand&lt;CompletionList&gt;(
        'vscode.executeCompletionItemProvider',
        vdocUri,
        position,
        context.triggerCharacter
      );
    }
  }
};
</code></pre>
<h2 id="潜在问题"><a class="header" href="#潜在问题">潜在问题</a></h2>
<hr />
<p>当实现嵌入语言服务器的时候，我们会遇到很多问题，到目前为止，我们也没有找到完美的方案，所以当你遇到下面的问题，可别说我们没有事先说过。</p>
<h3 id="很难实现语言特性"><a class="header" href="#很难实现语言特性">很难实现语言特性</a></h3>
<p>通常来说，围绕<strong>语言域</strong>的语言特性都是很难实现的。自动补全或者悬停信息比较容易实现，是因为你可以检测嵌入内容的语言，并计算出一个结果。但是像代码格式化、全局重命名等功能就需要特殊处理了。在格式化功能中，你需要处理缩进和多个<strong>域</strong>各自的的格式化配置问题。在重命名功能中，你也很在众多<strong>域</strong>中找到正确的替换目标。</p>
<h3 id="语言服务器的状态太多而无法嵌入"><a class="header" href="#语言服务器的状态太多而无法嵌入">语言服务器的状态太多而无法嵌入</a></h3>
<p>VS Code 的 HTML 支持提供了 HTML、CSS 和 JavaScript特性。虽然 HTML 和 CSS 的语言服务是无状态的，但是受 TypeScript 服务器加强过的 JavaScript 语言特性就不一样了。我们只在 HTML 文档中的 JavaScript 提供了基本的支持，因为在这个里面，我们很难告诉 TypeScript 这个项目状态到底是什么。比如说，如果出用 <code>&lt;script&gt;</code> 引入了一个CDN 上的 <code>lodash</code> 库，那么其他每个 <code>&lt;script&gt;</code> 脚本中都应该能够使用 <code>_.</code>自动补全。</p>
<h3 id="编码和解码"><a class="header" href="#编码和解码">编码和解码</a></h3>
<p>文件的首要语言和嵌入的语言，他们的编解码和转义规则可能完全不同。比如，根据 <a href="https://www.w3.org/TR/html401/appendix/notes.html#h-B.3.2">HTML 规范</a>，下面的 HTML 文档是无效的：</p>
<pre><code class="language-html">&lt;SCRIPT type=&quot;text/javascript&quot;&gt;
  document.write (&quot;&lt;EM&gt;This won't work&lt;/EM&gt;&quot;)
&lt;/SCRIPT&gt;
</code></pre>
<p>在这个例子里，语言服务器在处理<code>&lt;/</code>时应该转义为<code>&lt;\/</code>才行。</p>
<h2 id="总结"><a class="header" href="#总结">总结</a></h2>
<hr />
<p>我们的这两种方法各有千秋。</p>
<p>语言服务：</p>
<ul>
<li>
<ul>
<li>可获完全掌控语言服务器和用户体验</li>
</ul>
</li>
<li>
<ul>
<li>无需依赖其他语言服务器。所有代码都在一个仓库内完成</li>
</ul>
</li>
<li>
<ul>
<li>语言服务器可被所有 <a href="https://microsoft.github.io/language-server-protocol/implementors/tools/">LSP-兼容的代码编辑器</a> 重用</li>
</ul>
</li>
<li>
<ul>
<li>可能很难嵌入用其他语言实现的语言服务</li>
</ul>
</li>
<li>
<ul>
<li>需要持续维护语言服务依赖来获得新的特性</li>
</ul>
</li>
</ul>
<p>请求转发：</p>
<ul>
<li>
<ul>
<li>避免<strong>嵌入语言服务</strong>与<strong>语言服务器</strong>的非同构的问题（比如，在 Razor 语言服务器嵌入的 C# 编译器去支持 C#）</li>
</ul>
</li>
<li>
<ul>
<li>无需维护上游的语言服务器来获取新功能</li>
</ul>
</li>
<li>
<ul>
<li>无需诊断上游语言服务器的错误</li>
</ul>
</li>
<li>
<ul>
<li>由于缺乏控制，很难和其他语言服务器分享状态信息</li>
</ul>
</li>
<li>
<ul>
<li>多语言特性可能很难实现（比如，当书写 <code>&lt;div class=&quot;foo&quot;&gt;</code> 中的 <code>.foo</code>时提供 CSS 补全）</li>
</ul>
</li>
</ul>
<p>总体来说，我们还是更推荐用嵌入<strong>语言服务</strong>构建嵌入语言服务器，因为这个方法更能掌控用户体验，而且这个服务器还可被任何 LSP 兼容的编辑器复用。但是如果你的场景比较简单，无需上下文、依赖语言服务器的状态或者没有能力打包一个 Node.js 库，那么你也可以考虑使用请求转发的方式。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="插件主机"><a class="header" href="#插件主机">插件主机</a></h1>
<p>你已经在<a href="advanced-topics//get-started/extension-anatomy">插件诊断</a>中学习了插件会将<code>active</code>和<code>deactive</code>声明周期函数暴露给VS Code，在本节我们来看看**插件主机/插件宿主(Extension Host)**是怎么管理所有运行中的插件的。</p>
<p><strong>插件主机</strong>是VS Code中负责加载和运行插件的Node.js进程，虽然你在写插件时不必关心这件事，但是掌握插件主机的运行原理对你创作插件还是非常有用的。</p>
<h2 id="稳定性和性能"><a class="header" href="#稳定性和性能">稳定性和性能</a></h2>
<hr />
<p>VS Code致力于为用户提供一个稳定且高性能的编辑环境，因此出错的插件不应该影响到用户的体验。所以<strong>插件主机</strong>可以预防这些事情：</p>
<ul>
<li>启动性能影响</li>
<li>阻塞的UI操作</li>
<li>修改UI</li>
</ul>
<p>另外，VS Code提供的<a href="advanced-topics//references/activation-events">激活事件机制</a>也让插件只在用到时才懒加载它们，比如，Markdown插件应该只在用户打开了Markdown文件时才启动，因此避免了不必要CPU和内存消耗。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="支持远程开发和-github-代码空间"><a class="header" href="#支持远程开发和-github-代码空间">支持远程开发和 GitHub 代码空间</a></h1>
<p><a href="https://code.visualstudio.com/docs/remote/remote-overview">VS Code 远程开发</a>允许你无缝在远程机器上开发代码。有了这项支持后，你就可以完全使用VS Code本地插件和你熟悉的方式远程工作了。<a href="https://github.com/features/codespaces">GitHub 代码空间</a> 是一项预览功能，它扩展了云端编辑环境，比如浏览器中的编辑器和 VS Code。</p>
<p>为了保证性能，远程开发和 GitHub 代码空间都会在远程运行一些插件。当然，这对插件的运行会产生微妙的影响。大部分插件都不需要刻意去适配远程开发，如果你需要插件在所有环境中都能稳定运行，你可能需要做点功课，但一般来说，改动不会太大。</p>
<p>本节会介绍远程开发相关的知识，<a href="advanced-topics/remote-extensions.html#%E6%9E%B6%E6%9E%84%E5%92%8C%E6%8F%92%E4%BB%B6%E7%B1%BB%E5%9E%8B">VS Code远程开发 插件架构</a>，在远程目录<a href="advanced-topics/remote-extensions.html#%E6%B5%8B%E8%AF%95%E5%92%8C%E8%B0%83%E8%AF%95%E6%8F%92%E4%BB%B6">测试插件</a>，和<a href="advanced-topics/remote-extensions.html#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98">远程插件不能正常工作</a>的一些建议。大部分插件不需要改动就能适应远程开发环境，其他的插件也只要稍微改动一点就能适配远程开发了。</p>
<h2 id="架构和插件类型"><a class="header" href="#架构和插件类型">架构和插件类型</a></h2>
<hr />
<p>为了使远程开发尽力透明化，便于理解，我们可以将插件分为两类：</p>
<ul>
<li><strong>UI 插件：</strong> 这些插件可以配置VS Code的用户界面，而且只运行在用户的本地机器上。UI插件不能直接访问工作区的文件，或者在工作区的机器上运行脚本/工具。这类插件如：主题、代码片段、语言语法、快捷键映射。</li>
<li><strong>工作区插件：</strong> 这类插件运行在工作区所在机器上。当运行在本地时，<em>工作区插件</em>运行在本地机器上；运行在远程项目或代码空间中时，工作区插件运行在远程机器上。工作区插件可以访问工作区的文件并提供富文本支持和多语言服务器，调试和其他复杂的操作（也包含被脚本/工具调起的文件）。不过工作区插件在自定义UI上稍有限制，你可以配置的UI组件有资源管理器，视图容器等其他UI组件。</li>
</ul>
<p>当一个用户安装了一个插件，VS Code会基于插件类型自动让插件安装到正确的环境：UI 插件运行在VS Code的<a href="advanced-topics//advanced-topics/extension-host.html">本地插件主机</a>中，工作区插件则运行在一个非常小的<strong>VS Code 服务器</strong>的<strong>远程插件主机</strong>中。当你打开一个Windows Subsystem for Linux(WSL)、容器、或者远程SSH主机时这个服务会自动安装（更新）。VS Code还会自动管理这个服务的启停，所以用户根本意识不到它的存在。</p>
<p><img src="https://code.visualstudio.com/assets/api/advanced-topics/remote-extensions/architecture.png" alt="architecture" /></p>
<p>VS Code API 会自动运行在正确的机器上（不管是本地还是远程）。但是如果你的插件使用的api不是VS Code提供的——比如运行shell脚本的Node API——当运行在远程时可能不会正常工作，因此我们建议你在所有的环境中测试一下你的插件。</p>
<h2 id="调试插件-1"><a class="header" href="#调试插件-1">调试插件</a></h2>
<hr />
<p>这个部分将说明如何在远程目录下测试和调试插件。在这之前，我们先看一下怎么使用本地<a href="https://code.visualstudio.com/docs/remote/containers">开发容器</a>测试一个插件。本地测试容器是跨平台的，很容易部署，但是限制了访问文件系统的端口。由于只占用了非常小的OS空间，开发容器可以提供最为接近插件的真实运行环境。WSL，换句话说，就是一个典型的最小自治SSH主机。大部分场景下，你只要做小小的调整就可以解决问题了，相关主题查看<a href="advanced-topics/remote-extensions.html#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98">常见问题</a>。</p>
<p>当你学会<a href="advanced-topics/remote-extensions.html#%E5%AE%89%E8%A3%85%E5%BC%80%E5%8F%91%E7%89%88%E6%8F%92%E4%BB%B6">在远程环境安装开发版插件</a>包用于测试，如果你遇到了问题，你可能会想直接在远程环境中调试插件。本章，我们会介绍如何在 <a href="advanced-topics/remote-extensions.html#%E5%9C%A8-github-%E4%BB%A3%E7%A0%81%E7%A9%BA%E9%97%B4%E4%B8%AD%E8%B0%83%E8%AF%95">Github 代码空间</a>、<a href="advanced-topics/remote-extensions.html#%E5%9C%A8%E6%9C%AC%E5%9C%B0%E5%AE%B9%E5%99%A8%E4%B8%AD%E8%B0%83%E8%AF%95">本地容器</a>、<a href="advanced-topics/remote-extensions.html#%E5%9C%A8-ssh-%E4%B8%AD%E8%B0%83%E8%AF%95">SSH 主机</a>、<a href="advanced-topics/remote-extensions.html#%E5%9C%A8-wsl-%E4%B8%AD%E8%B0%83%E8%AF%95">WSL</a> 中编辑、加载、调试你的插件。</p>
<p>通常来说，我们测试的最佳起点就是使用限制端口访问的远程环境（比如使用了防火墙限制端口访问的代码空间、容器或远程 SSH 主机等），因为插件在这些环境中总是任意使用资源。</p>
<h3 id="在-github-代码空间中调试"><a class="header" href="#在-github-代码空间中调试">在 GitHub 代码空间中调试</a></h3>
<p>你可以使用 <a href="https://docs.github.com/github/developing-online-with-codespaces">GitHub 代码空间</a> 预览版 开始你的调试。</p>
<p>遵循以下步骤：</p>
<ol>
<li>安装 <a href="https://marketplace.visualstudio.com/items?itemName=ms-vsonline.vsonline">代码空间</a> 插件</li>
<li>创建一个新的 <a href="https://docs.github.com/github/developing-online-with-codespaces/creating-a-codespace">代码空间</a></li>
<li>如果你还没连接到你的代码空间，用 <code>F1</code> 打开命令面板选择 <strong>Codespaces: Connect to Codespace</strong> 建立连接。</li>
<li>连接好之后，你可以用 <strong>文件 &gt; 打开.../ 打开文件夹...</strong> 选择你插件所在的代码空间，或者使用命令面板的 <strong>Git: Clone</strong> 将代码复制下来，然后打开它。</li>
<li>GitHub 代码空间基于云端环境，所以应该包含了大部分插件所需的预备依赖，你可以在 VS Code 终端窗口中安装任何所需依赖（比如使用 <code>yarn install</code> 或者 <code>apt-get</code>）</li>
<li>最后，按 <code>F5</code> 或者使用 <strong>运行视图</strong> ，在代码空间中加载插件</li>
</ol>
<p>!&gt; 注意：你无法像窗口展示的那样，打开展示出来的插件源代码目录，但是你可以在代码空间中打开子目录或其他位置的目录。</p>
<p>插件开发主机窗口启动后，会将插件运行在 代码空间 中，现在也同时可以使用调试了。</p>
<p><strong>使用基于浏览器的编辑器编辑代码空间</strong></p>
<p>如果你的既有代码空间，也有插件源代码，那么你可以使用<a href="https://docs.github.com/github/developing-online-with-codespaces/developing-in-a-codespace">前往 GitHub portal</a> 连接，或者使用命令面板中的 <strong>Codespaces: Open in Browser</strong> 命令。连接到代码空间之后，你可以在<strong>浏览器中编辑和调试代码</strong>，就像从 VS Code 中操作一样。</p>
<h3 id="在本地容器中调试"><a class="header" href="#在本地容器中调试">在本地容器中调试</a></h3>
<p>遵循以下步骤：</p>
<ol>
<li>请先 <a href="https://code.visualstudio.com/docs/remote/containers#_getting-started">安装和配置 Remote-Container 插件</a>，然后用 **文件 &gt; 打开... / 打开文件夹...**在本地打开你的源代码。</li>
<li>从命令面板中执行 <strong>Remote-Containers: Add Development Container Configuration Files...</strong>，然后选择 <strong>Node.js 8 &amp; TypeScript</strong>(如果你不使用 TypeScript 的话，直接选择 Nodejs 8) 添加所需的容器配置文件</li>
<li>【可选】命令运行之后你可以修改 <code>.devcontainer</code> 文件夹中的内容，配置额外的构建或运行时所需要的东西。请参考 <a href="https://code.visualstudio.com/docs/remote/create-dev-container#_set-up-a-folder-to-run-in-a-container">Remote - Containers</a>查看更多。</li>
<li>运行 <strong>Remote-Containers: Reopen Folder in Container</strong>，此时 VS Code 会初始化容器然后连接。现在你可以在容器中像在本地环境操作那样部署你的源代码了。</li>
<li>在 VS Code 终端窗口(**⌃⇧<code>**)中运行 </code>yarn install<code>或者</code>npm install<code>，配置好 Linux 中的开发环境。你也可以安装其他 OS 或者运行时依赖，但是你也需要把这些东西添加到 </code>.devcontainer/Dockerfile` 中去，这样你在重启容器的时候，配置就不会丢失了。</li>
<li>最后，按下 <code>F5</code> 或者使用 <strong>运行窗口</strong> 在容器中启动插件和调试。</li>
</ol>
<p>!&gt; 注意：你无法像窗口展示的那样，打开展示出来的插件源代码目录，但是你可以在代码空间中打开子目录或其他位置的目录。</p>
<h3 id="在-ssh-中调试"><a class="header" href="#在-ssh-中调试">在 SSH 中调试</a></h3>
<p>遵循以下步骤：</p>
<ol>
<li>请先 <a href="https://code.visualstudio.com/docs/remote/ssh#_getting-started">安装和配置 Remote-SSH 插件</a>，然后执行命令面板中的 **Remote-SSH: Connect to Host...**连接到主机上。</li>
<li>连接好之后，<strong>文件 &gt; 打开... / 打开文件夹...</strong> 打开你插件源代码所在的远程目录。或者使用命令面板的 <strong>Git: Clone</strong> 将代码复制下来，然后打开它。</li>
<li>你可以在 VS Code 终端窗口中安装所需依赖（比如使用 <code>yarn install</code> 或者 <code>apt-get</code>）</li>
<li>最后，按下 <code>F5</code> 或者使用 <strong>运行窗口</strong> 在容器中启动插件和调试。</li>
</ol>
<p>!&gt; 注意：你无法像窗口展示的那样，打开展示出来的插件源代码目录，但是你可以在代码空间中打开子目录或其他位置的目录。</p>
<h3 id="在-wsl-中调试"><a class="header" href="#在-wsl-中调试">在 WSL 中调试</a></h3>
<p>遵循以下步骤：</p>
<ol>
<li>请先 <a href="https://code.visualstudio.com/docs/remote/ssh#_getting-started">安装和配置 Remote-WSL 插件</a>，然后执行命令面板中的 <strong>Remote-WSL: New Window</strong>。</li>
<li>在新出现的窗口中，<strong>文件 &gt; 打开... / 打开文件夹...</strong> 打开你插件源代码所在的远程目录。或者使用命令面板的 <strong>Git: Clone</strong> 将代码复制下来，然后打开它。</li>
</ol>
<p>?&gt; 提示：如果你使用的是 Windows 系统，你可以在 <code>/mnt/c</code> 中克隆代码</p>
<ol start="3">
<li>你可以在 VS Code 终端窗口中安装所需依赖（比如使用 <code>yarn install</code> 或者 <code>apt-get</code>），并确保 Linux 环境已经准备好了 Node 相关的依赖。</li>
<li>最后，按下 <code>F5</code> 或者使用 <strong>运行窗口</strong> 在容器中启动插件和调试。</li>
</ol>
<p>!&gt; 注意：你无法像窗口展示的那样，打开展示出来的插件源代码目录，但是你可以在代码空间中打开子目录或其他位置的目录。</p>
<h2 id="安装开发版插件"><a class="header" href="#安装开发版插件">安装开发版插件</a></h2>
<hr />
<p>目前，VS Code自动在SSH主机、容器、WSL安装插件时会使用插件市场的版本(而不是你本机上当前安装的版本)。大部分时候这么做事合理的，但是我们现在可能需要一个未发布的版本来测试，所以你可以将插件打包成<code>VSIX</code>格式，然后打开已经连接到远程VS Code窗口中手动安装这个插件。</p>
<p>遵循以下步骤：</p>
<ol>
<li>如果这个插件已经发布，你需要将配置文件<code>setting.json</code>设置成<code>&quot;extensions.autoUpdate&quot;: false</code>，阻止插件自动更新到插件市场的最新版本。</li>
<li>下一步，使用<code>vsce package</code>将你的插件打包成VSIX</li>
<li>连接到 <a href="https://docs.github.com/github/developing-online-with-codespaces">代码空间</a>、<a href="https://code.visualstudio.com/docs/remote/containers">开发容器</a>、<a href="https://code.visualstudio.com/docs/remote/ssh">SSH主机</a>或<a href="https://code.visualstudio.com/docs/remote/wsl">WSL环境</a></li>
<li>在你已经连接远程目录的项目中，使用命令 **Install from VSIX...**安装你打包好的插件</li>
<li>完成后重启</li>
</ol>
<p>?&gt; **小提示：**安装完毕后，你可以使用 <strong>Developer: Show Running Extensions</strong>命令查看VS Code在本地运行插件还是在远程运行插件的。</p>
<h2 id="常见问题"><a class="header" href="#常见问题">常见问题</a></h2>
<hr />
<p>VS Code API 会根据项目自动运行在正确的环境上。记住这点，然后我们来看看几个API，它会帮助你避免一些意外问题。</p>
<h4 id="不正确的执行环境"><a class="header" href="#不正确的执行环境">不正确的执行环境</a></h4>
<p>如果你的插件出错了，它有可能是运行在了错误环境中。比较常见的场景是，你原本期望它运行在本地却运行在了远程上。你可以使用命令面板的 <strong>Developer: Show Running Extensions</strong>命令查看插件的运行情况。</p>
<p>如果这个命令显示某个UI 插件被当做工作区插件或者类似的情况，你可以试着在插件的<code>package.json</code>中设置<code>extensionKind</code>属性：</p>
<p>VS Code 1.40 之后，这个值支持使用数组，插件可以定义多种类型。比如：</p>
<pre><code class="language-json">{
  &quot;extensionKind&quot;: [&quot;ui&quot;, &quot;workspace&quot;]
}
</code></pre>
<ul>
<li><code>&quot;extensionKind&quot;: &quot;workspace&quot;</code> —— 表示插件需要访问工作区内容，因此当连接到远程工作区或者代码空间中时，插件会运行到 VS Code 服务器中。大部分插件都是使用该类别。</li>
<li><code>&quot;extensionKind&quot;: &quot;ui&quot;</code> —— 表示插件需要访问本地资源、设备或其他能力，插件被视为 UI 插件，强制在本地运行。无法在 <em>代码空间的编辑器</em> 中运行，因为该环境没有本地插件主机。</li>
<li><code>&quot;extensionKind&quot;: [&quot;ui&quot;, &quot;workspace&quot;]</code> —— 表示插件<strong>优先</strong>以 UI 插件的方式运行，不强制依赖本地资源、设备或其他能力。使用 VS Code 的时候，如果本地插件主机可用，插件会已本地的方式运行，如果工作区插件主机可用，则会以工作区插件的方式运行。当在云端环境使用时，它会运行在远程插件主机中（因为没有本地插件主机可用）。旧的 <code>ui</code> 值作为兼容映射，我们会逐步考虑废弃它。</li>
<li><code>&quot;extensionKind&quot;:[&quot;workspace&quot;, &quot;ui&quot;]</code> —— 表示插件<strong>优先</strong>以 工作区插件的方式运行，但不依赖工作区内容。使用 VS Code 的时候，如果在远程工作区中使用，会以工作区插件运行，本地插件主机可用则在本地运行。当在云端环境使用时，它只会以远程插件主机运行。</li>
</ul>
<p>你也可以在<a href="https://code.visualstudio.com/docs/getstarted/settings">设置</a>中修改 <code>remote.extensionKind</code>插件的类型，这项配置可以立竿见影地看到效果。比如，你想把 <a href="https://marketplace.visualstudio.com/items?itemName=ms-azuretools.vscode-cosmosdb">Azure Cosmos DB</a>插件强制设置为 UI 插件（默认是工作区插件）然后把<a href="https://marketplace.visualstudio.com/items?itemName=msjsdiag.debugger-for-chrome">Debugger for Chrome</a>设置为工作区插件（默认是UI 插件），你可以这么设置：</p>
<pre><code class="language-json">{
  &quot;remote.extensionKind&quot;: {
    &quot;ms-azuretools.vscode-cosmosdb&quot;: &quot;ui&quot;,
    &quot;msjsdiag.debugger-for-chrome&quot;: &quot;workspace&quot;
  }
}
</code></pre>
<p>使用 <code>remote.extensionKind</code>可以快速地测试发行版插件，而不用修改插件的<code>package.json</code>或重新构建插件。</p>
<h4 id="保存插件数据或状态"><a class="header" href="#保存插件数据或状态">保存插件数据或状态</a></h4>
<p>有的时候，你的插件需要保留住不属于<code>settings.json</code>的数据或者独立的工作区配置文件（如<code>.eslintrc</code>），你可以使用插件激活入口的<code>vscode.ExtensionContext</code>对象。如果你的插件已经使用好了这些属性那就应该不会出错。</p>
<p>但是，你的插件如果依赖VS Code的路径约定（如 <code>~/.vscode</code>）或者特定的OS目录（比如Linux上的 <code>~/.config/Code</code>）来保存数据，那你就可能会遇到问题。不过还好这些小问题只要稍加修改插件就能处理掉。</p>
<p>如果你只是想保存一些键值对全局状态信息，你可以使用<code>vscode.ExtensionContext.workspaceState</code>或<code>vscode.ExtensionContext.globalState</code>。如果数据不止键值对且更为复杂，访问<code>globalStoragePath</code>和<code>storagePath</code>可以安全地获取对应的储存路径，供你读写文件。</p>
<p>如何使用我们上面介绍的API:</p>
<pre><code class="language-typescript">import * as vscode from 'vscode';
import * as fs from 'fs';
import * as path from 'path';

export function activate(context: vscode.ExtensionContext) {
    context.subscriptions.push(
        vscode.commands.registerCommand('myAmazingExtension.persistWorkspaceData', () =&gt; {

        // 如果插件所属的工作区不存在储存路径，则创建一个
        if (!fs.existsSync(context.storagePath)) {
            fs.mkdirSync(context.storagePath);
        }

        // 将文件写入储存目录
        fs.writeFileSync(
            path.join(context.storagePath, 'workspace-data.json'),
            JSON.stringify({ now: Date.now() }));
    }));

    context.subscriptions.push(
        vscode.commands.registerCommand('myAmazingExtension.persistGlobalData', () =&gt; {

        // 如果插件所属的全局（跨工作区）文件夹不存在则创建一个
        if (!fs.existsSync(context.globalStoragePath)) {
            fs.mkdirSync(context.globalStoragePath);
        }

        // 为插件创建一个全局储存文件
        fs.writeFileSync(
            path.join(context.globalStoragePath, 'global-data.json'),
            JSON.stringify({ now: Date.now() }));
    }));
}
</code></pre>
<h4 id="保留密钥"><a class="header" href="#保留密钥">保留密钥</a></h4>
<p>如果你的插件需要保留密码或者其他密钥，你可能会想到使用本地操作系统的密钥储存功能（Windows Cert Store、 macOS KeyChain、Linux 的 <code>libsecret</code>-based keyring），而不是使用远程主机的储存功能。更有可能的是，你可能需要在Linux上使用<code>libsecret</code>，在插件中使用<code>gnome-keyring</code>去储存你的密钥，通常来说，这项功能在服务端或者容器内不一定能运作起来。</p>
<p>VS Code本身不提供密钥储存机制，不过需要插件作者会转而使用<a href="https://www.npmjs.com/package/keytar"><code>keytar</code> node module</a>包。因此，VS Code内建了<code>keytar</code>，你在 <em>工作区插件</em> 中如果使用了它，它就会<strong>自动无声</strong>地运行在后台。这样一来你就可以使用本地系统的 keychain/ keyring/ cert store 同时还避免了各种问题。</p>
<p>比如：</p>
<pre><code class="language-typescript">import { env } from 'vscode';
import * as keytarType from 'keytar';

declare const __webpack_require__: typeof require;
declare const __non_webpack_require__: typeof require;
function getNodeModule&lt;T&gt;(moduleName: string): T | undefined {
  const r = typeof __webpack_require__ === 'function' ? __non_webpack_require__ : require;
  try {
    return r(`${env.appRoot}/node_modules.asar/${moduleName}`);
  } catch (err) {
    // 不在ASAR中
  }
  try {
    return r(`${env.appRoot}/node_modules/${moduleName}`);
  } catch (err) {
    // 不可用
  }
  return undefined;
}

// 使用它
const keytar = getNodeModule&lt;typeof keytarType&gt;('keytar');
await keytar.setPassword('my-service-name', 'my-account', 'iamal337d00d');
const password = await keytar.getPassword('my-service-name', 'my-account');
</code></pre>
<h4 id="使用剪贴板"><a class="header" href="#使用剪贴板">使用剪贴板</a></h4>
<p>由于历史原因，大部分插件作者会使用诸如<code>clipboardy</code>等Node.js的包和剪贴板交互。不幸的的是，如果你使用了这样的包，那么它就很有可能会运行在远程机器上。</p>
<p>VS Code 1.30引入的剪贴板则解决了这个问题。它总是运行在本地中，所以同样的，你只要修改你的<code>engines.vscode</code>版本就可以使用这个API了。</p>
<p>在插件中使用剪贴板API：</p>
<pre><code class="language-typescript">import * as vscode from 'vscode';

export function activate(context: vscode.ExtensionContext) {
  context.subscriptions.push(
    vscode.commands.registerCommand('myAmazingExtension.clipboardIt', async () =&gt; {
      // 读取剪贴板
      const text = await vscode.env.clipboard.readText();

      // 写入剪贴板
      await vscode.env.clipboard.writeText(
        `It looks like you're copying &quot;${text}&quot;. Would you like help?`
      );
    })
  );
}
</code></pre>
<h4 id="在本地浏览器或者其他应用中打开些什么"><a class="header" href="#在本地浏览器或者其他应用中打开些什么">在本地浏览器或者其他应用中打开些什么</a></h4>
<p>在本地的场景下，通过使用子进程或者<code>opn</code>包启动浏览器或者其他应用是完全可行的，但是一旦插件运行到了远程上，这就会导致应用加载错误。VS Code远程开发<strong>部分</strong>兼容了<code>opn</code>包使得现有插件可以正常运行。你可以使用URI调用这个包，VS Code会带上这个URL在客户端唤起默认应用。由于不是完整实现，有些配置是不支持的，也不会返回<code>child_process</code>对象。</p>
<p>除了依赖第三方包，我们建议你使用<code>vscode.env.openExternal</code>方法在本地操作系统上启动默认应用打开对应的URI。而且<code>vscode.env.openExternal</code><strong>还支持自动端口转发</strong>！你可以指向到远程的web server上，即使那个端口外部不可访问。</p>
<p>!&gt; 注意：当前代码空间（云编辑器环境）中的转发机制仅支持 <strong>http 和 https</strong>。从转发页面或 JavaScript 代码发送的 Websocket 是无法工作的。不过远程开发和代码空间插件不受此影响，查看 <a href="https://github.com/MicrosoftDocs/vscodespaces/issues/19">MicrosoftDocs/vscodespaces#19</a> 了解更多。</p>
<p>如何使用<code>vscode.env.openExternal</code>API：</p>
<pre><code class="language-typescript">import * as vscode from 'vscode';

export async function activate(context: vscode.ExtensionContext) {
  context.subscriptions.push(
    vscode.commands.registerCommand('myAmazingExtension.openExternal', () =&gt; {
      // 示例 1 - 在默认浏览器中打开VS Code主页
      vscode.env.openExternal(vscode.Uri.parse('https://code.visualstudio.com'));

      // 示例 2 -  打开 localhost HTTP 服务器进行自动转发
      vscode.env.openExternal(vscode.Uri.parse('http://localhost:3000'));

      // 示例 3 - 打开默认email应用
      vscode.env.openExternal(vscode.Uri.parse('mailto:vscode@microsoft.com'));
    })
  );
}
</code></pre>
<h4 id="转发-localhost"><a class="header" href="#转发-localhost">转发 localhost</a></h4>
<p><a href="advanced-topics/remote-extensions.html#%E5%9C%A8%E6%9C%AC%E5%9C%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E6%88%96%E8%80%85%E5%85%B6%E4%BB%96%E5%BA%94%E7%94%A8%E4%B8%AD%E6%89%93%E5%BC%80%E4%BA%9B%E4%BB%80%E4%B9%88"><code>vscode.env.openExternal</code> 中的 localhost 转发机制非常的有用</a>，但是你也会有想要转发一些东西，但是又不想新开一个浏览器窗口或者应用的时候。现在就是<code>vscode.env.asExternalUri</code> 登场的时候了。</p>
<p>!&gt; 注意：当前代码空间（云编辑器环境）中的转发机制仅支持 <strong>http 和 https</strong>。从转发页面或 JavaScript 代码发送的 Websocket 是无法工作的。不过远程开发和代码空间插件不受此影响，查看 <a href="https://github.com/MicrosoftDocs/vscodespaces/issues/19">MicrosoftDocs/vscodespaces#19</a> 了解更多。</p>
<p>使用 <code>vscode.env.asExternalUri</code> API：</p>
<pre><code class="language-typescript">import * as vscode from 'vscode';
import { getExpressServerPort } from './server';

export async function activate(context: vscode.ExtensionContext) {

    const dynamicServerPort = await getWebServerPort();

    context.subscriptions.push(vscode.commands.registerCommand('myAmazingExtension.forwardLocalhost', async () =&gt;

        // 确保端口可用，获取完整的 URI
        const fullUri = await vscode.env.asExternalUri(
            vscode.Uri.parse(`http://localhost:${dynamicServerPort}`));

        // ... 用 fullUri 做点啥 ...
    }));
}
</code></pre>
<p>务必注意被传递回来的的 URI 可能根本不会引用 localhost，所以你必须完整地使用它，尤其当你在使用云编辑器的时候。</p>
<h4 id="回调和-uri-处理程序"><a class="header" href="#回调和-uri-处理程序">回调和 URI 处理程序</a></h4>
<p>插件可通过 <code>vscode.window.registerUriHandler</code> 注册一个自定义的 URI，如果会在浏览器中打开，则触发一个回调事件。URI 处理程序的常见用法是使用 OAuth 2.0 授权服务（比如 Azure AD）提供服务标识。当然你也可以用在外部应用或者浏览器的通信。</p>
<p>远程开发和代码空间插件显式地将 URI 传递到你的插件里，不管它实际运行在哪（本地或远程）。但是，<code>vscode://</code> 这样的 URI 无法在代码空间（云编辑器）中工作，因为浏览器中打开这样的 URI 会试图发送到本地 VS Code 客户端而不是云编辑器上。幸运的是，我们可以通过<code>vscode.env.asExternalUri</code> 补救。</p>
<p>让我们把 <code>vscode.window.registerUriHandler</code> 和 <code>vscode.env.asExternalUri</code> 结合起来，看看这个 OAuth 授权回调通信示例：</p>
<pre><code class="language-typescript">import * as vscode from 'vscode';

// 来自 package.json 中的 ${publisher}.${name}
const extensionId = 'my.amazing-extension';

export async function activate(context: vscode.ExtensionContext) {
  // 注册 URI 处理程序处理授权回调
  vscode.window.registerUriHandler({
    handleUri(uri: vscode.Uri): vscode.ProviderResult&lt;void&gt; {
      // 当授权完成时，运行你想要做的事情
      if (uri.path === '/auth-complete') {
        vscode.window.showInformationMessage('Sign in successful!');
      }
    }
  });

  // 在命令中注册登录事件
  context.subscriptions.push(
    vscode.commands.registerCommand(`${extensionId}.signin`, async () =&gt; {
      // 获取外部回调函数得到 URI，将该 URI 提供给授权处理程序使用
      const callbackUri = await vscode.env.asExternalUri(
        vscode.Uri.parse(`${vscode.env.uriScheme}://${extensionId}/auth-complete`)
      );

      // 将你的代码和授权处理程序整合——此处，我们使用伪代码
      vscode.env.clipboard.writeText(callbackUri.toString());
      await vscode.window.showInformationMessage(
        'Open the URI copied to the clipboard in a browser window to authorize.'
      );
    })
  );
}
</code></pre>
<p>在 VS Code 中运行上例后，<code>vscode://</code> 或 <code>vscode-insiders://</code> 可用作授权处理的回调。在云编辑器环境中运行时，它会连接到 <code>https://*.github.dev</code> URI，无需改变任何代码或分支语句。</p>
<p>如果你的 OAuth 场景超出了本文档，你可以适当修改本例。你也可以在处理程序之前再构建一个代理服务，因为并不是所有处理程序都允许 <code>vscode://</code> 这样的回调 URI，而且有些可能不允许使用域名通配符当作回调（比如 HTTPS）。为了提升回调的安全性，我们建议只要在能够使用的场景下，尽量使用 <a href="https://oauth.net/2/pkce/">带 PKCE 流的 OAuth 2.0 授权码</a>。</p>
<h4 id="在远程或-codespace-浏览器编辑器中运行时改变行为"><a class="header" href="#在远程或-codespace-浏览器编辑器中运行时改变行为">在远程或 Codespace 浏览器编辑器中运行时改变行为</a></h4>
<p>有的时候，你的工作区插件可能需要在远程/云代码环境的运行期间改变行为。VS Code 提供了 3 个 API 检测这些情况：<code>vscode.env.uiKind</code>、<code>extension.extensionKind</code>、<code>vscode.env.remoteName</code>。</p>
<p>你可以像这样使用这些 API:</p>
<pre><code class="language-typescript">import * as vscode from 'vscode';

export async function activate(context: vscode.ExtensionContext) {
  // 当本地运行时 extensionKind 返回 ExtensionKind.UI，所以可以用来检测是否在远程运行
  const extension = vscode.extensions.getExtension('your.extensionId');
  if (extension.extensionKind === vscode.ExtensionKind.Workspace) {
    vscode.window.showInformationMessage('I am running remotely!');
  }

  // 云编辑器环境运行时 uiKind 会返回 UIKind.Web
  if (vscode.env.uiKind === vscode.UIKind.Web) {
    vscode.window.showInformationMessage('I am running in the Codespaces browser editor!');
  }

  // 在本地工作区运行时，remoteName 会返回 undefined
  if (typeof vscode.env.remoteName === 'undefined') {
    vscode.window.showInformationMessage('Not currently connected to a remote workspace.');
  }
}
</code></pre>
<h4 id="使用命令在插件间通信"><a class="header" href="#使用命令在插件间通信">使用命令在插件间通信</a></h4>
<p>一些插件意在被其他插件调用（通过<code>vscode.extension.getExtension(extensionName).exports</code>），因此会在激活时返回一些API。如果这些插件都在同一环境（都是UI插件，或者都是工作区插件时）下工作不会出什么问题，但是如果一个是UI插件，一个是工作区插件就会出问题了。</p>
<p>如果你的插件需要彼此产生交互，使用私有命令暴露功能可以避免一些问题。不过记住一点，所有你传入的对象参数都会被字符串化（<code>JSON.stringify</code>），因此这些对象不可以有循环引用，这会导致接受方只收到一个&quot;字符串化的object类型&quot;。</p>
<p>示例：</p>
<pre><code class="language-typescript">import * as vscode from 'vscode';

export async function activate(context: vscode.ExtensionContext) {
  // 注册私有命令
  const echoCommand = vscode.commands.registerCommand(
    '_private.command.called.echo',
    (value: string) =&gt; {
      return value;
    }
  );
  context.subscriptions.push(echoCommand);
}
</code></pre>
<p>使用命令的更多细节，请参考<a href="advanced-topics//extension-guides/command.html">命令API指南</a></p>
<h2 id="使用webview-api"><a class="header" href="#使用webview-api">使用Webview API</a></h2>
<hr />
<p>就像剪贴板API，<a href="advanced-topics//extension-guides/webview.html">Webview API</a>也总是运行在本地环境，即使是 <em>工作区插件</em> 调用的。也就是说大部分基于webview的插件都可以正常工作，但是还有些注意事项需要交代一下。</p>
<h4 id="请使用-aswebviewuri"><a class="header" href="#请使用-aswebviewuri">请使用 asWebviewUri</a></h4>
<p>你应该使用 <code>asWebviewUri</code> 管理插件资源。不要硬编码<code>vscode-resource://</code>，而是使用 <code>asWebviewUri</code> 确保你的插件在云端环境也能正常运行。请参考<a href="https://code.visualstudio.com/api/extension-guides/webview">Webview API</a>，不过我们先来快速地看一个例子：</p>
<pre><code class="language-typescript">// 创建 webview
const panel = vscode.window.createWebviewPanel(
  'catWebview',
  'Cat Webview',
  vscode.ViewColumn.One
);

// 获取内容的 Uri
const catGifUri = panel.webview.asWebviewUri(
  vscode.Uri.file(path.join(context.extensionPath, 'media', 'cat.gif'))
);

// 在你的内容中引用它
panel.webview.html = `&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;body&gt;
    &lt;img src=&quot;${catGifUri}&quot; width=&quot;300&quot; /&gt;
&lt;/body&gt;
&lt;/html&gt;`;
</code></pre>
<h4 id="为动态的-webview-内容使用消息传递"><a class="header" href="#为动态的-webview-内容使用消息传递">为动态的 webview 内容使用消息传递</a></h4>
<p>VS Code 中，webview包含一个 <a href="advanced-topics//extension-guides/webview?id=%E8%84%9A%E6%9C%AC%E5%92%8C%E4%BF%A1%E6%81%AF%E4%BC%A0%E9%80%92">message passing</a>API，你无需使用本地的 web 服务器，它就能帮你动态更新webview 的内容。通过这个 API，你可以直接在插件中操作，而不是直接操作 HTML。</p>
<p>这对于远程开发和云环境来说是个非常重要的安全模式。</p>
<p><strong>为什么使用消息传递，而不是本地 web 服务器</strong></p>
<p>这个模式的替代方案是使用 <code>iframe</code> 或者和让本地服务器提供 webview。不幸的是，webview 中的 <code>localhost</code> 默认解析到开发者的本地机器上，也就是说如果工作区插件运行在远程，webview 是无法获得插件生成的本地服务器的。即使你使用机器的 IP 地址 ，端口也会被云虚拟机或容器默认屏蔽掉。虽然它能在 VS Code 中运行，但不代表这个机制能在云环境中运行。</p>
<p>我们来看一下示意图</p>
<p><img src="https://code.visualstudio.com/assets/api/advanced-topics/remote-extensions/webview-problem.png" alt="webview to remote" /></p>
<p>即使看起来能走的通，你也应该尽量不要做这种事，因为你的插件会变得更复杂。<a href="advanced-topics//extension-guides/webview?id=%E8%84%9A%E6%9C%AC%E5%92%8C%E4%BF%A1%E6%81%AF%E4%BC%A0%E9%80%92">消息传递</a>可以做到同样的用户体验，而且不会有这些头疼的问题。</p>
<h4 id="从-webview-访问localhost"><a class="header" href="#从-webview-访问localhost">从 webview 访问localhost</a></h4>
<p>如果你不用 使用 webview的<a href="advanced-topics//extension-guides/webview?id=%E8%84%9A%E6%9C%AC%E5%92%8C%E4%BF%A1%E6%81%AF%E4%BC%A0%E9%80%92">message passing</a>，那么还有 2 种方法帮你解决远程开发和代码空间插件的问题。但因为 <a href="https://github.com/MicrosoftDocs/vscodespaces/issues/11">MicrosoftDocs/vscodespaces#11</a>，这两种方法目前都无法支持云编辑器。</p>
<p>这两种方式都允许 webview 内容通过特定信道路由到 VS Code 服务器上。比如，如果我们更新一下上面的图，我们就会得到：</p>
<p><img src="https://code.visualstudio.com/assets/api/advanced-topics/remote-extensions/webview-solution.png" alt="Access to remote" /></p>
<p><strong>方法 1 - 使用 asExternalUri</strong></p>
<p>VS Code 1.40 引入了 <code>vscode.env.asExternalUri</code>，插件可以通过程序式的方法将本地的 http 和 https 请求转发到远程。所以你也可以用这个API 把 webview 的请求转发到本地 web 服务器上。未来，如果你只需要在 iframe 中使用远程服务，你可以通过这个功能支持代码空间中的云编辑器，只是该功能当前因为 <a href="https://github.com/MicrosoftDocs/vscodespaces/issues/11">MicrosoftDocs/vscodespaces#11</a>被屏蔽了。</p>
<p>!&gt; 注意: 除了上面的这些问题，当前代码空间（云编辑器环境）中的转发机制仅支持 <strong>http 和 https</strong>。从转发页面或 JavaScript 代码发送的 Websocket 是无法工作的。不过远程开发和代码空间插件不受此影响，查看 <a href="https://github.com/MicrosoftDocs/vscodespaces/issues/19">MicrosoftDocs/vscodespaces#19</a> 了解更多。</p>
<p>使用 API 获取 iframe 完整的 URI，你还需要在 webview 中为这个功能启用 CSP。</p>
<pre><code class="language-typescript">// 使用 asExternalUri 获得 web 服务器的 URI
const dynamicWebServerPort = await getWebServerPort();
const fullWebServerUri = await vscode.env.asExternalUri(
  vscode.Uri.parse(`http://localhost:${dynamicWebServerPort}`)
);

// 新建 webview
const panel = vscode.window.createWebviewPanel(
  'asExternalUriWebview',
  'asExternalUri Example',
  vscode.ViewColumn.One,
  {
    enableScripts: true
  }
);

const cspSource = panel.webview.cspSource;
panel.webview.html = `&lt;!DOCTYPE html&gt;
        &lt;head&gt;
            &lt;meta
                http-equiv=&quot;Content-Security-Policy&quot;
                content=&quot;default-src 'none'; frame-src ${fullWebServerUri} ${cspSource} https:; img-src ${cspSource} https:; script-src ${cspSource}; style-src ${cspSource};&quot;
            /&gt;
        &lt;/head&gt;
        &lt;body&gt;
        &lt;!-- All content from the web server must be in an iframe --&gt;
        &lt;iframe src=&quot;${fullWebServerUri}&quot;&gt;
    &lt;/body&gt;
    &lt;/html&gt;`;
</code></pre>
<p>注意任何被服务器启动的 iframe 中（包含上例）都<strong>需要使用相对路径</strong>，而不是<code>localhost</code>这样的硬编码。</p>
<p><strong>方法 2 - 使用端口映射</strong></p>
<p>如果你不想支持代码空间中的云编辑器，你还可以 <strong>添加端口映射</strong> 告诉webview哪些端口可以直接转发到远程机器上。</p>
<p>端口映射可以将webview所使用的localhost端口映射到远程插件启动的任意端口上。如果你的 <em>工作区插件</em> 运行在远程，而且你也定义了端口映射，那么这些流量会自动、安全地转发到远程机器上。如果你的插件只是运行在本地，端口映射则会将一个localhost端口重新映射到另一个端口上。Webview端口映射同时支持<em>UI插件</em>和<em>工作区插件</em>，也同时支持本地和远程环境。</p>
<p>使用端口映射，只要在你创建的webview中添加传入一个<code>portMapping</code>对象即可：</p>
<pre><code class="language-typescript">const LOCAL_STATIC_PORT = 3000;
const dynamicServerPort = await getWebServerPort();

// 创建webview然后传入portMapping
const panel = vscode.window.createWebviewPanel(
  'remoteMappingExample',
  'Remote Mapping Example',
  vscode.ViewColumn.One,
  {
    portMapping: [
      // 这里映射了 webview 的 localhost:3000 到远程主机的 express 服务器端口
      { webviewPort: LOCAL_STATIC_PORT, extensionHostPort: dynamicServerPort }
    ]
  }
);

// 你可以在HTML中使用&quot;webviewPort&quot;查看端口
panel.webview.html = `&lt;!DOCTYPE html&gt;
    &lt;body&gt;
        &lt;!-- This will resolve to the dynamic server port on the remote machine --&gt;
        &lt;img src=&quot;http://localhost:${LOCAL_STATIC_PORT}/canvas.png&quot;&gt;
    &lt;/body&gt;
    &lt;/html&gt;`;
</code></pre>
<p>现在不管是远程还是本地的请求，webview前往<code>localhost:3000</code>的流量都会走到Express.js web 服务器上了。</p>
<h2 id="使用原生nodejs模块"><a class="header" href="#使用原生nodejs模块">使用原生Node.js模块</a></h2>
<hr />
<p>和插件打包（或动态引入的包）的原生node包会被<a href="https://electronjs.org/docs/tutorial/using-native-node-modules">Electorn的<code>electron-rebuild</code></a>重新编译。但是VS Code Server运行在一个标准的（非Electron）的Node.js中，因此可能造成远程二进制库失效问题。</p>
<p>解决这个问题需要：</p>
<ol>
<li>同时引入Node.js和Elctron标准的两种二进制包（别忘了动态引入的包）。</li>
<li>检查<code>vscode.extensions.getExtension('your.extensionId').extensionKind === vscode.ExtensionKind.Workspace</code>是否根据环境使用了正确的包。</li>
<li>如果你想支持非x86_64构建目标和Alpine Linux则遵循[下述类似逻辑](#为非x86_64主机或Apline Linux容器提供支持)。</li>
</ol>
<p>使用VS Code的 <strong>Help &gt; Developer Tools</strong>然后在控制台（console）中打印<code>process.versions.modules</code>可以找到VS Code使用的模块（modules）类型。如果你想要确保原生模块在各个Node.js环境中都能无缝运行，你可能把所有可能支持的平台（Electron Node.js, 官方Node.js Windows/Darwin/Linux的全部版本）相关的包全部引入。<a href="https://github.com/tree-sitter/node-tree-sitter/releases/tag/v0.14.0">node-tree-sitter</a>包在这方面是个非常好的例子。</p>
<h2 id="为非x86_64主机或apline-linux容器提供支持"><a class="header" href="#为非x86_64主机或apline-linux容器提供支持">为非x86_64主机或Apline Linux容器提供支持</a></h2>
<hr />
<p>如果你的插件只是用JavasSript/TypeScript写的，你的插件可能什么都不用做就能支持其他进程架构或基于<code>musl</code>的Apline Linux。</p>
<p>但是如果你的插件可以运行在Debian 9+, Ubuntu 16.04+, 或者基于 RHEL / CentOS 7+ 的远程SSH主机、容器或 WSL上，却无法支持非x86_64(比如 ARMv7l)或Alpine Linux容器，插件可能需要包含了x86_64的<code>glibc</code>特定机器码或运行时，所以导致了这些架构/操作系统上出现问题。</p>
<p>比如，你的插件坑包含了x86_64编译的原生模块或运行时版本。对于Alpine Linux来说就是因<a href="https://wiki.musl-libc.org/functional-differences-from-glibc.html">基础架构差异</a>而无法运行这样的插件。</p>
<p>为了解决这个问题：</p>
<ol>
<li>如果你是动态引入编译码，你可以用<code>process.arch</code>检测环境，然后根据对应架构下载对应架构下的依赖。如果你已经在插件中直接使用了二进制包，你也可以用同样的逻辑使用正确的包。</li>
<li>对于Alpine Linux来说，你可以用<code>await fs.exists('/etc/alpine-release')</code>检测操作系统，然后下载或者使用基于<code>musl</code>的正确的二进制包。</li>
<li>如果你不想支持这些平台，你也可以用同样的逻辑提供良好的错误提示。</li>
</ol>
<p>你要非常注意一些第三方包可能依赖了导致这个问题的源码包。所以有时候你需要联系npm包作者提供额外的编译版本。</p>
<h2 id="避免使用electron模块"><a class="header" href="#避免使用electron模块">避免使用Electron模块</a></h2>
<hr />
<p>虽然依赖未暴露的内置Electron或者VS Code模块非常方便，但是你必须知道VS Code Server运作在标准的（非Electron）Node.js环境中，当插件运行在远程时就会丢失这些包。除了少数个例，比如<a href="advanced-topics/remote-extensions.html#%E4%BF%9D%E7%95%99%E5%AF%86%E9%92%A5">keytar</a>，用了特殊的实现所以在所有环境中都能正常工作。</p>
<p>使用基于Node.js的模块从而避免这些问题。如果你一定要用Electron模块，那就要确保如果包丢失的时候提供合适的后备方案。</p>
<p>下面的例子使用了Electron的<code>original-fs</code>包，缺失时则使用Node.js的<code>fs</code>模块。</p>
<pre><code class="language-typescript">function requireWithFallback(electronModule: string, nodeModule: string) {
  try {
    return require(electronModule);
  } catch (err) {}
  return require(nodeModule);
}

const fs = requireWithFallback('original-fs', 'fs');
</code></pre>
<p>但是不论何时，你都应该避免这些问题。</p>
<h2 id="已知问题"><a class="header" href="#已知问题">已知问题</a></h2>
<hr />
<p>目前我们还有些影响 工作区插件 功能的问题亟待解决。见<a href="https://code.visualstudio.com/api/advanced-topics/remote-extensions#known-issues">原文档 - 已知问题</a></p>
<h2 id="faq-2"><a class="header" href="#faq-2">FAQ</a></h2>
<hr />
<ul>
<li>查看<a href="https://code.visualstudio.com/docs/remote/troubleshooting">提示和解决方法</a>或者<a href="https://code.visualstudio.com/docs/remote/faq">FAQ</a></li>
<li>在 <a href="https://stackoverflow.com/questions/tagged/vscode-remote">Stack Overflow</a>上查找答案</li>
<li><a href="https://aka.ms/vscode-remote/feature-requests">支持或者新建一项功能</a>，查看<a href="https://aka.ms/vscode-remote/issues">已知问题</a>，或者<a href="https://aka.ms/vscode-remote/issues/new">报告问题</a></li>
<li>贡献一个<a href="https://aka.ms/vscode-dev-containers">开发容器配置</a>方便大家使用</li>
<li>贡献<a href="https://github.com/Microsoft/vscode-docs">文档</a>或者<a href="https://github.com/Microsoft/vscode">VS Code</a></li>
<li>查看我们的<a href="https://aka.ms/vscode-remote/contributing">贡献</a>指南查看更多详情</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="使用不稳定的api"><a class="header" href="#使用不稳定的api">使用不稳定的API</a></h1>
<p>在VS Code中，插件API的兼容性非常重要，我们尽最大努力避免API变动以便插件开发人员已经发布的插件可以按预期工作。但是，这对使得我们束手束脚，一旦新的API发布后，就不可能再轻易改动。</p>
<p>不稳定的API（Proposed API）则解决了这个问题，不稳定的API是VS Code已经实现但是还未公开的API。它们只在Insider版的VS Code中可用，而且很有可能再次产生变动，你也不能在想要发布的插件中使用。不管怎样，插件开发者开始可以在本地开发时测试这些API，然后给VS Code团队提供建议的，经过不断修改之后最终可能出现在稳定版中。</p>
<h2 id="使用不稳定的api-1"><a class="header" href="#使用不稳定的api-1">使用不稳定的API</a></h2>
<p>下面是在本地开发中测试未稳定API的步骤：</p>
<ul>
<li>使用 VS Code的<a href="https://code.visualstudio.com/insiders">Insider</a>版本</li>
<li>在<code>package.json</code>中添加<code>&quot;enableProposedApi&quot;: true</code></li>
<li>把最新的<a href="https://github.com/Microsoft/vscode/blob/master/src/vs/vscode.proposed.d.ts"><code>vscode.proposed.d.ts</code></a>复制到你的项目中</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vs-code-api"><a class="header" href="#vs-code-api">VS Code API</a></h1>
<p><strong>VS Code API</strong>是VS Code提供给插件使用的一系列Javascript API。</p>
<p>!&gt; 注意：VS Code API 变动较快，翻译版本的参与人员和精力有限无法保证实时跟进，有需要的小伙伴请自行参考<a href="https://code.visualstudio.com/api/references/vscode-api">官方文档</a>，其中包含了完整而且是最新的VS Code API列表。</p>
<h2 id="api模式"><a class="header" href="#api模式">API模式</a></h2>
<hr />
<p>以下将介绍我们在VS Code中经常使用的API模式。</p>
<h4 id="promises异步"><a class="header" href="#promises异步">Promises（异步）</a></h4>
<p>VS Code API完全采用了promise的实现。对于插件来说允许任何promise形式的返回格式，如ES6，WinJS，A+等。</p>
<p>一个promise库需要它的API使用<code>Thenable</code>类型来表达，<code>Thenable</code>类型代表了一种通用特性的实现——then方法。</p>
<p>大多数时候promise是一个可选项，VS Code调用插件之后，它能直接处理正常的返回结果也能处理<code>Thenable</code>的结果类型。当promise是可选的API返回结果时，API会在返回类型中用<code>Thenable</code>表示。</p>
<pre><code class="language-typescript">provideNumber(): number | Thenable&lt;number&gt;
</code></pre>
<h4 id="cancellation-tokens取消式令牌"><a class="header" href="#cancellation-tokens取消式令牌">Cancellation Tokens（取消式令牌）</a></h4>
<p>有些事件可能从不稳定的变化状态开始，而随着状态变化这一事件最后肯能被取消了。比如：IntelliSense（智能补全）被触发后，用户持续输入的行为使得这一操作最终被取消了。</p>
<p>API也为这种行为提供了解决方案，你可以通过<code>CancellationToken</code>检查取消的状态（<code>isCancellationRequested</code>）或者当<em>取消</em>发生时得到通知（<code>onCancellationRequested</code>）。取消式令牌通常是API函数的最后一个（可选）参数。</p>
<h4 id="disposables释放器"><a class="header" href="#disposables释放器">Disposables（释放器）</a></h4>
<p>VS Code API使用了<a href="https://en.wikipedia.org/wiki/Dispose_pattern">释放器模式</a>，这个模式被用于事件侦听，命令，UI交互和各类语言配置上。</p>
<p>例如：<code>setStatusBarMessage(value: string)</code>事件返回一个<code>Disposable</code>对象，这个对象最终调用<code>dispose</code>方法移除message。</p>
<h4 id="events事件"><a class="header" href="#events事件">Events（事件）</a></h4>
<p>事件在API中被暴露为函数，当你订阅一个事件侦听器时绑定。事件侦听器调用后会返回一个<code>Disposable</code>，它会在dispose触发后，移除事件侦听器。</p>
<pre><code class="language-typescript">var listener = function(event) {
    console.log(&quot;It happened&quot;, event);
};

// 开始侦听
var subscription = fsWatcher.onDidDelete(listener);

// 你的代码

subscription.dispose(); // 停止侦听
</code></pre>
<p>事件的命名规则遵循<code>on[Will | Did] 动词 + 名词</code>的形式。通过<code>onWill</code>表示将要发生，<code>onDid</code>表示已经发生，<code>动词</code>表示行为，<code>名词</code>指代上下文或目标。</p>
<p>举个栗子：<code>window.onDidChangeActiveTextEditor</code>中，激活的编辑器（ActiveTextEditor：<code>名词</code>）变动（change：<code>动词</code>）后（<code>onDid</code>）会触发事件。</p>
<h4 id="严格null检查"><a class="header" href="#严格null检查">严格null检查</a></h4>
<p>VS CodeAPI使用<code>undefined</code>和<code>null</code>的Typescript类型，同样也支持<a href="https://github.com/Microsoft/TypeScript/pull/7140">严格null检查</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="发布内容配置-1"><a class="header" href="#发布内容配置-1">发布内容配置</a></h1>
<p>发布内容配置（即VS Code为插件扩展提供的配置项）是<code>pacakge.json</code><a href="https://code.visualstudio.com/api/references/extension-manifest">插件清单</a>的<code>contributes</code>字段，你可以在其中注册各种配置项扩展VS Code的能力。下面是目前可用的配置项列表：</p>
<ul>
<li><a href="references/contribution-points.html#%E5%8F%91%E5%B8%83%E5%86%85%E5%AE%B9%E9%85%8D%E7%BD%AE">发布内容配置</a>
<ul>
<li><a href="references/contribution-points.html#-contributesconfiguration">## contributes.configuration</a>
<ul>
<li><a href="references/contribution-points.html#%E7%A4%BA%E4%BE%8B">示例</a></li>
</ul>
</li>
<li><a href="references/contribution-points.html#-contributesconfigurationdefaults">## contributes.configurationDefaults</a>
<ul>
<li><a href="references/contribution-points.html#%E7%A4%BA%E4%BE%8B-1">示例</a></li>
</ul>
</li>
<li><a href="references/contribution-points.html#-contributescommands">## contributes.commands</a>
<ul>
<li><a href="references/contribution-points.html#%E7%A4%BA%E4%BE%8B-2">示例</a></li>
</ul>
</li>
<li><a href="references/contribution-points.html#-contributesmenus">## contributes.menus</a>
<ul>
<li><a href="references/contribution-points.html#%E7%A4%BA%E4%BE%8B-3">示例</a></li>
<li><a href="references/contribution-points.html#%E8%AE%A9%E8%8F%9C%E5%8D%95%E9%A1%B9%E5%8F%AA%E6%98%BE%E7%A4%BA%E5%9C%A8%E5%91%BD%E4%BB%A4%E9%9D%A2%E6%9D%BF%E4%B8%AD">让菜单项只显示在命令面板中</a></li>
<li><a href="references/contribution-points.html#%E5%88%86%E7%BB%84%E6%8E%92%E5%BA%8F">分组排序</a></li>
<li><a href="references/contribution-points.html#%E7%BB%84%E5%86%85%E6%8E%92%E5%BA%8F">组内排序</a></li>
</ul>
</li>
<li><a href="references/contribution-points.html#-contributeskeybindings">## contributes.keybindings</a>
<ul>
<li><a href="references/contribution-points.html#%E7%A4%BA%E4%BE%8B-4">示例</a></li>
</ul>
</li>
<li><a href="references/contribution-points.html#-contributeslanguages">## contributes.languages</a>
<ul>
<li><a href="references/contribution-points.html#%E7%A4%BA%E4%BE%8B-5">示例</a></li>
</ul>
</li>
<li><a href="references/contribution-points.html#-contributesdebuggers">## contributes.debuggers</a>
<ul>
<li><a href="references/contribution-points.html#%E7%A4%BA%E4%BE%8B-6">示例</a></li>
</ul>
</li>
<li><a href="references/contribution-points.html#-contributesbreakpoints">## contributes.breakpoints</a></li>
<li><a href="references/contribution-points.html#-contributesgrammars">## contributes.grammars</a>
<ul>
<li><a href="references/contribution-points.html#%E7%A4%BA%E4%BE%8B-7">示例</a></li>
</ul>
</li>
<li><a href="references/contribution-points.html#-contributesthemes">## contributes.themes</a>
<ul>
<li><a href="references/contribution-points.html#%E7%A4%BA%E4%BE%8B-8">示例</a></li>
</ul>
</li>
<li><a href="references/contribution-points.html#-contributessnippets">## contributes.snippets</a>
<ul>
<li><a href="references/contribution-points.html#%E7%A4%BA%E4%BE%8B-9">示例</a></li>
</ul>
</li>
<li><a href="references/contribution-points.html#-contributesjsonvalidation">## contributes.jsonValidation</a>
<ul>
<li><a href="references/contribution-points.html#%E7%A4%BA%E4%BE%8B-10">示例</a></li>
</ul>
</li>
<li><a href="references/contribution-points.html#-contributesviews">## contributes.views</a>
<ul>
<li><a href="references/contribution-points.html#%E7%A4%BA%E4%BE%8B-11">示例</a></li>
</ul>
</li>
<li><a href="references/contribution-points.html#contributesviewswelcome">contributes.viewsWelcome</a></li>
<li><a href="references/contribution-points.html#-contributesviewscontainers">## contributes.viewsContainers</a>
<ul>
<li><a href="references/contribution-points.html#%E7%A4%BA%E4%BE%8B-12">示例</a></li>
</ul>
</li>
<li><a href="references/contribution-points.html#-contributesproblemmatchers">## contributes.problemMatchers</a>
<ul>
<li><a href="references/contribution-points.html#%E7%A4%BA%E4%BE%8B-13">示例</a></li>
</ul>
</li>
<li><a href="references/contribution-points.html#-contributesproblempatterns">## contributes.problemPatterns</a></li>
<li><a href="references/contribution-points.html#-contributestaskdefinitions">## contributes.taskDefinitions</a></li>
<li><a href="references/contribution-points.html#-contributescolors">## contributes.colors</a></li>
<li><a href="references/contribution-points.html#-contributestypescriptserverplugins">## contributes.typescriptServerPlugins</a></li>
<li><a href="references/contribution-points.html#%E4%B8%8B%E4%B8%80%E6%AD%A5">下一步</a></li>
</ul>
</li>
</ul>
<h2 id="contributesconfiguration"><a class="header" href="#contributesconfiguration">contributes.configuration</a></h2>
<hr />
<p>在configuration中配置的内容会暴露给用户，用户可以从“用户设置”和“工作区设置”中修改你暴露的选项。</p>
<p>configuration是JSON格式的键值对，用户会在修改设置时获得对应的提示和更好的体验。</p>
<p>你可以用<code>vscode.workspace.getConfiguration('myExtension')</code>读取配置值。</p>
<p>?&gt; 小提示：配置<code>markdownDescription</code>比配置<code>description</code>更好，它能呈现Markdown格式的文档。</p>
<h4 id="示例-1"><a class="header" href="#示例-1">示例</a></h4>
<pre><code class="language-json">&quot;contributes&quot;: {
    &quot;configuration&quot;: {
        &quot;type&quot;: &quot;object&quot;,
        &quot;title&quot;: &quot;TypeScript configuration&quot;,
        &quot;properties&quot;: {
            &quot;typescript.useCodeSnippetsOnMethodSuggest&quot;: {
                &quot;type&quot;: &quot;boolean&quot;,
                &quot;default&quot;: false,
                &quot;description&quot;: &quot;Complete functions with their parameter signature.&quot;
            },
            &quot;typescript.tsdk&quot;: {
                &quot;type&quot;: [&quot;string&quot;, &quot;null&quot;],
                &quot;default&quot;: null,
                &quot;description&quot;: &quot;Specifies the folder path containing the tsserver and lib*.d.ts files to use.&quot;
            }
        }
    }
}
</code></pre>
<p><img src="https://media.githubusercontent.com/media/Microsoft/vscode-docs/master/api/references/images/contribution-points/configuration.png" alt="configuration" /></p>
<h2 id="contributesconfigurationdefaults"><a class="header" href="#contributesconfigurationdefaults">contributes.configurationDefaults</a></h2>
<hr />
<p>为特定的语言配置编辑器的默认值，修改这个配置会覆盖编辑器已经为语言提供的默认配置。</p>
<p>下面的示例是修改<code>markdown</code>语言的默认配置。</p>
<h4 id="示例-2"><a class="header" href="#示例-2">示例</a></h4>
<pre><code class="language-json">&quot;contributes&quot;: {
    &quot;configurationDefaults&quot;: {
        &quot;[markdown]&quot;: {
            &quot;editor.wordWrap&quot;: &quot;on&quot;,
            &quot;editor.quickSuggestions&quot;: false
        }
    }
}
</code></pre>
<h2 id="contributescommands"><a class="header" href="#contributescommands">contributes.commands</a></h2>
<hr />
<p>设置命令标题和命令体，随后这个命令会显示在<strong>命令面板</strong>中。你也可以加上<code>category</code>前缀，在<strong>命令面板</strong>中会以分类显示。</p>
<p>?&gt;<strong>注意：<strong>当调用命令时（通过组合键或者在</strong>命令面板</strong>中调用），VS Code会触发激活事件<code>onCommand:${command}</code>。</p>
<p>下面的示例是修改<code>markdown</code>语言的默认配置。</p>
<h4 id="示例-3"><a class="header" href="#示例-3">示例</a></h4>
<pre><code class="language-json">&quot;contributes&quot;: {
    &quot;commands&quot;: [{
        &quot;command&quot;: &quot;extension.sayHello&quot;,
        &quot;title&quot;: &quot;Hello World&quot;,
        &quot;category&quot;: &quot;Hello&quot;
    }]
}
</code></pre>
<p>?&gt; <strong>提示</strong>: 想了解更多的有关于在VS Code插件开发中使用命令, 请参阅<a href="references//extension-guides/command">命令</a>章节</p>
<p><img src="https://media.githubusercontent.com/media/Microsoft/vscode-docs/master/api/references/images/contribution-points/commands.png" alt="commands" /></p>
<h2 id="contributesmenus"><a class="header" href="#contributesmenus">contributes.menus</a></h2>
<hr />
<p>为编辑器或者文件管理器设置命令的<em>菜单项</em>。菜单项至少包含1️⃣选中时调用的命令和2️⃣何时显示这个菜单项的时机。显示菜单的时机由<code>when</code>键定义，而对应的值语法需要参考键值绑定的<a href="https://github.com/Microsoft/vscode-docs/blob/master/docs/getstarted/keybindings.md#when-clause-contexts">when语法</a>。</p>
<p><code>command</code>键则是必须的。可选的命令使用<code>alt</code>定义，当你按下ALT键时，菜单中会显示对应的菜单项。</p>
<p>最后，<code>group</code>属性定义了菜单的分组。<code>navigation</code>值不同于普通的<code>group</code>值，一旦设置这个值就会总是显示在菜单的最顶端。</p>
<p>当前插件创作者可以配置的菜单的地方有：</p>
<ul>
<li>全局命令面板 - <code>commandPalette</code></li>
<li>资源管理器上下文菜单 - <code>explorer/context</code></li>
<li>编辑器上下文菜单 - <code>editor/context</code></li>
<li>编辑器标题栏 - <code>editor/title</code></li>
<li>编辑器标题上下文菜单 - <code>editor/title/context</code></li>
<li>调试栈视图的上下文菜单 - <code>debug/callstack/context</code></li>
<li><a href="references/extensibility-reference/api-scm.html#%E8%8F%9C%E5%8D%95">SCM 标题菜单</a> - <code>scm/title</code></li>
<li><a href="references/extensibility-reference/api-scm.html#%E8%8F%9C%E5%8D%95">SCM 资源组</a> - <code>scm/resourceGroup/context</code></li>
<li><a href="references/extensibility-reference/api-scm.html#%E8%8F%9C%E5%8D%95">SCM 资源</a> - <code>scm/resource/context</code></li>
<li><a href="references/extensibility-reference/api-scm.html#%E8%8F%9C%E5%8D%95">SCM 改变标题</a> - <code>scm/change/title</code></li>
<li><a href="references/contribution-points.html#contributesviews">视图的标题菜单</a> - <code>view/title</code></li>
<li><a href="references/contribution-points.html#contributesviews">视图项的菜单</a> - <code>view/item/context</code></li>
</ul>
<p>?&gt;**注意：**当菜单中的命令被调用，VS Code会将当前选中资源作为参数传给调用的命令。比方说，资源管理器的菜单被触发，选中资源的URI会作为参数，编辑器中的菜单项被触发，则将当前文件的URI作为参数传入。</p>
<p>关于<em>标题</em>还有一点要说，命令还可以定义图标，VS Code会显示在编辑器的标题菜单栏中。</p>
<h4 id="示例-4"><a class="header" href="#示例-4">示例</a></h4>
<pre><code class="language-json">&quot;contributes&quot;: {
    &quot;menus&quot;: {
        &quot;editor/title&quot;: [{
            &quot;when&quot;: &quot;resourceLangId == markdown&quot;,
            &quot;command&quot;: &quot;markdown.showPreview&quot;,
            &quot;alt&quot;: &quot;markdown.showPreviewToSide&quot;,
            &quot;group&quot;: &quot;navigation&quot;
        }]
    }
}
</code></pre>
<p><img src="https://media.githubusercontent.com/media/Microsoft/vscode-docs/master/api/references/images/contribution-points/menus.png" alt="menus" /></p>
<h4 id="让菜单项只显示在命令面板中"><a class="header" href="#让菜单项只显示在命令面板中">让菜单项只显示在命令面板中</a></h4>
<p>注册的命令默认显示在<strong>命令面板</strong>中。要想控制命令的可见性，我们提供了一个<code>commandPalette</code>菜单配置，在这个配置中，你可以定义一个<code>when</code>控制是否在<strong>命令菜单</strong>中显示。</p>
<p>下面的片段只在编辑器中选中了什么东西的时候才会在<strong>命令面板</strong>中显示出‘Hello World’：</p>
<pre><code class="language-json">&quot;commands&quot;: [{
    &quot;command&quot;: &quot;extension.sayHello&quot;,
    &quot;title&quot;: &quot;Hello World&quot;
}],
&quot;menus&quot;: {
    &quot;commandPalette&quot;: [{
        &quot;command&quot;: &quot;extension.sayHello&quot;,
        &quot;when&quot;: &quot;editorHasSelection&quot;
    }]
}
</code></pre>
<h4 id="分组排序"><a class="header" href="#分组排序">分组排序</a></h4>
<p>菜单项可以通过组来分类。根据下列默认规则，然后按照字母排序，</p>
<p><strong>编辑器上下文菜单</strong>默认有这些分组：</p>
<ul>
<li><code>navigation</code> - <code>navigation</code>组始终在最上方。</li>
<li><code>1_modification</code> - 紧接上一个组，这个组包含可以修改你代码的命令。</li>
<li><code>9_cutcopypaste</code> - 然后是基础编辑命令。</li>
<li><code>z_commands</code> - 最后一个分组则是命令面板入口。</li>
</ul>
<p><img src="https://media.githubusercontent.com/media/Microsoft/vscode-docs/master/api/references/images/contribution-points/groupSorting.png" alt="groupSorting" /></p>
<p><strong>资源管理器上下文菜单</strong>默认有下列分组：</p>
<ul>
<li><code>navigation</code> -  在VS Code中导航的相关命令。<code>navigation</code>组始终在最上方。</li>
<li><code>2_workspace</code> - 和工作区操作相关的命令。</li>
<li><code>3_compare</code> - 比较文件和diff相关的命令。</li>
<li><code>4_search</code> - 在搜索视图中和搜索相关的命令。</li>
<li><code>5_cutcopypaste</code> - 和剪切、复制、粘贴文件相关的命令。</li>
<li><code>7_modification</code> - 修改文件的相关命令。</li>
</ul>
<p><strong>编辑器标签菜单</strong>默认有下列分组</p>
<ul>
<li>1_close - 和关闭编辑器相关的命令。</li>
<li>3_preview - 和固定编辑器相关的命令。</li>
</ul>
<p><strong>编辑器标题菜单</strong>默认有下列分组</p>
<ul>
<li>1_diff - diff编辑器相关的命令。</li>
<li>3_open - 打开编辑器的相关命令。</li>
<li>5_close - 和关闭编辑器相关的命令。</li>
</ul>
<h4 id="组内排序"><a class="header" href="#组内排序">组内排序</a></h4>
<p>组内的菜单顺序取决于标题或者<em>序号属性</em>。菜单的组内顺序由<code>@&lt;number&gt;</code>加到<code>group</code>值的后面得以确定：</p>
<pre><code class="language-json">&quot;editor/title&quot;: [{
    &quot;when&quot;: &quot;editorHasSelection&quot;,
    &quot;command&quot;: &quot;extension.Command&quot;,
    &quot;group&quot;: &quot;myGroup@1&quot;
}]
</code></pre>
<h2 id="contributeskeybindings"><a class="header" href="#contributeskeybindings">contributes.keybindings</a></h2>
<hr />
<p>这个配置确定了用户输入按键组合时的触发规则。在<a href="https://code.visualstudio.com/docs/getstarted/keybindings">快捷键绑定</a>中，你可以了解更加细节的东西。</p>
<p>配置快捷键绑定会使<em>默认键盘快捷方式</em>中显示你的规则，每一处和命令相关的UI部分也会显示你添加的快捷键组合。</p>
<p>?&gt;<strong>注意</strong>因为VS Code支持Windows，macOS和Linux平台，而</p>
<h4 id="示例-5"><a class="header" href="#示例-5">示例</a></h4>
<p>Windows和Linux下使用<code>Ctrl+F1</code>，macOS下使用<code>Cmd+F1</code>调用<code>&quot;extension.sayHello&quot;</code>命令：</p>
<pre><code class="language-json">&quot;contributes&quot;: {
    &quot;keybindings&quot;: [{
        &quot;command&quot;: &quot;extension.sayHello&quot;,
        &quot;key&quot;: &quot;ctrl+f1&quot;,
        &quot;mac&quot;: &quot;cmd+f1&quot;,
        &quot;when&quot;: &quot;editorTextFocus&quot;
    }]
}
</code></pre>
<p><img src="https://media.githubusercontent.com/media/Microsoft/vscode-docs/master/api/references/images/contribution-points/keybindings.png" alt="keybindings" /></p>
<h2 id="contributeslanguages"><a class="header" href="#contributeslanguages">contributes.languages</a></h2>
<hr />
<p>配置一门语言，引入一门新的语言或者加强VS Code已有的语言支持。</p>
<p>在这部分内容中，一个语言必须要有一个标识符（identifier）关联到文件上（查看 <code>TextDocument.getLanguageId()</code>）。</p>
<p>VS Code提供三种文件应该关联哪种语言的方式。每种方式都可以可以“单独”加强：</p>
<ol>
<li>插件的文件名</li>
<li>文件名</li>
<li>文件内的首行</li>
</ol>
<p>用户打开文件后，三种规则都会使用，然后确定语言。接着VS Code就会触发激活事件<code>onLanguage:${language}</code>（比如：下面的<code>onLanguage:python</code>例子）</p>
<p><code>aliases</code>属性包含着这门语言的可读性名称。这个列表的第一项会作为语言标签（在VS Code右下角状态栏显示）。</p>
<p><code>configuration</code>属性确定了语言配置文件的路径。路径是指相对插件文件夹的路径，通常是<code>./language-configuration.json</code>，这个文件是JSON格式的，包含着下列可配置属性：</p>
<ul>
<li><code>comments</code> - 定义了注释的符号
<ul>
<li><code>blockComment</code> - 用于标识块注释的起始和结束token。被'Toggle Block Comment'使用</li>
<li><code>lineComment</code> - 用于标识行注释的起始token。被'Add Line Comment'使用</li>
</ul>
</li>
<li><code>brackets</code> - 定义括号，同时也会影响括号内的代码缩进。进入新的一行时，被编辑器用来确定或是更正新的缩进距离</li>
<li><code>autoClosingPairs</code> - 为<em>自动闭合功能</em>定义某个符号的开闭符（open and close symbols）。<em>开符号</em>输入后，编辑器会自动插入<em>闭符号</em>。使用<code>notIn</code>参数，关闭字符串或者注释中的<em>符号对</em></li>
<li><code>surroundingPairs</code> - 定义选中文本的开闭符号</li>
<li><code>folding</code> - 定义编辑器中的代码应何时、应怎么样折叠
<ul>
<li><code>offSide</code> - 和一下个缩进块之间的代码块尾部的空行（用于基于缩进的语言，如Python or F#）</li>
<li><code>markers</code> - 使用正则自定义代码中的折叠区域标识符</li>
</ul>
</li>
<li><code>wordPattern</code> - 使用正则匹配编程语言中哪些词应该是单个词</li>
</ul>
<p>如果你的语言配置文件是<code>language-configuration.json</code>，或者以这样的字符串结尾的，VS Code就会提供校验和编辑支持。</p>
<h4 id="示例-6"><a class="header" href="#示例-6">示例</a></h4>
<pre><code class="language-json">...
&quot;contributes&quot;: {
    &quot;languages&quot;: [{
        &quot;id&quot;: &quot;python&quot;,
        &quot;extensions&quot;: [ &quot;.py&quot; ],
        &quot;aliases&quot;: [ &quot;Python&quot;, &quot;py&quot; ],
        &quot;filenames&quot;: [ ... ],
        &quot;firstLine&quot;: &quot;^#!/.*\\bpython[0-9.-]*\\b&quot;,
        &quot;configuration&quot;: &quot;./language-configuration.json&quot;
    }]
}
</code></pre>
<p>language-configuration.json</p>
<pre><code class="language-json">{
    &quot;comments&quot;: {
        &quot;lineComment&quot;: &quot;//&quot;,
        &quot;blockComment&quot;: [ &quot;/*&quot;, &quot;*/&quot; ]
    },
    &quot;brackets&quot;: [
        [&quot;{&quot;, &quot;}&quot;],
        [&quot;[&quot;, &quot;]&quot;],
        [&quot;(&quot;, &quot;)&quot;]
    ],
    &quot;autoClosingPairs&quot;: [
        [&quot;{&quot;, &quot;}&quot;],
        [&quot;[&quot;, &quot;]&quot;],
        [&quot;(&quot;, &quot;)&quot;],
        { &quot;open&quot;: &quot;'&quot;, &quot;close&quot;: &quot;'&quot;, &quot;notIn&quot;: [&quot;string&quot;, &quot;comment&quot;] },
        { &quot;open&quot;: &quot;/**&quot;, &quot;close&quot;: &quot; */&quot;, &quot;notIn&quot;: [&quot;string&quot;] }
    ],
    &quot;surroundingPairs&quot;: [
        [&quot;{&quot;, &quot;}&quot;],
        [&quot;[&quot;, &quot;]&quot;],
        [&quot;(&quot;, &quot;)&quot;],
        [&quot;&lt;&quot;, &quot;&gt;&quot;],
        [&quot;'&quot;, &quot;'&quot;]
    ],
    &quot;folding&quot;: {
        &quot;offSide&quot;: true,
        &quot;markers&quot;: {
            &quot;start&quot;: &quot;^\\s*//#region&quot;,
            &quot;end&quot;: &quot;^\\s*//#endregion&quot;
        }
    },
    &quot;wordPattern&quot;: &quot;(-?\\d*\\.\\d\\w*)|([^\\`\\~\\!\\@\\#\\%\\^\\&amp;\\*\\(\\)\\-\\=\\+\\[\\{\\]\\}\\\\\\|\\;\\:\\'\\\&quot;\\,\\.\\&lt;\\&gt;\\/\\?\\s]+)&quot;
}
</code></pre>
<h2 id="contributesdebuggers"><a class="header" href="#contributesdebuggers">contributes.debuggers</a></h2>
<hr />
<p>配置VS Code的调试器，调试器配置有下列属性：</p>
<ul>
<li><code>type</code> 用于加载配置的调试器唯一标识——ID。</li>
<li><code>label</code> 会在UI中显示的调试器名称。</li>
<li><code>program</code> 调试适配的路径，调试适配通过VS Code debug protocol连接到真正的调试器或者运行时。</li>
<li><code>runtime</code> 如果调试适配器的路径不是可执行程序，那么就会用到这个运行时。</li>
<li><code>configurationAttributes</code> 调试器的启动配置参数。</li>
<li><code>initialConfigurations</code> 列出了初始化launch.json需要的加载配置。</li>
<li><code>configurationSnippets</code> 列出了编辑launch.json文件时可以提供的加载配置智能提示。</li>
<li><code>variables</code> 引入替代变量，并绑定到调试器插件实现的命令上。</li>
<li><code>languages</code> 调试插件会使用“默认调试器”的语言</li>
<li><code>adapterExecutableCommand</code> 调试适配器执行路径和参数动态计算的命令。命令返回的格式如下：
<pre><code class="language-json">command: &quot;&lt;executable&gt;&quot;,
args: [ &quot;&lt;argument1&gt;&quot;, &quot;&lt;argument2&gt;&quot;, ... ]
</code></pre>
<code>command</code>属性必须是一个可执行程序的<strong>绝对路径</strong>，或者是通过PATH环境变量可以查找到可执行程序的名称。使用特殊值<code>node</code>，则会映射到VS Code内建的node运行时，而不会在PATH中查找。</li>
</ul>
<h4 id="示例-7"><a class="header" href="#示例-7">示例</a></h4>
<pre><code class="language-json">&quot;contributes&quot;: {
    &quot;debuggers&quot;: [{
        &quot;type&quot;: &quot;node&quot;,
        &quot;label&quot;: &quot;Node Debug&quot;,

        &quot;program&quot;: &quot;./out/node/nodeDebug.js&quot;,
        &quot;runtime&quot;: &quot;node&quot;,

        &quot;languages&quot;: [&quot;javascript&quot;, &quot;typescript&quot;, &quot;javascriptreact&quot;, &quot;typescriptreact&quot;],

        &quot;configurationAttributes&quot;: {
            &quot;launch&quot;: {
                &quot;required&quot;: [ &quot;program&quot; ],
                &quot;properties&quot;: {
                    &quot;program&quot;: {
                        &quot;type&quot;: &quot;string&quot;,
                        &quot;description&quot;: &quot;The program to debug.&quot;
                    }
                }
            }
        },

        &quot;initialConfigurations&quot;: [{
            &quot;type&quot;: &quot;node&quot;,
            &quot;request&quot;: &quot;launch&quot;,
            &quot;name&quot;: &quot;Launch Program&quot;,
            &quot;program&quot;: &quot;${workspaceFolder}/app.js&quot;
        }],

        &quot;configurationSnippets&quot;: [
            {
                &quot;label&quot;: &quot;Node.js: Attach Configuration&quot;,
                &quot;description&quot;: &quot;A new configuration for attaching to a running node program.&quot;,
                &quot;body&quot;: {
                    &quot;type&quot;: &quot;node&quot;,
                    &quot;request&quot;: &quot;attach&quot;,
                    &quot;name&quot;: &quot;${2:Attach to Port}&quot;,
                    &quot;port&quot;: 9229
                }
            }
        ],

        &quot;variables&quot;: {
            &quot;PickProcess&quot;: &quot;extension.node-debug.pickNodeProcess&quot;
        }
    }]
}
</code></pre>
<p>想要完整地学习<code>debugger</code>，移步至<a href="references//extension-authoring/example-debug-adapter.html">调试器</a></p>
<h2 id="contributesbreakpoints"><a class="header" href="#contributesbreakpoints">contributes.breakpoints</a></h2>
<hr />
<p>通常调试器插件会有<code>contributes.breakpoints</code>入口，插件可以在这里面设置哪些语言可以设置断点。</p>
<pre><code class="language-json">&quot;contributes&quot;: {
    &quot;breakpoints&quot;: [
        {
            &quot;language&quot;: &quot;javascript&quot;
        },
        {
            &quot;language&quot;: &quot;javascriptreact&quot;
        }
    ]
}
</code></pre>
<h2 id="contributesgrammars"><a class="header" href="#contributesgrammars">contributes.grammars</a></h2>
<hr />
<p>为一门语言配置TextMate语法。你必须提供应用语法的<code>language</code>，TextMate的<code>scopeName</code>确定了语法和文件路径。</p>
<p>!&gt;**注意：**包含语法的文件必须是JSON（以.json结尾的文件）或者XML的plist格式文件。</p>
<h4 id="示例-8"><a class="header" href="#示例-8">示例</a></h4>
<pre><code class="language-json">&quot;contributes&quot;: {
    &quot;grammars&quot;: [{
        &quot;language&quot;: &quot;markdown&quot;,
        &quot;scopeName&quot;: &quot;text.html.markdown&quot;,
        &quot;path&quot;: &quot;./syntaxes/markdown.tmLanguage.json&quot;,
        &quot;embeddedLanguages&quot;: {
            &quot;meta.embedded.block.frontmatter&quot;: &quot;yaml&quot;,
            ...
        }
    }]
}
</code></pre>
<p>查看<a href="references//language-extensions/syntax-highlight-guide">语法高亮指南</a>学习更多从现有的语法高亮插件迁移的内容。</p>
<p><img src="https://media.githubusercontent.com/media/Microsoft/vscode-docs/master/api/references/images/contribution-points/grammars.png" alt="grammars" /></p>
<h2 id="contributesthemes"><a class="header" href="#contributesthemes">contributes.themes</a></h2>
<hr />
<p>为VS Code添加TextMate主题。你必须添加一个label，指定这个主题是dark还是light的（以便VS Code根据你的主题调整界面），当然还需要加上目标文件路径（XML plist 格式）。</p>
<p>!&gt;**注意：**包含语法的文件必须是JSON（以.json结尾的文件）或者XML的plist格式文件。</p>
<h4 id="示例-9"><a class="header" href="#示例-9">示例</a></h4>
<pre><code class="language-json">&quot;contributes&quot;: {
    &quot;themes&quot;: [{
        &quot;label&quot;: &quot;Monokai&quot;,
        &quot;uiTheme&quot;: &quot;vs-dark&quot;,
        &quot;path&quot;: &quot;./themes/Monokai.tmTheme&quot;
    }]
}
</code></pre>
<p><img src="https://media.githubusercontent.com/media/Microsoft/vscode-docs/master/api/references/images/contribution-points/themes.png" alt="themes" /></p>
<p>查看<a href="references/docs/extension-authoring/themes-snippets-colorizers.html">改变色彩主题</a>学习使用<a href="references//extension-authoring/extension-generator.html">yo code插件生成器</a>将TextMate.tmTheme文件快速打包成VS Code插件。</p>
<h2 id="contributessnippets"><a class="header" href="#contributessnippets">contributes.snippets</a></h2>
<hr />
<p>为语言添加代码片段。<code>language</code>属性必须是<a href="https://code.visualstudio.com/docs/languages/identifiers">语言标识符</a>而<code>path</code>则必须是使用<a href="https://code.visualstudio.com/docs/editor/userdefinedsnippets#_snippet-syntax">VS Code代码片段格式</a>的代码片段文件的相对路径。</p>
<h4 id="示例-10"><a class="header" href="#示例-10">示例</a></h4>
<p>下面是一个Go语言的代码片段：</p>
<pre><code class="language-json">&quot;contributes&quot;: {
    &quot;snippets&quot;: [{
        &quot;language&quot;: &quot;go&quot;,
        &quot;path&quot;: &quot;./snippets/go.json&quot;
    }]
}
</code></pre>
<h2 id="contributesjsonvalidation"><a class="header" href="#contributesjsonvalidation">contributes.jsonValidation</a></h2>
<hr />
<p>为<code>json</code>文件添加校验器。<code>url</code>值可以是本地路径也可以是插件中的模式文件（schema file），或者是远程服务器的URL比如：<a href="http://schemastore.org/json">json schema</a></p>
<h4 id="示例-11"><a class="header" href="#示例-11">示例</a></h4>
<pre><code class="language-json">&quot;contributes&quot;: {
    &quot;jsonValidation&quot;: [{
        &quot;fileMatch&quot;: &quot;.jshintrc&quot;,
        &quot;url&quot;: &quot;http://json.schemastore.org/jshintrc&quot;
    }]
}
</code></pre>
<h2 id="contributesviews"><a class="header" href="#contributesviews">contributes.views</a></h2>
<hr />
<p>为VS Code 添加视图。你需要为视图指定唯一标识和名称。可以配置的属性如下：</p>
<ul>
<li><code>explorer</code>: 活动栏中的资源管理视图容器。</li>
<li><code>scm</code>: 活动栏中的源代码管理(SCM) 视图容器。</li>
<li><code>debug</code>: 活动栏中的调试视图容器。</li>
<li><code>test</code>: 活动栏中的测试视图容器。</li>
<li><a href="references/contribution-points.html#contributesviewscontainers">Custom view containers</a> 由插件提供的自定义视图容器。</li>
</ul>
<p>当用户打开视图，VS Code会触发<code>onView:${viewId}</code>激活事件（比如：下面示例中的<code>onView:nodeDependencies</code>）。你也可以用<code>when</code>控制视图的可见性。</p>
<h4 id="示例-12"><a class="header" href="#示例-12">示例</a></h4>
<pre><code class="language-json">&quot;contributes&quot;: {
    &quot;views&quot;: {
        &quot;explorer&quot;: [
            {
                &quot;id&quot;: &quot;nodeDependencies&quot;,
                &quot;name&quot;: &quot;Node Dependencies&quot;,
                &quot;when&quot;: &quot;workspaceHasPackageJSON&quot;
            }
        ]
    }
}
</code></pre>
<p><img src="https://media.githubusercontent.com/media/Microsoft/vscode-docs/master/api/references/images/contribution-points/views.png" alt="views" /></p>
<p>插件创作者应该通过<code>createTreeView</code>API提供的<a href="https://code.visualstudio.com/docs/extensionAPI/vscode-api#TreeDataProvider">data provider</a>创建一个<a href="https://code.visualstudio.com/docs/extensionAPI/vscode-api#TreeView">TreeView</a>或者直接使用<code>registerTreeDataProvider</code>注册一个<a href="https://code.visualstudio.com/docs/extensionAPI/vscode-api#TreeDataProvider">data provider</a>。更多示例参考<a href="https://github.com/Microsoft/vscode-extension-samples/tree/master/tree-view-sample">这里</a></p>
<h2 id="contributesviewswelcome"><a class="header" href="#contributesviewswelcome">contributes.viewsWelcome</a></h2>
<p>给<a href="references/">自定义视图</a>配置欢迎内容。欢迎内容只能应用到空的树视图中。如果一个树视图中没有任何子树数据时，才是空的树视图。按照约定，任何单独成行的链接会被展示为按钮。你可以配置<code>view</code>属性，指定欢迎页展示的位置。欢迎页的可见性可通过<code>when</code>语句和变量值配置。展示在欢迎页的内容，可通过<code>contents</code>属性配置。</p>
<pre><code class="language-json">{
  &quot;contributes&quot;: {
    &quot;viewsWelcome&quot;: [
      {
        &quot;view&quot;: &quot;scm&quot;,
        &quot;contents&quot;: &quot;In order to use git features, you can open a folder containing a git repository or clone from a URL.\n[Open Folder](command:vscode.openFolder)\n[Clone Repository](command:git.clone)\nTo learn more about how to use git and source control in VS Code [read our docs](https://aka.ms/vscode-scm).&quot;,
        &quot;when&quot;: &quot;config.git.enabled &amp;&amp; git.state == initialized &amp;&amp; workbenchState == empty&quot;
      }
    ]
  }
}
</code></pre>
<p><img src="https://code.visualstudio.com/assets/api/references/contribution-points/viewsWelcome.png" alt="Welcome content example" /></p>
<p>一个视图可以展示多条欢迎内容，当出现这类场景时，VS Code 内置的内容会优先呈现，然后是插件提供欢迎内容，最后是来自其他插件的内容。</p>
<h2 id="contributesviewscontainers"><a class="header" href="#contributesviewscontainers">contributes.viewsContainers</a></h2>
<hr />
<p>配置<a href="references//references/contribution-points#contributesviews">自定义视图</a>的视图容器。你需要为视图指定唯一标识和标题和图标。目前你只可以配置活动栏（activitybar），下面的示例展示了活动栏中的<code>Package Explorer</code>视图容器应该如何配置。</p>
<h4 id="示例-13"><a class="header" href="#示例-13">示例</a></h4>
<pre><code class="language-json">&quot;contributes&quot;: {
    &quot;viewsContainers&quot;: {
        &quot;activitybar&quot;: [
            {
                &quot;id&quot;: &quot;package-explorer&quot;,
                &quot;title&quot;: &quot;Package Explorer&quot;,
                &quot;icon&quot;: &quot;resources/package-explorer.svg&quot;
            }
        ]
    },
    &quot;views&quot;: {
        &quot;package-explorer&quot;: [
            {
                &quot;id&quot;: &quot;package-dependencies&quot;,
                &quot;name&quot;: &quot;Dependencies&quot;
            },
            {
                &quot;id&quot;: &quot;package-outline&quot;,
                &quot;name&quot;: &quot;Outline&quot;
            }
        ]
    }
}
</code></pre>
<p><img src="https://media.githubusercontent.com/media/Microsoft/vscode-docs/master/api/references/images/contribution-points/custom-views-container.png" alt="custom-views-container" /></p>
<p><strong>图标规格</strong></p>
<ul>
<li><code>Size:</code> 28x28的图标居中于50x40的视图块上。</li>
<li><code>Color:</code> 图标应使用黑白单色。</li>
<li><code>Format:</code> 虽然图片格式的图标都是可以的，但建议使用SVG图标。</li>
<li><code>States:</code> 所有图标状态继承下列样式：</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>State</th><th>Opacity</th></tr></thead><tbody>
<tr><td>Default</td><td>60%</td></tr>
<tr><td>Hover</td><td>100%</td></tr>
<tr><td>Active</td><td>100%</td></tr>
</tbody></table>
</div>
<h2 id="contributesproblemmatchers"><a class="header" href="#contributesproblemmatchers">contributes.problemMatchers</a></h2>
<hr />
<p>配置问题定位器的模式。这些配置在输出面板和终端中都会有所体现，下面是一个配置了插件中的gcc编译器的问题定位器示例：</p>
<h4 id="示例-14"><a class="header" href="#示例-14">示例</a></h4>
<pre><code class="language-json">&quot;contributes&quot;: {
    &quot;problemMatchers&quot;: [
        {
            &quot;name&quot;: &quot;gcc&quot;,
            &quot;owner&quot;: &quot;cpp&quot;,
            &quot;fileLocation&quot;: [&quot;relative&quot;, &quot;${workspaceFolder}&quot;],
            &quot;pattern&quot;: {
                &quot;regexp&quot;: &quot;^(.*):(\\d+):(\\d+):\\s+(warning|error):\\s+(.*)$&quot;,
                &quot;file&quot;: 1,
                &quot;line&quot;: 2,
                &quot;column&quot;: 3,
                &quot;severity&quot;: 4,
                &quot;message&quot;: 5
            }
        }
    ]
}
</code></pre>
<p>这个问题定位器现在可以通过名称引用<code>$gcc</code>在<code>task.json</code>中使用了，示例如下：</p>
<pre><code class="language-json">{
    &quot;version&quot;: &quot;2.0.0&quot;,
    &quot;tasks&quot;: [
        {
            &quot;label&quot;: &quot;build&quot;,
            &quot;command&quot;: &quot;gcc&quot;,
            &quot;args&quot;: [&quot;-Wall&quot;, &quot;helloWorld.c&quot;, &quot;-o&quot;, &quot;helloWorld&quot;],
            &quot;problemMatcher&quot;: &quot;$gcc&quot;
        }
    ]
}
</code></pre>
<p>更多内容请查看：<a href="https://code.visualstudio.com/docs/editor/tasks#_defining-a-problem-matcher">实现一个问题定位器</a></p>
<h2 id="contributesproblempatterns"><a class="header" href="#contributesproblempatterns">contributes.problemPatterns</a></h2>
<hr />
<p>配置可以在问题定位器（见上）中可以使用的问题模式的名称。</p>
<h2 id="contributestaskdefinitions"><a class="header" href="#contributestaskdefinitions">contributes.taskDefinitions</a></h2>
<hr />
<p>配置和定义一个object结构，定义系统中唯一的<em>配置任务</em>。任务定义最少需要一个<code>type</code>属性，不过通常需要更多的属性配置。
在package.json文件中，<em>一个展示脚本的任务</em>看起来是这样的：</p>
<pre><code class="language-json">&quot;taskDefinitions&quot;: [
    {
        &quot;type&quot;: &quot;npm&quot;,
        &quot;required&quot;: [
            &quot;script&quot;
        ],
        &quot;properties&quot;: {
            &quot;script&quot;: {
                &quot;type&quot;: &quot;string&quot;,
                &quot;description&quot;: &quot;The script to execute&quot;
            },
            &quot;path&quot;: {
                &quot;type&quot;: &quot;string&quot;,
                &quot;description&quot;: &quot;The path to the package.json file. If omitted the package.json in the root of the workspace folder is used.&quot;
            }
        }
    }
]
</code></pre>
<p>任务定义是JSON格式的，且包含<code>required</code>和<code>properties</code>两个属性。
<code>type</code>属性定义了任务类型，如果上述例子变成：</p>
<ul>
<li><code>&quot;type&quot;: &quot;npm&quot;</code>要求任务与npm任务相关联</li>
<li><code>&quot;required&quot;: [ &quot;script&quot; ]</code>其中<code>script</code>属性不可或缺。<code>path</code>属性变成可选。</li>
<li><code>&quot;properties&quot;: {...}</code>：定义了其他属性和他们的类型</li>
</ul>
<p>当插件真的创建了一个任务，它需要传入一个与package.json中任务配置对应的<code>TaskDefinition</code>。对于<code>npm</code>任务来说，pacakge.json中的脚本应该是这样的：</p>
<pre><code class="language-javascript">let task = new vscode.Task({ type: 'npm', script: 'test' }, ....);
</code></pre>
<h2 id="contributescolors"><a class="header" href="#contributescolors">contributes.colors</a></h2>
<hr />
<p>这些色彩可用于状态栏的编辑器装饰器。定义之后，用户可以在<code>workspace.colorCustomization</code>设置中自定义颜色，用户的主题会覆盖这些色值。</p>
<pre><code class="language-json">&quot;contributes&quot;: {
  &quot;colors&quot;: [{
      &quot;id&quot;: &quot;superstatus.error&quot;,
      &quot;description&quot;: &quot;Color for error message in the status bar.&quot;,
      &quot;defaults&quot;: {
          &quot;dark&quot;: &quot;errorForeground&quot;,
          &quot;light&quot;: &quot;errorForeground&quot;,
          &quot;highContrast&quot;: &quot;#010203&quot;
      }
  }]
}
</code></pre>
<h2 id="contributestypescriptserverplugins"><a class="header" href="#contributestypescriptserverplugins">contributes.typescriptServerPlugins</a></h2>
<hr />
<p>配置VS Code的Javascript和Typescript支持的<a href="https://github.com/Microsoft/TypeScript/wiki/Writing-a-Language-Service-Plugin">Typescript 服务器插件</a>：</p>
<pre><code class="language-json">&quot;contributes&quot;: {
   &quot;typescriptServerPlugins&quot;: [
      {
        &quot;name&quot;: &quot;typescript-styled-plugin&quot;
      }
    ]
}
</code></pre>
<p>上述例子配置了<a href="https://github.com/Microsoft/typescript-styled-plugin"><code>typescript-styled-plugin</code></a>，这个插件为Javascript和Typescript添加了风格化的组件智能提示。这个插件会从扩展插件中加载，而且必须在<code>dependency</code>中列明：</p>
<pre><code class="language-json">{
    &quot;dependencies&quot;: {
        &quot;typescript-styled-plugin&quot;: &quot;*&quot;
    }
}
</code></pre>
<p>Typescript 服务器插件可以被所有Javascript和Typescript文件加载，只有当用户的工作区使用Typescript时才会激活。</p>
<h2 id="下一步-9"><a class="header" href="#下一步-9">下一步</a></h2>
<p>学习更多VS Code的扩展性模型，试着查看下面的主题吧：</p>
<ul>
<li><a href="references//extensibility-reference/extension-manifest.html">插件配置清单</a> - VS Code的package.json插件配置清单参考</li>
<li><a href="references//extensibility-reference/activation-events.html">激活事件</a> - VS Code的激活事件参考</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="激活事件"><a class="header" href="#激活事件">激活事件</a></h1>
<p><strong>激活事件</strong>是<code>package.json</code>中<code>activationEvents</code>字段声明的一个JSON对象, 参考<a href="references//references/extension-manifest">插件清单</a>. 当<strong>激活事件</strong>触发时, 插件就会被激活. 下面是可用的<strong>激活事件</strong>列表:</p>
<ul>
<li><a href="references/activation-events.html#%E6%BF%80%E6%B4%BB%E4%BA%8B%E4%BB%B6">激活事件</a>
<ul>
<li><a href="references/activation-events.html#onlanguage">onLanguage</a></li>
<li><a href="references/activation-events.html#oncommand">onCommand</a></li>
<li><a href="references/activation-events.html#ondebug">onDebug</a>
<ul>
<li><a href="references/activation-events.html#ondebuginitialconfigurations">onDebugInitialConfigurations</a></li>
<li><a href="references/activation-events.html#ondebugresolve">onDebugResolve</a></li>
</ul>
</li>
<li><a href="references/activation-events.html#workspacecontains">workspaceContains</a></li>
<li><a href="references/activation-events.html#onfilesystem">onFileSystem</a></li>
<li><a href="references/activation-events.html#onview">onView</a></li>
<li><a href="references/activation-events.html#onuri">onUri</a></li>
<li><a href="references/activation-events.html#onwebviewpanel">onWebviewPanel</a></li>
<li><a href="references/activation-events.html#oncustomeditor">onCustomEditor</a></li>
<li><a href="references/activation-events.html#onauthenticationrequest">onAuthenticationRequest</a></li>
<li><a href="references/activation-events.html#onstartupfinished">onStartupFinished</a></li>
<li><a href="references/activation-events.html#start-up">*</a></li>
</ul>
</li>
</ul>
<p><code>package.json</code>的配置项都可以在<a href="references//references/extension-manifest">插件清单</a>中找到.</p>
<h2 id="onlanguage"><a class="header" href="#onlanguage">onLanguage</a></h2>
<hr />
<p>打开特定语言文件时激活事件和相关插件</p>
<pre><code class="language-json">...
&quot;activationEvents&quot;: [
  &quot;onLanguage:python&quot;
]
...
</code></pre>
<p><code>onLanguage</code>事件需要指定特定的<a href="https://code.visualstudio.com/docs/languages/identifiers">语言标识符</a></p>
<p>也可以添加多种语言:</p>
<pre><code class="language-json">&quot;activationEvents&quot;: [
  &quot;onLanguage:json&quot;,
  &quot;onLanguage:markdown&quot;,
  &quot;onLanguage:typescript&quot;
]
</code></pre>
<h2 id="oncommand"><a class="header" href="#oncommand">onCommand</a></h2>
<hr />
<p>调用命令时激活</p>
<pre><code class="language-json">...
&quot;activationEvents&quot;: [
  &quot;onCommand:extension.sayHello&quot;
]
...
</code></pre>
<h2 id="ondebug"><a class="header" href="#ondebug">onDebug</a></h2>
<hr />
<p>调试会话(debug session)启动前激活</p>
<pre><code class="language-json">...
&quot;activationEvents&quot;: [
  &quot;onDebug&quot;
]
...
</code></pre>
<h3 id="ondebuginitialconfigurations"><a class="header" href="#ondebuginitialconfigurations">onDebugInitialConfigurations</a></h3>
<h3 id="ondebugresolve"><a class="header" href="#ondebugresolve">onDebugResolve</a></h3>
<p>这是两个粒度更细的<code>onDebug</code>激活事件:</p>
<ul>
<li><code>DebugConfigurationProvider</code>中的<code>provideDebugConfigurations</code>在<code>onDebugInitialConfigurations</code>之后触发</li>
<li><code>onDebugResolve:type</code>在<code>DebugConfigurationProvider</code>的<code>resolveDebugConfiguration</code>方法之前触发.</li>
</ul>
<p><strong>友情提示</strong>: 如果调试插件比较轻量, 使用<code>onDebug</code>. 相反, 根据<code>DebugConfigurationProvider</code>实现的对应方法（<code>provideDebugConfigurations</code>或<code>resolveDebugConfiguration</code>），使用<code>onDebugInitialConfigurations</code>或<code>onDebugResolve</code>. 参阅<a href="references//extension-guides/debugger-extension#using-a-debugconfigurationprovider">使用调试器插件</a>.</p>
<h2 id="workspacecontains"><a class="header" href="#workspacecontains">workspaceContains</a></h2>
<hr />
<p>文件夹打开后，且文件夹中至少包含一个符合glob模式的文件时触发.</p>
<pre><code class="language-json">&quot;activationEvents&quot;: [
  &quot;workspaceContains:**/.editorconfig&quot;
]
</code></pre>
<h2 id="onfilesystem"><a class="header" href="#onfilesystem">onFileSystem</a></h2>
<hr />
<p>以协议（scheme）打开文件或文件夹时触发. 通常是<code>file</code>-协议，也可以用自定义的文件供应器函数替换掉，比如<code>ftp</code>、<code>ssh</code>.</p>
<pre><code class="language-json">...
&quot;activationEvents&quot;: [
  &quot;onFileSystem:sftp&quot;
]
...
</code></pre>
<h2 id="onview"><a class="header" href="#onview">onView</a></h2>
<hr />
<p>指定id的视图展开时触发:</p>
<pre><code class="language-json">...
&quot;activationEvents&quot;: [
  &quot;onView:nodeDependencies&quot;
]
...
</code></pre>
<h2 id="onuri"><a class="header" href="#onuri">onUri</a></h2>
<hr />
<p>插件的系统级URI打开时触发. 这个URI协议需要带上<code>vscode</code>或者 <code>vscode-insiders</code>协议. URI主机名必须是插件的唯一标识，剩余的URI是可选的. </p>
<pre><code class="language-json">...
&quot;activationEvents&quot;: [
  &quot;onUri&quot;
]
...
</code></pre>
<p>如果<code>vscode.git</code>插件定义了<code>onUri</code>激活事件，那么下列任意URI打开时就会触发:</p>
<ul>
<li><code>vscode://vscode.git/init</code></li>
<li><code>vscode://vscode.git/clone?url=https%3A%2F%2Fgithub.com%2FMicrosoft%2Fvscode-vsce.git</code></li>
<li><code>vscode-insiders://vscode.git/init</code>(for VS Code Insiders)</li>
</ul>
<h2 id="onwebviewpanel"><a class="header" href="#onwebviewpanel">onWebviewPanel</a></h2>
<hr />
<p>当相应<code>viewType</code>的<code>webview</code>恢复时触发. </p>
<p>下面是一个例子:</p>
<pre><code class="language-json">&quot;activationEvents&quot;: [
  ...,
  &quot;onWebviewPanel:catCoding&quot;
]
</code></pre>
<p>VS Code 恢复 (restore) <code>viewType</code> 为 <code>catCoding</code> 的 webview 时会激活插件. 调用 <code>window.createWebviewPanel</code> 可以设置 <code>viewType</code>, 你可能会需要其它的激活事件(比如: <code>onCommand</code>)初始化你的插件，然后再创建<code>webview</code>视图. </p>
<h2 id="oncustomeditor"><a class="header" href="#oncustomeditor">onCustomEditor</a></h2>
<hr />
<p>当相应 <code>viewType</code> 的 <a href="references/../extension-guides/custom-editors.html">自定义编辑器</a> 被创建时触发. </p>
<p>下面是一个例子:</p>
<pre><code class="language-json">&quot;activationEvents&quot;: [
    &quot;onCustomEditor:catCustoms.pawDraw&quot;
]
</code></pre>
<p>VS Code 恢复 (restore) <code>viewType</code> 为 <code>catCustoms.pawDraw</code> 的自定义编辑器时会激活插件. 
首先通过 <a href="references/../extension-guides/custom-editors.html#%E5%8F%91%E5%B8%83%E5%86%85%E5%AE%B9%E9%85%8D%E7%BD%AE"><code>自定义编辑器</code> 的发布内容配置</a> 设置 <code>viewType</code> ，然后为 <code>registerCustomEditorProvider</code> 提供一个 供应器函数. </p>
<p>!&gt; <strong>注意</strong>: 从VS Code 1.74.0开始，包含自定义编辑器的插件，不再需要单独配置 <code>onCustomEditor</code> 事件来激活. </p>
<h2 id="onauthenticationrequest"><a class="header" href="#onauthenticationrequest">onAuthenticationRequest</a></h2>
<hr />
<p>当插件通过 <code>authentication.getSession()</code> API和相应的 <code>providerId</code> 请求认证会话时会激活插件. </p>
<p>下面是一个例子：</p>
<pre><code class="language-json">&quot;activationEvents&quot;: [
    &quot;onAuthenticationRequest:github&quot;
]
</code></pre>
<p>当 VS Code 需要获取类型为 <code>github</code> 的 <code>AuthenticationSession</code> 将激活插件. </p>
<p>!&gt; <strong>注意</strong>: 从VS Code 1.74.0开始，包含认证程序的插件，不再需要单独配置 <code>onAuthenticationRequest</code> 事件来激活. </p>
<h2 id="onstartupfinished"><a class="header" href="#onstartupfinished">onStartupFinished</a></h2>
<hr />
<p>VS Code启动一段时间后才会激活插件. 它类似于 <code>*</code> 类激活事件，但它不会减慢VS Code启动. 目前，该事件在所有 <code>*</code> 类插件激活完成后触发. </p>
<pre><code class="language-json">...
&quot;activationEvents&quot;: [
    &quot;onStartupFinished&quot;
]
...
</code></pre>
<h2 id="start-up"><a class="header" href="#start-up">Start up</a></h2>
<hr />
<p>当VS Code启动时触发. 为了保证良好的用户体验，只在你的插件没有其他任何激活事件的前提下，添加这个激活事件. </p>
<pre><code class="language-json">...
&quot;activationEvents&quot;: [
  &quot;*&quot;
]
...
</code></pre>
<p>!&gt; <strong>注意</strong>: 一个插件如果侦听了多个激活事件, 那么最好用<code>&quot;*&quot;</code>替换掉.</p>
<p>!&gt; <strong>注意</strong>: 插件<strong>必须</strong>从它的主模块中输出一个<code>activate()</code>函数，当任意的激活事件触发时，VS Code会<strong>仅仅调用一次这个函数</strong>. 此外，插件也<strong>应该</strong> 导出一个<code>deactivate()</code>函数，当VS Code关闭时执行清理的任务. 如果清理进程是异步的，插件的<code>deactivate()</code><strong>必须</strong>返回一个Promise. 如果这个清理任务是同步的，那么<code>deactivate()</code>可以返回<code>undefined</code>. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="插件清单-1"><a class="header" href="#插件清单-1">插件清单</a></h1>
<h2 id="配置字段"><a class="header" href="#配置字段">配置字段</a></h2>
<hr />
<div class="table-wrapper"><table><thead><tr><th>名称</th><th style="text-align: center">必须</th><th>类型</th><th>详细</th></tr></thead><tbody>
<tr><td><code>name</code></td><td style="text-align: center">Y</td><td><code>string</code></td><td>插件的名称必须用全小写无空格的字母组成。</td></tr>
<tr><td><code>version</code></td><td style="text-align: center">Y</td><td><code>string</code></td><td><a href="https://semver.org/">SemVer</a>版本模式兼容。</td></tr>
<tr><td><code>publisher</code></td><td style="text-align: center">Y</td><td><code>string</code></td><td><a href="references//extension-authoring/publish-extension.html#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%8F%91%E8%A1%8C%E6%96%B9">发行方名称</a></td></tr>
<tr><td><code>engines</code></td><td style="text-align: center">Y</td><td><code>object</code></td><td>一个至少包含<code>vscode</code>字段的对象，其值必须<a href="references//extension-authoring/publish-extension.html#VS-Code%E7%89%88%E6%9C%AC%E5%85%BC%E5%AE%B9%E6%80%A7">兼容</a> VS Code版本。不可以是<code>*</code>。例如：<code>^0.10.5</code> 表明最小兼容<code>0.10.5</code>版本的VS Code。</td></tr>
<tr><td><code>license</code></td><td style="text-align: center"></td><td><code>string</code></td><td>参考<a href="https://docs.npmjs.com/files/package.json#license">npm's documentation</a>。如果你在插件根目录已经提供了<code>LICENSE</code>文件。那么<code>license</code>的值应该是<code>&quot;SEE LICENSE IN &lt;filename&gt;&quot;</code>。</td></tr>
<tr><td><code>displayName</code></td><td style="text-align: center"></td><td><code>string</code></td><td>插件市场所显示的插件名称。</td></tr>
<tr><td><code>description</code></td><td style="text-align: center"></td><td><code>string</code></td><td>简单地描述一下你的插件是做什么的。</td></tr>
<tr><td><code>categories</code></td><td style="text-align: center"></td><td><code>string[]</code></td><td>你想要使用的插件分类，可选值有：<code>[Programming Languages, Snippets, Linters, Themes, Debuggers, Formatters, Keymaps, SCM Providers, Other, Extension Packs, Language Packs]</code></td></tr>
<tr><td><code>keywords</code></td><td style="text-align: center"></td><td><code>array</code></td><td><strong>关键字</strong>（数组），这样用户可以更方便地找到你的插件。到时候会和市场上的其他插件以<strong>标签</strong>筛选在一起。</td></tr>
<tr><td><code>galleryBanner</code></td><td style="text-align: center"></td><td><code>object</code></td><td>根据你的icon格式化市场的头部显示。详情见下。</td></tr>
<tr><td><code>preview</code></td><td style="text-align: center"></td><td><code>boolean</code></td><td>在市场中会显示Preview标记。</td></tr>
<tr><td><code>main</code></td><td style="text-align: center"></td><td><code>string</code></td><td>你的插件入口</td></tr>
<tr><td><a href="references//extensibility-reference/contribution-points.html"><code>contributes</code></a></td><td style="text-align: center"></td><td><code>object</code></td><td>描述插件<a href="references//extensibility-reference/contribution-points.html">发布内容</a>的对象。</td></tr>
<tr><td><a href="references//extensibility-reference/activation-events.html"><code>activationEvents</code></a></td><td style="text-align: center"></td><td><code>array</code></td><td><a href="references//extensibility-reference/activation-events.html">激活事件</a>数组。</td></tr>
<tr><td><code>badges</code></td><td style="text-align: center"></td><td><code>array</code></td><td>显示在插件市场页面侧边栏的<a href="references/extension-manifest.html#%E4%BD%BF%E7%94%A8%E8%AE%A4%E8%AF%81%E8%BF%87%E7%9A%84%E6%A0%87%E5%BF%97">合法</a>标记。 每个标记都是一个对象，包含了3个属性：<code>url</code> 标记的图片URL，当用户点击标记和<code>description</code>时，会跳转到<code>href</code>。</td></tr>
<tr><td><code>markdown</code></td><td style="text-align: center"></td><td><code>string</code></td><td>控制市场中使用的Markdown渲染引擎。可以是<code>github</code> (默认) 或 <code>standard</code>。</td></tr>
<tr><td><code>qna</code></td><td style="text-align: center"></td><td><code>marketplace</code> (默认), <code>string</code>, <code>false</code></td><td>控制市场中的<strong>Q &amp; A</strong> 链接。 设置成<code>marketplace</code>时，自动使用市场默认的Q &amp; A网址。或者提供一个URL转跳到你的Q &amp; A 地址。设置为<code>false</code>时禁用。</td></tr>
<tr><td><code>dependencies</code></td><td style="text-align: center"></td><td><code>object</code></td><td>Node.js 运行时依赖。等同于<a href="https://docs.npmjs.com/files/package.json#dependencies">npm's <code>dependencies</code></a>.</td></tr>
<tr><td><code>devDependencies</code></td><td style="text-align: center"></td><td><code>object</code></td><td>Node.js 开发时依赖。 等同于<a href="https://docs.npmjs.com/files/package.json#devdependencies">npm's <code>devDependencies</code></a>.</td></tr>
<tr><td><code>extensionDependencies</code></td><td style="text-align: center"></td><td><code>array</code></td><td>插件依赖，由插件ID组成的数组。当主要插件安装完成后，其他插件会相应安装。插件ID的格式为 <code>${publisher}.${name}</code>。比如：<code>vscode.csharp</code>。</td></tr>
<tr><td><code>scripts</code></td><td style="text-align: center"></td><td><code>object</code></td><td>等同于<a href="https://docs.npmjs.com/misc/scripts">npm的 <code>scripts</code></a>，不过有VS Code额外字段如<a href="references//extension-authoring/publish-extension.html#%E9%A2%84%E5%8F%91%E5%B8%83%E6%AD%A5%E9%AA%A4">vscode:prepublish</a>或<a href="references/extension-manifest.html#%E6%8F%92%E4%BB%B6%E5%8D%B8%E8%BD%BD%E9%92%A9%E5%AD%90">vscode:uninstall</a>.</td></tr>
<tr><td><code>icon</code></td><td style="text-align: center"></td><td><code>string</code></td><td>icon的文件路径，最小 128x128 像素 (视网膜屏幕则需 256x256)。</td></tr>
</tbody></table>
</div>
<p>你还可以参考<a href="https://docs.npmjs.com/files/package.json">npm的<code>package.json</code></a></p>
<h2 id="示例-15"><a class="header" href="#示例-15">示例</a></h2>
<hr />
<p>下面是一份完整的<code>package.json</code>示例</p>
<pre><code class="language-json">{
    &quot;name&quot;: &quot;wordcount&quot;,
    &quot;displayName&quot;: &quot;Word Count&quot;,
    &quot;version&quot;: &quot;0.1.0&quot;,
    &quot;publisher&quot;: &quot;ms-vscode&quot;,
    &quot;description&quot;: &quot;Markdown Word Count Example - reports out the number of words in a Markdown file.&quot;,
    &quot;author&quot;: {
        &quot;name&quot;: &quot;seanmcbreen&quot;
    },
    &quot;categories&quot;: [
        &quot;Other&quot;
    ],
    &quot;icon&quot;: &quot;images/icon.png&quot;,
    &quot;galleryBanner&quot;: {
        &quot;color&quot;: &quot;#C80000&quot;,
        &quot;theme&quot;: &quot;dark&quot;
    },
    &quot;activationEvents&quot;: [
        &quot;onLanguage:markdown&quot;
    ],
    &quot;engines&quot;: {
        &quot;vscode&quot;: &quot;^1.0.0&quot;
    },
    &quot;main&quot;: &quot;./out/extension&quot;,
    &quot;scripts&quot;: {
        &quot;vscode:prepublish&quot;: &quot;node ./node_modules/vscode/bin/compile&quot;,
        &quot;compile&quot;: &quot;node ./node_modules/vscode/bin/compile -watch -p ./&quot;
    },
    &quot;devDependencies&quot;: {
        &quot;vscode&quot;: &quot;0.10.x&quot;,
        &quot;typescript&quot;: &quot;^1.6.2&quot;
    },
    &quot;license&quot;: &quot;SEE LICENSE IN LICENSE.txt&quot;,
    &quot;bugs&quot;: {
        &quot;url&quot;: &quot;https://github.com/Microsoft/vscode-wordcount/issues&quot;,
        &quot;email&quot;: &quot;smcbreen@microsoft.com&quot;
    },
    &quot;repository&quot;: {
        &quot;type&quot;: &quot;git&quot;,
        &quot;url&quot;: &quot;https://github.com/Microsoft/vscode-wordcount.git&quot;
    },
    &quot;homepage&quot;: &quot;https://github.com/Microsoft/vscode-wordcount/blob/master/README.md&quot;
}
</code></pre>
<h2 id="插件市场展示小贴士"><a class="header" href="#插件市场展示小贴士">插件市场展示小贴士</a></h2>
<hr />
<p>下面是一些让你的插件在<a href="https://marketplace.visualstudio.com/VSCode">市场</a>上看起来狂拽酷帅吊炸天的小建议。</p>
<p>使用<code>npm install -g vsce</code>安装最新的<code>vsce</code>。</p>
<p>在插件根目录中新建一个<code>README.md</code>文件，我们会把里面的内容作为插件的介绍（在市场上），你可以在<code>README.md</code>提供图片的相对路径。</p>
<p>下面是两个栗子🌰：</p>
<ol>
<li><a href="references/extension-authoring/example-word-count">Word Count</a></li>
<li><a href="https://marketplace.visualstudio.com/items/seanmcbreen.MDTools">MD Tools</a></li>
</ol>
<p>好的名字和描述是市场展示产品非常重要的部分。下述字符串用于VS Code文本搜索，带上关键字更容易被找到。</p>
<pre><code class="language-json">    &quot;displayName&quot;: &quot;Word Count&quot;,
    &quot;description&quot;: &quot;Markdown Word Count Example - reports out the number of words in a Markdown file.&quot;,
</code></pre>
<p>Icon和banner颜色会展示在市场页面头部，<code>theme</code>属性是指banner中使用的字体主题——<code>dark</code>或<code>light</code>。</p>
<pre><code class="language-json">{
    &quot;icon&quot;: &quot;images/icon.png&quot;,
    &quot;galleryBanner&quot;: {
        &quot;color&quot;: &quot;#C80000&quot;,
        &quot;theme&quot;: &quot;dark&quot;
    },
}
</code></pre>
<p>下面的几个可选链接（<code>bugs</code>，<code>homepage</code>，<code>repository</code>）会在市场的<strong>Resources</strong>部分显示：</p>
<pre><code class="language-json">{
    &quot;license&quot;: &quot;SEE LICENSE IN LICENSE.txt&quot;,
    &quot;homepage&quot;: &quot;https://github.com/Microsoft/vscode-wordcount/blob/master/README.md&quot;,
    &quot;bugs&quot;: {
        &quot;url&quot;: &quot;https://github.com/Microsoft/vscode-wordcount/issues&quot;,
        &quot;email&quot;: &quot;smcbreen@microsoft.com&quot;
    },
    &quot;repository&quot;: {
        &quot;type&quot;: &quot;git&quot;,
        &quot;url&quot;: &quot;https://github.com/Microsoft/vscode-wordcount.git&quot;
    },
}
</code></pre>
<div class="table-wrapper"><table><thead><tr><th>市场资源链接</th><th>对应的package.json属性</th></tr></thead><tbody>
<tr><td>Issues</td><td><code>bugs:url</code></td></tr>
<tr><td>Repository</td><td><code>repository:url</code></td></tr>
<tr><td>Homepage</td><td><code>homepage</code></td></tr>
<tr><td>License</td><td><code>license</code></td></tr>
</tbody></table>
</div>
<p>设置插件的<code>category</code>，<code>category</code>一样的插件会分类到一起以便用户查找和筛选。</p>
<blockquote>
<p>**注意：**请使用有意义的分类值，允许的值有<code>[Programming Languages, Snippets, Linters, Themes, Debuggers, Formatters, Keymaps, SCM Providers, Other, Extension Packs, Language Packs]</code>。有语法高亮、代码补全功能的插件，请使用<code>Programming Languages</code>。<code>Language Packs</code>分类是为本地化保留的插件类别（例如：简体中文（本地化））。</p>
</blockquote>
<pre><code class="language-json">{
    &quot;categories&quot;: [
        &quot;Linters&quot;, &quot;Programming Languages&quot;, &quot;Other&quot;
    ],
}
</code></pre>
<p>?&gt; <strong>小贴士：</strong> The <a href="https://marketplace.visualstudio.com/items?itemName=ms-devlabs.extension-manifest-editor">Extension Manifest Editor</a> 插件可以帮你预览预览你的插件中的<code>README.md</code> 和 <code>package.json</code>， 生成的预览就像你已经发布到插件市场了一样。</p>
<h3 id="使用认证过的徽章"><a class="header" href="#使用认证过的徽章">使用认证过的徽章</a></h3>
<p>出于安全考虑，我们只允许可信服务商提供的标志。
我们允许来自下列URL前缀的标志：</p>
<ul>
<li><a href="http://api.bintray.com">api.bintray.com</a></li>
<li><a href="http://api.travis-ci.com">api.travis-ci.com</a></li>
<li><a href="http://api.travis-ci.org">api.travis-ci.org</a></li>
<li><a href="http://app.fossa.io">app.fossa.io</a></li>
<li><a href="http://badge.fury.io">badge.fury.io</a></li>
<li><a href="http://badge.waffle.io">badge.waffle.io</a></li>
<li><a href="http://badgen.net">badgen.net</a></li>
<li><a href="http://badges.frapsoft.com">badges.frapsoft.com</a></li>
<li><a href="http://badges.gitter.im">badges.gitter.im</a></li>
<li><a href="http://badges.greenkeeper.io">badges.greenkeeper.io</a></li>
<li><a href="http://cdn.travis-ci.com">cdn.travis-ci.com</a></li>
<li><a href="http://cdn.travis-ci.org">cdn.travis-ci.org</a></li>
<li><a href="http://ci.appveyor.com">ci.appveyor.com</a></li>
<li><a href="http://circleci.com">circleci.com</a></li>
<li><a href="http://cla.opensource.microsoft.com">cla.opensource.microsoft.com</a></li>
<li><a href="http://codacy.com">codacy.com</a></li>
<li><a href="http://codeclimate.com">codeclimate.com</a></li>
<li><a href="http://codecov.io">codecov.io</a></li>
<li><a href="http://coveralls.io">coveralls.io</a></li>
<li><a href="http://david-dm.org">david-dm.org</a></li>
<li><a href="http://deepscan.io">deepscan.io</a></li>
<li><a href="http://dev.azure.com">dev.azure.com</a></li>
<li><a href="http://gemnasium.com">gemnasium.com</a></li>
<li><a href="http://githost.io">githost.io</a></li>
<li><a href="http://gitlab.com">gitlab.com</a></li>
<li><a href="http://godoc.org">godoc.org</a></li>
<li><a href="http://goreportcard.com">goreportcard.com</a></li>
<li><a href="http://img.shields.io">img.shields.io</a></li>
<li><a href="http://isitmaintained.com">isitmaintained.com</a></li>
<li><a href="http://marketplace.visualstudio.com">marketplace.visualstudio.com</a></li>
<li><a href="http://nodesecurity.io">nodesecurity.io</a></li>
<li><a href="http://opencollective.com">opencollective.com</a></li>
<li><a href="http://snyk.io">snyk.io</a></li>
<li><a href="http://travis-ci.com">travis-ci.com</a></li>
<li><a href="http://travis-ci.org">travis-ci.org</a></li>
<li><a href="http://visualstudio.com">visualstudio.com</a></li>
<li><a href="http://vsmarketplacebadge.apphb.com">vsmarketplacebadge.apphb.com</a></li>
<li><a href="http://www.bithound.io">www.bithound.io</a></li>
<li><a href="http://www.versioneye.com">www.versioneye.com</a></li>
</ul>
<p>如果你想用其他标志，欢迎在我们的Github <a href="https://github.com/Microsoft/vscode/issues">issue</a>页面提供建议。</p>
<h2 id="整合插件配置"><a class="header" href="#整合插件配置">整合插件配置</a></h2>
<hr />
<p><code>yo code</code>可以帮你轻松地打包TextMate 主题，着色器，代码片段和创建新插件。当你运行了生成器，每一次配置都会创建一个完整、独立的插件包。但是，将多个配置内容整合进一个插件会更方便。比如：你想要支持一门新的语言，你会希望同时提供语法高亮和代码片段，甚至调试支持。</p>
<p>为了整合插件配置，编辑已有的<code>package.json</code>文件，然后添加新的配置内容，关联相关文件。</p>
<p>下面是一个包含了LaTex语言定义（语言标识符和相关文件插件），（语法）着色器和代码片段。</p>
<pre><code class="language-json">{
    &quot;name&quot;: &quot;language-latex&quot;,
    &quot;description&quot;: &quot;LaTex Language Support&quot;,
    &quot;version&quot;: &quot;0.0.1&quot;,
    &quot;publisher&quot;: &quot;someone&quot;,
    &quot;engines&quot;: {
        &quot;vscode&quot;: &quot;0.10.x&quot;
    },
    &quot;categories&quot;: [
        &quot;Programming Languages&quot;,
        &quot;Snippets&quot;
    ],
    &quot;contributes&quot;: {
        &quot;languages&quot;: [{
            &quot;id&quot;: &quot;latex&quot;,
            &quot;aliases&quot;: [&quot;LaTeX&quot;, &quot;latex&quot;],
            &quot;extensions&quot;: [&quot;.tex&quot;]
        }],
        &quot;grammars&quot;: [{
            &quot;language&quot;: &quot;latex&quot;,
            &quot;scopeName&quot;: &quot;text.tex.latex&quot;,
            &quot;path&quot;: &quot;./syntaxes/latex.tmLanguage.json&quot;
        }],
        &quot;snippets&quot;: [{
            &quot;language&quot;: &quot;latex&quot;,
            &quot;path&quot;: &quot;./snippets/snippets.json&quot;
        }]
    }
}
</code></pre>
<p>注意插件的<code>categories</code>字段现在包含了<code>Programming Languages</code>和<code>Snippets</code>，以便用户在市场中找到这个插件。</p>
<p>?&gt; <strong>小贴士：</strong> 整合好的配置文件应该使用同样的标识符。在上述例子中，所有的标识符都用了&quot;latex&quot;。这样VS Code 才知道（语法）着色器和代码片段是为LaTeX语言准备的，当编辑LaTeX文件的时候才会激活插件。</p>
<h2 id="插件包"><a class="header" href="#插件包">插件包</a></h2>
<hr />
<p>你也可以将几个独立的插件打包成一个“插件包”。插件包是指一组可以无冲突安装的插件集合。然后你就可以很方便地把插件分享给其他人，或者为特定情境创建一组插件，比如帮助PHP工程师在VS Code中快速上手。</p>
<p>一个插件包可以包含其他插件，或者直接将其打包到自身中。<code>package.json</code>中的<code>extensionDependencies</code>描述了这项依赖。</p>
<p>举个例子🌰，下面是一个PHP插件包，其中包含了调试器，语言服务器和格式化器。</p>
<pre><code class="language-json">{
  &quot;extensionDependencies&quot;: [
      &quot;felixfbecker.php-debug&quot;,
      &quot;felixfbecker.php-intellisense&quot;,
      &quot;Kasik96.format-php&quot;
  ]
}
</code></pre>
<p>当安装插件包的时候，VS Code会连同它的插件依赖一起安装。</p>
<p>插件包需要使用市场分类中的<code>Extension Packs</code>：</p>
<pre><code class="language-json">{
  &quot;categories&quot;: [
      &quot;Extension Packs&quot;
  ],
}
</code></pre>
<p>想要创建插件包，你可以使用<code>yo code</code>Yeoman生成器。另外，你也可以用你VS Code中已有的一些插件生成插件包，然后你就可以很轻松地从喜欢的插件中创建出插件包，再发布到市场上或者分享给其他用户。</p>
<p>插件包不应该有除了它内部打包之外的其他插件包，打包好的插件包应该是在整个包里面可以独立管理的。如果一个插件非常依赖另外一个插件，那么这个依赖性应该在<code>extensionDependencies</code>中声明。</p>
<h4 id="插件卸载钩子"><a class="header" href="#插件卸载钩子">插件卸载钩子</a></h4>
<hr />
<p>如果你的插件在删除时需要做一些清理工作，你可以在package.json中的卸载钩子<code>vscode:uninstall</code>中注册一个<code>node</code>脚本。</p>
<pre><code class="language-json">{
  &quot;scripts&quot;: {
    &quot;vscode:uninstall&quot;: &quot;node ./out/src/lifecycle&quot;
  }
}
</code></pre>
<p>这个脚本会在插件完全卸载之后执行，也就是插件完全卸载之后——VS Code重载（关闭然后启动）之后执行。</p>
<p>!&gt; 注意：只支持Node.js脚本</p>
<p>下面有几个npmjs的Node.js 模块，可以帮你实现VS Code插件。你可以在插件的<code>dependencies</code>部分包含进去。</p>
<ul>
<li><a href="https://www.npmjs.com/package/vscode-nls">vscode-nls</a> - 支持插件的国际化和本地化。</li>
<li><a href="https://www.npmjs.com/package/vscode-uri">vscode-uri</a> - 使用VS Code实现的URI。</li>
<li><a href="https://www.npmjs.com/package/jsonc-parser">jsonc-parser</a> - 允许带注释的JSON检查器。</li>
<li><a href="https://www.npmjs.com/package/request-light">request-light</a> - 带代理支持的轻量级Node.js请求库。</li>
<li><a href="https://www.npmjs.com/package/vscode-extension-telemetry">vscode-extension</a> - 提供VS Code 插件的持续遥测监控报告。</li>
<li><a href="https://www.npmjs.com/package/vscode-languageclient">vscode-languageclient</a> - 轻松地将语言服务器绑定到语言服务器协议上。</li>
</ul>
<h2 id="下一步-10"><a class="header" href="#下一步-10">下一步</a></h2>
<p>学习更多VS Code扩展性模型，看看下面的话题：</p>
<ul>
<li><a href="references//extensibility-reference/contribution-points.html">发布内容配置点</a> - VS Code 发布内容配置点参考</li>
<li><a href="references//extensibility-reference/activation-events.html">激活事件</a> - VS Code 激活事件参考</li>
<li><a href="https://code.visualstudio.com/docs/editor/extension-gallery">插件市场</a> - 阅读更多关于 VS Code 插件市场的内容</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="内置命令"><a class="header" href="#内置命令">内置命令</a></h1>
<p>这篇文档列出了可能需要与<code>vscode.commands.executeCommand</code>一起使用的命令集合.</p>
<p>阅读<a href="references/">命令指南</a>以了解如何使用<code>commands</code>API.</p>
<p>下面是一个如何在 VS Code 中打开新文件夹的例子:</p>
<pre><code class="language-javascript">let uri = Uri.file('/some/path/to/folder');
let success = await commands.executeCommand('vscode.openFolder', uri);
</code></pre>
<h2 id="命令-2"><a class="header" href="#命令-2">命令</a></h2>
<p><code>vscode.executeWorkspaceSymbolProvider</code> - 执行工作区所有的<strong>符号</strong>供应器函数</p>
<ul>
<li><em>query</em> - 搜索关键词</li>
<li><em>(returns)</em> - promise函数, 且参数为具有SymbolInformation和DocumentSymbol的实例数组.</li>
</ul>
<p><code>vscode.executeDefinitionProvider</code> - 执行所有的<strong>定义</strong>供应器函数</p>
<ul>
<li><em>uri</em> - 文档的Uri</li>
<li><em>position</em> - 某个符号的位置</li>
<li><em>(returns)</em> - promise函数, 且参数为Location实例数组.</li>
</ul>
<p><code>vscode.executeDeclarationProvider</code> - 执行所有的<strong>声明</strong>供应器函数.</p>
<ul>
<li><em>uri</em> - 文档的Uri</li>
<li><em>position</em> - 某个符号的位置</li>
<li><em>(returns)</em> - promise函数, 且参数为Location实例数组.</li>
</ul>
<p><code>vscode.executeTypeDefinitionProvider</code> - 执行所有的<strong>类型定义</strong>供应器函数.</p>
<ul>
<li><em>uri</em> - 文档的Uri</li>
<li><em>position</em> - 某个符号的位置</li>
<li><em>(returns)</em> - promise函数, 且参数为Location实例数组.</li>
</ul>
<p><code>vscode.executeImplementationProvider</code> - 执行所有的<strong>接口</strong>供应器函数</p>
<ul>
<li><em>uri</em> - 文档的Uri</li>
<li><em>position</em> - 某个符号的位置</li>
<li><em>(returns)</em> - promise函数, 且参数为Location实例数组</li>
</ul>
<p><code>vscode.executeHoverProvider</code> - 执行所有的<strong>悬停</strong>供应器函数.</p>
<ul>
<li><em>uri</em> - 文档的Uri</li>
<li><em>position</em> - 某个符号的位置</li>
<li><em>(returns)</em> - promise函数, 且参数为Hover实例数组</li>
</ul>
<p><code>vscode.executeDocumentHighlights</code> - 执行<strong>文档高亮</strong>供应器函数.</p>
<ul>
<li><em>uri</em> - 文档的Uri</li>
<li><em>position</em> - 在文档中的位置</li>
<li><em>(returns)</em> - promise函数, 且参数为DocumentHighlight实例数组</li>
</ul>
<p><code>vscode.executeReferenceProvider</code> - 执行<strong>引用</strong>供应器函数</p>
<ul>
<li><em>uri</em> - 文档的Uri</li>
<li><em>position</em> - 在文档中的位置</li>
<li><em>(returns)</em> - promise函数, 且参数为Location实例数组</li>
</ul>
<p><code>vscode.executeDocumentRenameProvider</code> - 执行<strong>重命名</strong>供应器函数</p>
<ul>
<li><em>uri</em> - 文档的Uri</li>
<li><em>position</em> - 在文档中的位置</li>
<li><em>newName</em> - 新的符号名称</li>
<li><em>(returns)</em> - promise函数, 且参数为WorkspaceEdit</li>
</ul>
<p><code>vscode.executeSignatureHelpProvider</code> - 执行<strong>符号帮助</strong>供应器函数</p>
<ul>
<li><em>uri</em> - 文档的Uri</li>
<li><em>position</em> - 在文档中的位置</li>
<li><em>triggerCharacter</em> - (可选的)当用户输入特定字符时（如<code>,</code> 或 <code>(</code>）触发符号帮助</li>
<li><em>(returns)</em> - promise函数, 且参数为SignatureHelp</li>
</ul>
<p><code>vscode.executeDocumentSymbolProvider</code> - 执行<strong>文档符号</strong>供应器函数</p>
<ul>
<li><em>uri</em> - 文档的Uri</li>
<li><em>(returns)</em> - promise函数, 且参数为具有SymbolInformation和DocumentSymbol的实例数组</li>
</ul>
<p><code>vscode.executeCompletionItemProvider</code> - 执行<strong>自动补全</strong>供应器函数</p>
<ul>
<li><em>uri</em> - 文档的Uri</li>
<li><em>position</em> - 在文档中的位置</li>
<li><em>triggerCharacter</em> - (可选的)当用户输入诸如(<code>,</code> <code>(</code>)之类的字符时触发</li>
<li><em>itemResolveCount</em> - (可选的)补全的符号数量(数目太大会减慢补全速度)</li>
<li><em>(returns)</em> - promise函数, 且参数为CompletionList实例</li>
</ul>
<p><code>vscode.executeCodeActionProvider</code> - 执行<strong>代码操作小灯泡提示</strong>供应器函数</p>
<ul>
<li><em>uri</em> - 文档的Uri</li>
<li><em>range</em> - 在文档中的范围</li>
<li><em>(returns)</em> - promise函数, 且参数为Command实例数组</li>
</ul>
<p><code>vscode.executeCodeLensProvider</code> - 执行<strong>CodeLens</strong>供应器函数</p>
<ul>
<li><em>uri</em> - 文档的Uri</li>
<li><em>itemResolveCount</em> - (可选的)需要解析的lenses数量, 数目太大会影响性能</li>
<li><em>(returns)</em> - promise函数, 且参数为CodeLens实例数组</li>
</ul>
<p><code>vscode.executeFormatDocumentProvider</code> - 执行<strong>格式化文档</strong>供应器函数</p>
<ul>
<li><em>uri</em> - 文档的Uri</li>
<li><em>options</em> - 配置项</li>
<li><em>(returns)</em> - promise函数, 且参数为TextEdits数组</li>
</ul>
<p><code>vscode.executeFormatRangeProvider</code> - 执行<strong>局部格式化</strong>供应器函数</p>
<ul>
<li><em>uri</em> - 文档的Uri</li>
<li><em>range</em> - 限制的范围</li>
<li><em>options</em> - 配置项</li>
<li><em>(returns)</em> - promise函数, 且参数为TextEdits数组</li>
</ul>
<p><code>vscode.executeFormatOnTypeProvider</code> - 执行<strong>格式化文档</strong>供应器函数</p>
<ul>
<li><em>uri</em> - 文档的Uri</li>
<li><em>position</em> - 在文档中的位置</li>
<li><em>ch</em> - 在输入某个字符之后进行格式化</li>
<li><em>options</em> - 配置项</li>
<li><em>(returns)</em> - promise函数, 且参数为TextEdits数组</li>
</ul>
<p><code>vscode.executeLinkProvider</code> - 执行<strong>文档链接</strong>供应器函数</p>
<ul>
<li><em>uri</em> - 文档的Uri</li>
<li><em>(returns)</em> - promise函数, 且参数为DocumentLink实例数组</li>
</ul>
<p><code>vscode.executeDocumentColorProvider</code> - 执行<strong>文档颜色</strong>供应器函数</p>
<ul>
<li><em>uri</em> - 文档的Uri</li>
<li><em>(returns)</em> - promise函数, 且参数为ColorInfomation对象数组</li>
</ul>
<p><code>vscode.executeColorPresentationProvider</code> - 执行<strong>色彩呈现</strong>供应器函数</p>
<ul>
<li><em>color</em> - 需要展示并插入的颜色</li>
<li><em>context</em> - 上下文对象, 包括uri和影响范围</li>
<li><em>(returns)</em> - promise函数, 且参数为ColorPresentation对象数组</li>
</ul>
<p><code>vscode.openFolder</code> - 在当前窗口或者新的窗口打开一个文件夹或者工作区</p>
<ul>
<li><em>uri</em> - 被打开的文件夹或工作区Uri. 如果未提供, 会打开一个询问提示框</li>
<li><em>newWindow</em> - (可选的)是否在新窗口打开. 默认在本窗口</li>
</ul>
<p>!&gt; <strong>注意：</strong> 在当前窗口打开, 如果未设置<code>newWindow = true</code>, 会在指定的工作区或者文件夹开启新的拓展主机进程, 并且关闭当前拓展主机进程.</p>
<p><code>vscode.diff</code> - 在diff编辑器中打开指定资源以比较它们的内容</p>
<ul>
<li><em>left</em> diff编辑器左边的文件</li>
<li><em>right</em> diff编辑器右边的文件</li>
<li><em>title</em> (可选)diff编辑器标题</li>
<li><em>options</em> (可选)编辑器配置项, 参考<code>vscode.TextDocumentShowOptions</code></li>
</ul>
<p><code>vscode.open</code> - 在编辑器打开指定文件</p>
<ul>
<li><em>resource</em> - 要打开的文件</li>
<li><em>columnOrOptions</em> - (可选)可以是要打开的编辑器列，也可以是编辑器选项，参考<code>vscode.TextDocumentShowOptions</code></li>
</ul>
<p>可以是文本文件、二进制文件、http(s) url. 如果需要更多的配置项, 使用<code>vscode.window.showTextDocument</code>代替.</p>
<p><code>vscode.removeFromRecentlyOpened</code> - 在最近打开的列表中移除一个路径</p>
<ul>
<li><em>path</em> - 被移除的路径</li>
</ul>
<p><code>vscode.setEditorLayout</code> - 设置编辑器布局</p>
<ul>
<li><em>layout</em> - 被设置的布局</li>
</ul>
<p>布局是一个对象，带有初始布局方向（可选，0 = 水平布局，1 = 垂直布局），还有一个包含编辑器组的数组。每个编辑器组又有一个尺寸和另一个数组，其中有矩形布局和方向信息。如果设置了编辑器组的大小，每一行或者每一列的总和必须为1。比如一个2x2的网格：<code>{ orientation: 0, groups: [{ groups: [{}, {}], size: 0.5 }, { groups: [{}, {}], size: 0.5 }] }</code></p>
<p><code>cursorMove</code> - 移动光标到视图的合理位置</p>
<ul>
<li>
<p><em>Cursor move argument object</em></p>
<p>可以传递的键值对</p>
<ul>
<li>'to': 必选, 鼠标要移动到的合理位置</li>
</ul>
<pre><code>'left', 'right', 'up', 'down'
'wrappedLineStart', 'wrappedLineEnd', 'wrappedLineColumnCenter'
'wrappedLineFirstNonWhitespaceCharacter', 'wrappedLineLastNonWhitespaceCharacter'
'viewPortTop', 'viewPortCenter', 'viewPortBottom', 'viewPortIfOutside'
</code></pre>
<ul>
<li>'by': 移动的单位. 默认根据'to'来计算.</li>
</ul>
<pre><code>'line', 'wrappedLine', 'character', 'halfLine'
</code></pre>
<ul>
<li>'value': 单位步数. 默认为'1'.</li>
<li>'select': 如果为'true'则会选中. 默认为'false'.</li>
</ul>
</li>
</ul>
<p><code>editorScroll</code> - 编辑器滚动方向</p>
<ul>
<li>
<p><em>Editor scroll argument object</em></p>
<p>可以传递的键值对</p>
<ul>
<li>'to': 必须的. 方向值</li>
</ul>
<pre><code>'up', 'down'
</code></pre>
<ul>
<li>'by': 移动的单位. 默认根据'to'来计算.</li>
</ul>
<pre><code>'line', 'wrappedLine', 'page', 'halfPage'
</code></pre>
<ul>
<li>'value': 单位步数. 默认为'1'.</li>
<li>'revealCursor': 如果为'true', 在超出滚动视图也会显示光标.</li>
</ul>
</li>
</ul>
<p><code>revealLine</code> - 在给定的位置显示行</p>
<ul>
<li>
<p><em>Reveal line argument object</em></p>
<p>可以传递的键值对</p>
<ul>
<li>'lineNumber': 必须的. 行号</li>
<li>'at': 显示的合理位置</li>
</ul>
<pre><code>'top', 'center', 'bottom'
</code></pre>
</li>
</ul>
<p><code>editor.unfold</code> - 展开编辑器内容</p>
<ul>
<li>
<p><em>Unfold editor argument</em></p>
<p>可以传递的键值对</p>
<ul>
<li>'levels': 展开的层级数. 默认为 1.</li>
<li>'direction': 如果是'up', 向上展开, 否则向下展开</li>
<li>'selectionLines': 要使用展开功能的起始行（从0起）。如果不设置，就会使用当前激活的行（选中区）.</li>
</ul>
</li>
</ul>
<p><code>editor.fold</code> - 折叠编辑器内容</p>
<ul>
<li>
<p><code>Fold editor argument</code></p>
<p>可以传递的键值对</p>
<ul>
<li>'levels': 折叠的的层级数。默认为1</li>
<li>'direction':  如果设置为'up'，向上折叠，不然向下折叠</li>
<li>'selectionLines': 要使用折叠功能的起始行（从0起）。如果不设置，就会使用当前激活的行（选中区）</li>
</ul>
</li>
</ul>
<p><code>editor.action.showReferences</code> - 在文件中显示引用</p>
<ul>
<li><em>uri</em> - 要显示引用的文件</li>
<li><em>position</em> - 要显示的位置</li>
<li><em>locations</em> - 位置数组</li>
</ul>
<p><code>moveActiveEditor</code> - 通过标签或者组移动激活的编辑器</p>
<ul>
<li>
<p><em>Active editor move argument</em></p>
<p>参数</p>
<ul>
<li>'to': String. 目标位置</li>
<li>'by': String. 移动的单位(通过标签或者组).</li>
<li>'value': Number. 要移动的位置或者绝对位置值</li>
</ul>
</li>
</ul>
<h2 id="简单命令"><a class="header" href="#简单命令">简单命令</a></h2>
<p>简单的命令不需要参数, 可以在<code>keybindings.json</code>的<strong>键盘快捷方式</strong>列表中找到. 在文件底部的注释块中列出了未绑定的命令.</p>
<p>查看<code>keybindings.json</code>:</p>
<p>Windows, Linux: <strong>文件</strong> &gt; <strong>首选项</strong> &gt; <strong>键盘快捷方式</strong> &gt; <code>keybindings.json</code></p>
<p>macOS: <strong>编码</strong> &gt; <strong>首选项</strong> &gt; <strong>键盘快捷方式</strong> &gt; <code>keybindings.json</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="when-子句上下文"><a class="header" href="#when-子句上下文">when 子句上下文</a></h1>
<p>VS Code 为元素是否处于可见和激活状态，设置了不同的上下文值。这些上下文可以禁用或者启用插件的某些命令和 UI 元素，比如菜单和视图。</p>
<p>比如，VS Code 用 when 子句启停命令快捷键，你可以在默认快捷键绑定 JSON 文件中找到（<strong>首选项：打开默认键盘快捷键(JSON)</strong>）：</p>
<pre><code class="language-json">{ 
    &quot;key&quot;: &quot;f5&quot;,  
    &quot;command&quot;: &quot;workbench.action.debug.start&quot;,
    &quot;when&quot;: &quot;debuggersAvailable &amp;&amp; !inDebugMode&quot; 
}
</code></pre>
<p>上述内置<strong>启动调试器</strong>命令的快键键是 <code>F5</code>，它仅仅在适当的调试器可用（上下文中的 <code>debuggersAvailable</code> 为 true 时）且编辑器不在调试模式中（上下文中的 <code>inDebugMode</code> 为 false 时）才会启动。</p>
<h2 id="条件操作符"><a class="header" href="#条件操作符">条件操作符</a></h2>
<p>你可以使用下列条件操作符</p>
<div class="table-wrapper"><table><thead><tr><th>操作符</th><th>符号</th><th>例子</th></tr></thead><tbody>
<tr><td>相等</td><td><code>==</code></td><td><code>&quot;editorLangId == typescript&quot;</code></td></tr>
<tr><td>不相等</td><td><code>!=</code></td><td><code>&quot;resourceExtname != .js&quot;</code></td></tr>
<tr><td>或</td><td><code>\|\|</code></td><td><code>&quot;isLinux \|\| isWindows&quot;</code></td></tr>
<tr><td>且</td><td><code>&amp;&amp;</code></td><td><code>&quot;textInputFocus &amp;&amp; !editorReadonly&quot;</code></td></tr>
<tr><td>非</td><td><code>!</code></td><td><code>!editorReadonly</code></td></tr>
<tr><td>匹配</td><td><code>=~</code></td><td><code>&quot;resourceScheme =~ /^untitled$^file$/&quot;  </code></td></tr>
<tr><td>大于</td><td><code>&gt; &gt;=</code></td><td><code>&quot;gitOpenRepositoryCount &gt;= 1&quot;</code></td></tr>
<tr><td>小于</td><td><code>&lt; &lt;=</code></td><td><code>&quot;workspaceFolderCount &lt; 2&quot;</code></td></tr>
<tr><td>包含</td><td><code>in</code></td><td><code>resourceFilename in supportedFolders </code>(<a href="references/when-clause-contexts.html#_39in39-%E6%9D%A1%E4%BB%B6%E6%93%8D%E4%BD%9C%E7%AC%A6">详见</a> 下方 'in'-条件操作符)</td></tr>
</tbody></table>
</div>
<h3 id="键-值-when-子句操作符"><a class="header" href="#键-值-when-子句操作符">键-值 when 子句操作符</a></h3>
<p><code>when</code>子句中可以使用键值对匹配操作符。表达式 <code>key =~ value</code> 会把右侧作为正则表达式来匹配左侧。比如配置 Docker 文件的菜单项，你可以使用：</p>
<pre><code class="language-json">&quot;when&quot;: &quot;resourceFilename =~ /docker/&quot;
</code></pre>
<h2 id="可用上下文变量"><a class="header" href="#可用上下文变量">可用上下文变量</a></h2>
<p>下面是一些<code>when</code>子句中可以使用的上下文变量，这些值最终会被解析为布尔值 true/false。</p>
<p>这个表并不包含所有值，你可以在键盘快键键编辑器（<strong>首选项:打开键盘快捷键</strong>）或者默认快捷键绑定 JSON 文件（<strong>首选项：打开默认键盘快捷键(JSON)</strong>）中找到所有上下文变量。</p>
<div class="table-wrapper"><table><thead><tr><th>上下文名称</th><th>何时为真</th></tr></thead><tbody>
<tr><td><strong>编辑器上下文</strong></td><td></td></tr>
<tr><td><code>editorFocus</code></td><td>编辑器聚焦时，不管是聚焦到文本还是小部件</td></tr>
<tr><td><code>editorTextFocus</code></td><td>编辑器内的文本聚焦时（光标闪动）</td></tr>
<tr><td><code>textInputFocus</code></td><td>任何编辑器聚焦时（常规编辑器, 调试 REPL等等).</td></tr>
<tr><td><code>inputFocus</code></td><td>任何文本输入区域聚焦时（编辑器或文本框）</td></tr>
<tr><td><code>editorHasSelection</code></td><td>编辑器中的文本被选中时</td></tr>
<tr><td><code>editorHasMultipleSelections</code></td><td>多文本区被选中时（多个光标）</td></tr>
<tr><td><code>editorReadonly</code></td><td>编辑器只读时</td></tr>
<tr><td><code>editorLangId</code></td><td>当编辑器的<a href="https://code.visualstudio.com/docs/languages/identifiers">语言 ID</a> 匹配时。比如: <code>&quot;editorLangId == typescript&quot;</code>.</td></tr>
<tr><td><code>isInDiffEditor</code></td><td>激活的编辑器处于差异编辑器状态时</td></tr>
<tr><td><code>isInEmbeddedEditor</code></td><td>在嵌入式编辑器聚焦时</td></tr>
<tr><td><strong>操作系统上下文</strong></td><td></td></tr>
<tr><td><code>isLinux</code></td><td>系统是 Linux 时</td></tr>
<tr><td><code>isMac</code></td><td>系统是 macOS 时</td></tr>
<tr><td><code>isWindows</code></td><td>系统是 Windows  时</td></tr>
<tr><td><code>isWeb</code></td><td>从 web 访问编辑器时</td></tr>
<tr><td><strong>列表上下文</strong></td><td></td></tr>
<tr><td><code>listFocus</code></td><td>聚焦到列表时</td></tr>
<tr><td><code>listSupportsMultiselect</code></td><td>列表支持多选时</td></tr>
<tr><td><code>listHasSelectionOrFocus</code></td><td>列表被选中或聚焦时</td></tr>
<tr><td><code>listDoubleSelection</code></td><td>列表包含 2 个元素时</td></tr>
<tr><td><code>listMultiSelection</code></td><td>列表包含多个元素时</td></tr>
<tr><td><strong>模式上下文</strong></td><td></td></tr>
<tr><td><code>inSnippetMode</code></td><td>编辑器处于代码片段模式</td></tr>
<tr><td><code>inQuickOpen</code></td><td>聚焦到快速选择时</td></tr>
<tr><td><strong>资源上下文</strong></td><td></td></tr>
<tr><td><code>resourceScheme</code></td><td>资源的 Uri 协议匹配时。比如：<code>&quot;resourceScheme == file&quot;</code></td></tr>
<tr><td><code>resourceFilename</code></td><td>资源管理器或编辑器的文件名匹配时。比如: <code>&quot;resourceFilename == gulpfile.js&quot;</code></td></tr>
<tr><td><code>resourceExtname</code></td><td>资源管理器或编辑器的扩展文件名匹配时。比如: <code>&quot;resourceExtname == .js&quot;</code></td></tr>
<tr><td><code>resourceDirname</code></td><td>资源管理器或编辑器的资源文件夹绝对路径匹配时。比如: <code>&quot;resourceDirname == /users/alice/project/src&quot;</code></td></tr>
<tr><td><code>resourcePath</code></td><td>资源管理器或编辑器的资源绝对路径匹配时。比如: <code>&quot;resourcePath == /users/alice/project/gulpfile.js&quot;</code></td></tr>
<tr><td><code>resourceLangId</code></td><td>资源管理器或编辑器的<a href="https://code.visualstudio.com/docs/languages/identifiers">语言 ID</a>匹配时，比如: <code>&quot;resourceLangId == markdown&quot;</code></td></tr>
<tr><td><code>isFileSystemResource</code></td><td>资源管理器或编辑器的文件是文件系统供应器可处理的文件系统类型时</td></tr>
<tr><td><code>resourceSet</code></td><td>资源管理器或编辑器文件成组时</td></tr>
<tr><td><code>resource</code></td><td>资源管理器或编辑器的完整 Uri</td></tr>
<tr><td><strong>资源管理器上下文</strong></td><td></td></tr>
<tr><td><code>explorerViewletVisible</code></td><td>当资源管理器视图可见时</td></tr>
<tr><td><code>explorerViewletFocus</code></td><td>当资源管理器视图受键盘聚焦时</td></tr>
<tr><td><code>filesExplorerFocus</code></td><td>文件资源管理器区域受键盘聚焦时</td></tr>
<tr><td><code>openEditorsFocus</code></td><td>打开的编辑器区域受键盘聚焦时</td></tr>
<tr><td><code>explorerResourceIsFolder</code></td><td>资源管理器中选中了一个文件夹时</td></tr>
<tr><td><strong>编辑器小部件上下文</strong></td><td></td></tr>
<tr><td><code>findWidgetVisible</code></td><td>编辑器查找小部件可见时</td></tr>
<tr><td><code>suggestWidgetVisible</code></td><td>建议小部件可见时（智能提示）</td></tr>
<tr><td><code>suggestWidgetMultipleSuggestions</code></td><td>展示了多个提示时</td></tr>
<tr><td><code>renameInputVisible</code></td><td>重命名输入框可见时</td></tr>
<tr><td><code>referenceSearchVisible</code></td><td>查找引用窗口可见时</td></tr>
<tr><td><code>inReferenceSearchEditor</code></td><td>查找引用编辑器聚焦时</td></tr>
<tr><td><code>config.editor.stablePeek</code></td><td>引用编辑器保持打开时 (设置中的 <code>editor.stablePeek</code>)</td></tr>
<tr><td><code>quickFixWidgetVisible</code></td><td>快速修复小部件可见时</td></tr>
<tr><td><code>parameterHintsVisible</code></td><td>参数提示可见时 (设置中的 <code>editor.parameterHints.enabled</code>).</td></tr>
<tr><td><code>parameterHintsMultipleSignatures</code></td><td>多参数提示可见时</td></tr>
<tr><td><strong>调试器上下文</strong></td><td></td></tr>
<tr><td><code>debuggersAvailable</code></td><td>有合适的调试器插件可用时</td></tr>
<tr><td><code>inDebugMode</code></td><td>调试器会话在运行时</td></tr>
<tr><td><code>debugState</code></td><td>调试器激活状态，可用值有 <code>inactive</code>, <code>initializing</code>, <code>stopped</code>, <code>running</code>.</td></tr>
<tr><td><code>debugType</code></td><td>调试器类型匹配时，比如: <code>&quot;debugType == 'node'&quot;</code>.</td></tr>
<tr><td><code>inDebugRepl</code></td><td>调试控制台 REPL 聚焦时</td></tr>
<tr><td><strong>终端上下文</strong></td><td></td></tr>
<tr><td><code>terminalFocus</code></td><td>聚焦到终端时</td></tr>
<tr><td><code>terminalIsOpen</code></td><td>终端打开时</td></tr>
<tr><td><strong>时间线视图上下文</strong></td><td></td></tr>
<tr><td><code>timelineFollowActiveEditor</code></td><td>时间线视图跟随激活的编辑器时</td></tr>
<tr><td><strong>时间线视图项 上下文</strong></td><td></td></tr>
<tr><td><code>timelineItem</code></td><td>时间线项目的上下文变量匹配时，比如: <code>&quot;timelineItem =~ /git:file:commit\\b/&quot;</code>.</td></tr>
<tr><td><strong>插件上下文</strong></td><td></td></tr>
<tr><td><code>extension</code></td><td>插件 ID 匹配时，比如: <code>&quot;extension == eamodio.gitlens&quot;</code>.</td></tr>
<tr><td><code>extensionStatus</code></td><td>插件安装时，比如: <code>&quot;extensionStatus == installed&quot;</code>.</td></tr>
<tr><td><code>extensionHasConfiguration</code></td><td>插件存在配置时</td></tr>
<tr><td><strong>全局UI上下文</strong></td><td></td></tr>
<tr><td><code>notificationFocus</code></td><td>键盘聚焦到通知窗口</td></tr>
<tr><td><code>notificationCenterVisible</code></td><td>通知中心在 VS Code 右下角可见时</td></tr>
<tr><td><code>notificationToastsVisible</code></td><td>通知窗口在 VS Code 右下角可见时</td></tr>
<tr><td><code>searchViewletVisible</code></td><td>搜索视图打开时</td></tr>
<tr><td><code>sideBarVisible</code></td><td>侧边栏展示时</td></tr>
<tr><td><code>sideBarFocus</code></td><td>聚焦到侧边栏时</td></tr>
<tr><td><code>panelFocus</code></td><td>聚焦到面板焦时</td></tr>
<tr><td><code>inZenMode</code></td><td>窗口处于禅模式</td></tr>
<tr><td><code>isCenteredLayout</code></td><td>编辑器处于中心布局模式</td></tr>
<tr><td><code>workbenchState</code></td><td>值为 <code>empty</code>、 <code>folder</code> (至少包含一个文件夹) 或 <code>workspace</code>.</td></tr>
<tr><td><code>workspaceFolderCount</code></td><td>工作区文件夹数量</td></tr>
<tr><td><code>replaceActive</code></td><td>搜索视图中的替换文本框打开时</td></tr>
<tr><td><code>view</code></td><td>视图 ID 匹配时，比如: <code>&quot;view == myViewsExplorerID&quot;</code>.</td></tr>
<tr><td><code>viewItem</code></td><td>视图项上下文匹配时，比如:  <code>&quot;viewItem == someContextValue&quot;</code>.</td></tr>
<tr><td><code>isFullscreen</code></td><td>窗口全屏时</td></tr>
<tr><td><code>focusedView</code></td><td>当前聚焦视图的 ID</td></tr>
<tr><td><code>canNavigateBack</code></td><td>导航是否可以后退</td></tr>
<tr><td><code>canNavigateForward</code></td><td>导航是否可以前进</td></tr>
<tr><td><code>canNavigateToLastEditLocation</code></td><td>是否可以导航到上一次编辑位置</td></tr>
<tr><td><strong>全局编辑器 UI 上下文</strong></td><td></td></tr>
<tr><td><code>textCompareEditorVisible</code></td><td>最少有一个差异（对比）编辑器可见时</td></tr>
<tr><td><code>textCompareEditorActive</code></td><td>最少有一个差异（对比）编辑器激活</td></tr>
<tr><td><code>editorIsOpen</code></td><td>至少有一个编辑器打开时</td></tr>
<tr><td><code>groupEditorsCount</code></td><td>一个组内的编辑器数量</td></tr>
<tr><td><code>activeEditorGroupEmpty</code></td><td>激活的编辑器组内没有编辑器时</td></tr>
<tr><td><code>activeEditorGroupIndex</code></td><td>编辑器群块中的编辑器组的下标位置，从数字 <code>1</code> 开始。下标 <code>1</code> 表示从左上角开始计数的首个编辑器组</td></tr>
<tr><td><code>activeEditorGroupLast</code></td><td>编辑器群块中的最后一个编辑器组</td></tr>
<tr><td><code>multipleEditorGroups</code></td><td>多个编辑器群出现时</td></tr>
<tr><td><code>activeEditor</code></td><td>组内的某个激活的编辑器ID</td></tr>
<tr><td><code>activeEditorIsDirty</code></td><td>组内的某个激活的编辑器为脏时</td></tr>
<tr><td><code>activeEditorIsNotPreview</code></td><td>组内的某个激活的编辑器不在预览模式中</td></tr>
<tr><td><code>activeEditorIsPinned</code></td><td>组内的某个激活的编辑器被固定时</td></tr>
<tr><td><code>inSearchEditor</code></td><td>当焦点在搜索编辑器内时</td></tr>
<tr><td><strong>设置上下文</strong></td><td></td></tr>
<tr><td><code>config.editor.minimap.enabled</code></td><td>当设置中的 <code>editor.minimap.enabled</code> 为 <code>true</code> 时</td></tr>
</tbody></table>
</div>
<p>?&gt; 注意：你可以使用<code>config.</code>前缀，使用任意用户或工作区设置中的值。</p>
<h2 id="激活聚焦视图或面板相关的上下文变量"><a class="header" href="#激活聚焦视图或面板相关的上下文变量">激活/聚焦视图或面板相关的上下文变量</a></h2>
<p>你可以用 when 子句检查特定视图是否是可见的</p>
<div class="table-wrapper"><table><thead><tr><th>上下文名称</th><th>何时为真</th></tr></thead><tbody>
<tr><td>activeViewlet</td><td>当视图可见时，比如<code>&quot;activeViewlet == 'workbench.view.explorer'&quot;</code></td></tr>
<tr><td>activePanel</td><td>当面板可见时，比如<code>&quot;activePanel == 'workbench.panel.explorer'&quot;</code></td></tr>
<tr><td>focusedView</td><td>当聚焦到视图时，比如<code>&quot;focusedView == myViewsExplorerID&quot;</code></td></tr>
</tbody></table>
</div>
<p>视图标识：</p>
<ul>
<li>workbench.view.explorer - 资源文件管理器</li>
<li>workbench.view.search - 搜索</li>
<li>workbench.view.scm - 源控制</li>
<li>workbench.view.debug - 运行</li>
<li>workbench.view.extensions - 插件</li>
</ul>
<p>面板标识:</p>
<ul>
<li>workbench.panel.markers - 问题</li>
<li>workbench.panel.output - 输出</li>
<li>workbench.panel.repl - 调试控制台</li>
<li>terminal - 终端</li>
<li>workbench.panel.comments - 评论</li>
<li>workbench.view.search - 搜索， 当 <code>search.location</code> 设置到 <code>panel</code> 时</li>
</ul>
<p>如果你想要在特定视图或者面板聚焦时触发 when 子句，使用 <code>sideBarFocus</code> 或 <code>panelFocus</code> 与 <code>activeViewlet</code> 或 <code>activiewFocus</code> 进行组合。</p>
<p>比如，下列 when 子句只会在文件资源管理器聚焦时才会为真</p>
<pre><code class="language-json">&quot;sideBarFocus &amp;&amp; activeViewlet == 'workbench.view.explorer'&quot;
</code></pre>
<h2 id="在-when-子句中检查设置"><a class="header" href="#在-when-子句中检查设置">在 when 子句中检查设置</a></h2>
<p>在 when 子句中，你可以使用<code>config.</code>获取配置（设置）中的值。比如 <code>config.editor.tabCompletion</code> 或 <code>config.breadcrumbs.enabled</code></p>
<h2 id="添加自定义-when-子句上下文"><a class="header" href="#添加自定义-when-子句上下文">添加自定义 when 子句上下文</a></h2>
<p>如果你的插件需要使用 when 子句启动/禁用命令、菜单或者视图，而已有的上下文变量都不满足你的需求，你可以用 <code>setContext</code> 命令设置你自己的变量。</p>
<p>下面的第一个例子设置键<code>myExtension:showMyCommand</code>为真，你就可以在命令中或者 <code>when</code> 属性中进行使用了。第二个例子储存了一个值，那么你就可以在 <code>when</code> 子句中检查这个属性值是否大于 2 了。</p>
<pre><code class="language-typescript">vscode.commands.executeCommand('setContext', 'myExtension.showMyCommand', true);

vscode.commands.executeCommand('setContext', 'myExtension.numberOfCoolOpenThings', 4);
</code></pre>
<h2 id="in-条件操作符"><a class="header" href="#in-条件操作符">'in' 条件操作符</a></h2>
<p><code>when</code>中的操作符<code>in</code> 允许在上下文变量中动态查找其他的上下文变量值。比如，给包含特定文件的文件夹添加一个特殊的菜单命令（或者无法静态得知的其他东西），你可以使用 <code>in</code> 操作符来实现。</p>
<p>第一，确定需要支持的文件夹类型，比如是一个名称数组。然后，使用 <code>setContext</code> 命令把数组注入到上下文变量中：</p>
<pre><code class="language-typescript">vscode.commands.executeCommand('setContext', 'ext.supportedFolders', [
  'test',
  'foo',
  'bar'
]);

// 或者

// 注意本例（使用了一个对象）, 具体值是无关紧要的只要键存在于对象中
vscode.commands.executeCommand('setContext', 'ext.supportedFolders', {
  test: true,
  foo: 'anything',
  bar: false
});
</code></pre>
<p>然后在 <code>package.json</code> 中添加<code>explorer/context</code>菜单配置：</p>
<pre><code class="language-json">// 注意，本例假设你已经定义了一个叫做ext.doSpecial的命令
&quot;menus&quot;: {
  &quot;explorer/context&quot;: [
    {
      &quot;command&quot;: &quot;ext.doSpecial&quot;,
      &quot;when&quot;: &quot;explorerResourceIsFolder &amp;&amp; resourceFilename in ext:supportedFolders&quot;
    }
  ]
}
</code></pre>
<p>在这个例子里，我们拿到 <code>resourceFilename</code> 的值（在本例中也就是文件夹的名字）然后检查它是否在 <code>ext:supportedFolders</code> 之中。如果存在的话，菜单就会展示出来。这个强大的操作符使得更复杂的条件分支得以实现，同时也支持了动态配置。</p>
<h2 id="查看上下文变量的工具"><a class="header" href="#查看上下文变量的工具">查看上下文变量的工具</a></h2>
<p>如果你想在运行时查看当前所有激活的上下文变量，你可以打开命令面板(<code>⇧⌘P</code>) 使用 <strong>开发人员:检查上下文键值</strong> 命令。这个命令会打开 VS Code 开发者工具的 <strong>Console</strong> 标签（或 <strong>帮助 &gt; 打开开发者工具</strong>）然后显示出上下文变量的键值。</p>
<p>当你运行 <strong>开发人员:检查上下文键值</strong>，你的鼠标会高亮 VS Code UI 中的元素，当你点击一个元素时，对应的上下文变量和它们的状态就会输出到 <strong>Console</strong> 中。</p>
<p><img src="https://code.visualstudio.com/assets/api/references/when-clause-contexts/inspect-context-keys.png" alt="inspect-context-keys" /></p>
<p>一系列可能包含 <a href="references/when-clause-contexts.html#%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89-when-%E5%AD%90%E5%8F%A5%E4%B8%8A%E4%B8%8B%E6%96%87">自定义上下文变量</a> 的键值对会展示出来。</p>
<p>!&gt; 注意：部分 VS Code 内部使用的上下文变量在未来可能会有所变化。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="主题色彩"><a class="header" href="#主题色彩">主题色彩</a></h1>
<p>可以通过<a href="https://code.visualstudio.com/docs/getstarted/settings">用户设置</a>的<code>workbench.colorCustomizations</code>配置项，定制Visual Studio Code的<a href="https://code.visualstudio.com/docs/getstarted/themes">色彩主题</a>。</p>
<pre><code class="language-json">{
  &quot;workbench.colorCustomizations&quot;: {
    &quot;activityBar.background&quot;: &quot;#00AA00&quot;
  }
}
</code></pre>
<p>!&gt; <strong>注意</strong>: 如果你想用现成的颜色主题的话，通过<strong>首选项: 颜色主题</strong>的下拉菜单选取即可(<kbd>Ctrl+K Ctrl+T</kbd>)，参阅<a href="https://code.visualstudio.com/docs/getstarted/themes">色彩主题</a>。</p>
<h2 id="颜色格式"><a class="header" href="#颜色格式">颜色格式</a></h2>
<hr />
<p>可以使用RGBA来定义色值。同样，也支持十六进制表示法: <code>#RGB</code>，<code>#RGBA</code>，<code>#RRGGBB</code>，<code>#RRGGBBAA</code>。R(红)，G(绿)，B(蓝)，A(阿尔法)是一个十六进制字符(0-9，a-f，A-F)。<code>#RRGGBB</code>和<code>#RRGGBBAA</code>分别可以简写为<code>#RGB</code>和<code>#RGBA</code>。比如，<code>#ee3355ff</code>和<code>#e35f</code>是一样的效果。</p>
<p>如果没有定义alpha值，那么它的默认值是<code>ff</code>(不透明，没有透明度)。反之，如果设为<code>00</code>，则完全透明。</p>
<p>一些颜色应该设置成透明的，以免遮挡其他注释的视线。查看颜色描述来了解哪些颜色应该使用这个规则。</p>
<h2 id="对比色"><a class="header" href="#对比色">对比色</a></h2>
<hr />
<p>一般用于高对比度的主题。通过给UI项添加额外的边框来增强对比度。</p>
<ul>
<li><code>contrastActiveBorder</code>: 在活动元素周围额外的一层边框，用来提高对比度从而区别其他元素</li>
<li><code>contrastBorder</code>: 在元素周围额外的一层边框，用来提高对比度从而区别其他元素</li>
</ul>
<h2 id="基色"><a class="header" href="#基色">基色</a></h2>
<hr />
<ul>
<li><code>focusBorder</code>: 焦点元素的整体边框颜色。此颜色仅在不被其他组件覆盖时适用</li>
<li><code>foreground</code>: 整体前景色。此颜色仅在不被组件覆盖时适用</li>
<li><code>widget.shadow</code>: 编辑器内小组件（如查找/替换）的阴影颜色</li>
<li><code>selection.background</code>: 工作台所选文本的背景颜色（例如输入字段或文本区域）。注意，本设置不适用于编辑器</li>
<li><code>descriptionForeground</code>: 提供其他信息的说明文本的前景色，例如标签文本</li>
<li><code>errorForeground</code>: 错误信息的全局前景色。此颜色仅在不被组件覆盖时适用</li>
</ul>
<h2 id="文本颜色"><a class="header" href="#文本颜色">文本颜色</a></h2>
<hr />
<p>文本文档中的颜色，比如欢迎页</p>
<ul>
<li><code>textBlockQuote.background</code>: 文本中块引用的背景颜色</li>
<li><code>textBlockQuote.border</code>: 文本中块引用的边框颜色</li>
<li><code>textCodeBlock.background</code>: 文本中代码块的背景颜色</li>
<li><code>textLink.activeForeground</code>: 鼠标点击后或悬停时链接的前景色</li>
<li><code>textLink.foreground</code>: 文本中链接的前景色</li>
<li><code>textPreformat.foreground</code>: 预格式化文本段的前景色</li>
<li><code>textSeparator.foreground</code>: 文字分隔符的颜色</li>
</ul>
<h2 id="按钮控件"><a class="header" href="#按钮控件">按钮控件</a></h2>
<hr />
<p>按钮小组件的颜色，例如新窗口的资源管理器中的<strong>打开文件夹</strong>按钮。</p>
<p><img src="https://media.githubusercontent.com/media/Microsoft/vscode-docs/master/api/references/images/theme-color/button.png" alt="按钮控件" /></p>
<ul>
<li><code>button.background</code>: 按钮背景色</li>
<li><code>button.foreground</code>: 按钮前景色</li>
<li><code>button.hoverBackground</code>: 鼠标悬停时按钮的背景颜色</li>
</ul>
<h2 id="下拉列表控件"><a class="header" href="#下拉列表控件">下拉列表控件</a></h2>
<hr />
<p>下拉列表小部件颜色，例如集成终端和输出面板。</p>
<p>!&gt; <strong>注意</strong>: macOS目前还不能用该控件</p>
<p><img src="https://media.githubusercontent.com/media/Microsoft/vscode-docs/master/api/references/images/theme-color/dropdown.png" alt="下拉列表控件" /></p>
<ul>
<li><code>dropdown.background</code>: 下拉列表背景色</li>
<li><code>dropdown.listBackground</code>: 下拉列表背景色</li>
<li><code>dropdown.border</code>: 下拉列表边框</li>
<li><code>dropdown.foreground</code>: 下拉列表前景色</li>
</ul>
<h2 id="输入框控件"><a class="header" href="#输入框控件">输入框控件</a></h2>
<hr />
<p>输入框控件颜色，例如搜索视图、搜索/替换对话框。</p>
<p><img src="https://media.githubusercontent.com/media/Microsoft/vscode-docs/master/api/references/images/theme-color/input.png" alt="输入框控件" /></p>
<ul>
<li><code>input.background</code>: 输入框背景色</li>
<li><code>input.border</code>: 输入框边框</li>
<li><code>input.foreground</code>: 输入框前景色</li>
<li><code>input.placeholderForeground</code>: 输入框中占位符的前景色</li>
<li><code>inputOption.activeBorder</code>: 输入字段中已激活选项的边框颜色</li>
<li><code>inputValidation.errorBackground</code>: 输入验证结果为错误级别时的背景色</li>
<li><code>inputValidation.errorForeground</code>: 输入验证结果为错误级别时的前景色</li>
<li><code>inputValidation.errorBorder</code>: 严重性为错误时输入验证的边框颜色</li>
<li><code>inputValidation.infoBackground</code>: 输入验证结果为信息级别时的背景色</li>
<li><code>inputValidation.infoForeground</code>: 输入验证结果为信息级别时的前景色</li>
<li><code>inputValidation.infoBorder</code>: 严重性为信息时输入验证的边框颜色</li>
<li><code>inputValidation.warningBackground</code>: 严重性为警告时输入验证的背景色</li>
<li><code>inputValidation.warningForeground</code>: 输入验证结果为警告级别时的前景色</li>
<li><code>inputValidation.warningBorder</code>: 严重性为警告时输入验证的边框颜色</li>
</ul>
<h2 id="滚动条控件"><a class="header" href="#滚动条控件">滚动条控件</a></h2>
<hr />
<ul>
<li><code>scrollbar.shadow</code>: 视图滚动后，滚动条的阴影</li>
<li><code>scrollbarSlider.activeBackground</code>: 点击滚动条滑块后的背景色</li>
<li><code>scrollbarSlider.background</code>: 滚动条滑块背景色</li>
<li><code>scrollbarSlider.hoverBackground</code>: 鼠标悬停滚动条滑块时的背景色</li>
</ul>
<h2 id="徽章"><a class="header" href="#徽章">徽章</a></h2>
<hr />
<p>Badge 是小型的信息标签，如表示搜索结果数量的标签</p>
<ul>
<li><code>badge.foreground</code>: Badge前景色</li>
<li><code>badge.background</code>: Badge背景色</li>
</ul>
<h2 id="进度条"><a class="header" href="#进度条">进度条</a></h2>
<hr />
<ul>
<li><code>progressBar.background</code>: 表示长时间操作的进度条的背景色</li>
</ul>
<h2 id="列表和树"><a class="header" href="#列表和树">列表和树</a></h2>
<hr />
<p>列表和树的色彩，例如资源管理器。激活的列表/树具有键盘焦点，反之则没有。</p>
<ul>
<li><code>list.activeSelectionBackground</code>: 激活列表/树时已选项的背景色</li>
<li><code>list.activeSelectionForeground</code>: 列表/树激活时已选项的前景色</li>
<li><code>list.dropBackground</code>: 使用鼠标移动列表项时，列表/树的背景颜色</li>
<li><code>list.focusBackground</code>: 列表/树激活时焦点项的背景色</li>
<li><code>list.focusForeground</code>: 列表/树激活时焦点项的前景色</li>
<li><code>list.highlightForeground</code>: 在列表或树中搜索时，其中匹配内容的高亮颜色</li>
<li><code>list.hoverBackground</code>: 使用鼠标移动项目时，列表或树的背景颜色</li>
<li><code>list.hoverForeground</code>: 鼠标在项目上悬停时，列表或树的前景颜色</li>
<li><code>list.inactiveSelectionBackground</code>: 列表/树未激活时已选项的背景色</li>
<li><code>list.inactiveSelectionForeground</code>: 列表/树未激活时已选项的前景色</li>
<li><code>list.inactiveFocusBackground</code>: 非激活的列表或树控件中焦点项的背景颜色</li>
<li><code>list.invalidItemForeground</code>: 列表或树中无效项的前景色，例如资源管理器中没有解析的根目录</li>
<li><code>list.errorForeground</code>: 包含错误的列表项的前景颜色</li>
<li><code>list.warningForeground</code>: 包含警告的列表项的前景颜色</li>
<li><code>listFilterWidget.background</code>: 列表和树中类型筛选器小组件的背景色</li>
<li><code>listFilterWidget.outline</code>: 列表和树中类型筛选器小组件的轮廓颜色</li>
<li><code>listFilterWidget.noMatchesOutline</code>: 当没有匹配项时，列表和树中类型筛选器小组件的轮廓颜色</li>
</ul>
<h2 id="活动栏"><a class="header" href="#活动栏">活动栏</a></h2>
<hr />
<p>活动栏可显示在最左侧或最右侧，供用户快速切换侧边栏视图</p>
<ul>
<li><code>activityBar.background</code>: 活动栏背景色</li>
<li><code>activityBar.dropBackground</code>: 拖放活动栏项时的视觉反馈颜色。此颜色应有透明度，以便活动栏条目能透过此颜色</li>
<li><code>activityBar.foreground</code>: 激活时活动栏项的前景色</li>
<li><code>activityBar.inactiveForeground</code>: 未激活时活动栏项的前景色</li>
<li><code>activityBar.border</code>: 活动栏分隔侧边栏的边框颜色</li>
<li><code>activityBarBadge.background</code>: 活动通知徽章背景色</li>
<li><code>activityBarBadge.foreground</code>: 活动通知徽章前景色</li>
</ul>
<h2 id="侧边栏"><a class="header" href="#侧边栏">侧边栏</a></h2>
<hr />
<p>侧边栏是资源管理器和搜索等视图的容器。</p>
<ul>
<li><code>sideBar.background</code>: 侧边栏背景色</li>
<li><code>sideBar.foreground</code>: 侧边栏前景色</li>
<li><code>sideBar.border</code>: 侧边栏分隔编辑器的边框颜色</li>
<li><code>sideBar.dropBackground</code>: 拖放侧边栏区域时的反馈颜色。此颜色应有透明度，以便侧边栏中的部分仍能透过</li>
<li><code>sideBarTitle.foreground</code>: 侧边栏标题前景色</li>
<li><code>sideBarSectionHeader.background</code>: 侧边栏节标题的背景颜色</li>
<li><code>sideBarSectionHeader.foreground</code>: 侧边栏节标题的前景色</li>
<li><code>sideBarSectionHeader.border</code>: 侧边栏节标题的边框颜色</li>
</ul>
<h2 id="编辑器组--选项卡"><a class="header" href="#编辑器组--选项卡">编辑器组 &amp; 选项卡</a></h2>
<hr />
<p>编辑器组是多个编辑器的容器，一个编辑器组可以包含多个编辑器。一个选项卡是一个编辑器的容器。可以在一个编辑器组里面打开多个选项卡。</p>
<ul>
<li><code>editorGroup.border</code>: 编辑器组之间的分隔颜色</li>
</ul>
<p><img src="https://media.githubusercontent.com/media/Microsoft/vscode-docs/master/api/references/images/theme-color/editorGroup-border.gif" alt="编辑器组边框" /></p>
<ul>
<li><code>editorGroup.dropBackground</code>: 拖动编辑器时的背景颜色</li>
</ul>
<p><img src="https://media.githubusercontent.com/media/Microsoft/vscode-docs/master/api/references/images/theme-color/editorGroup-dropbackground.gif" alt="编辑器组拖动背景色" /></p>
<ul>
<li><code>editorGroupHeader.noTabsBackground</code>: 禁用选项卡 (<code>&quot;workbench.editor.showTabs&quot;: false</code>) 时编辑器组标题颜色</li>
</ul>
<p><img src="https://media.githubusercontent.com/media/Microsoft/vscode-docs/master/api/references/images/theme-color/editorgroupheader-notabsbackground.gif" alt="禁用选项卡时的编辑器组标题颜色" /></p>
<ul>
<li><code>editorGroupHeader.tabsBackground</code>: 启用选项卡时编辑器组标题的背景颜色</li>
</ul>
<p><img src="https://media.githubusercontent.com/media/Microsoft/vscode-docs/master/api/references/images/theme-color/editorgroupheader-tabsbackground.gif" alt="启用选项卡时编辑器组标题的背景颜色" /></p>
<ul>
<li><code>editorGroupHeader.tabsBorder</code>: 选项卡启用时编辑器组标题的边框颜色。</li>
</ul>
<p><img src="https://media.githubusercontent.com/media/Microsoft/vscode-docs/master/api/references/images/theme-color/editorgroupheader-tabsborder.gif" alt="启用选项卡时编辑器组标题的边框" /></p>
<ul>
<li><code>editorGroup.emptyBackground</code>: 空编辑器组的背景色</li>
<li><code>editorGroup.focusedEmptyBorder</code>: 编辑器组被聚焦时的边框颜色</li>
<li><code>tab.activeBackground</code>: 活动选项卡的背景色</li>
<li><code>tab.activeForeground</code>: 活动组中活动选项卡的前景色</li>
<li><code>tab.border</code>: 分隔多个选项卡的边框</li>
<li><code>tab.activeBorder</code>: 活动选项卡底部的边框</li>
<li><code>tab.unfocusedActiveBorder</code>: 在失去焦点的编辑器组中的活动选项卡底部的边框</li>
<li><code>tab.activeBorderTop</code>: 活动选项卡顶部的边框</li>
<li><code>tab.unfocusedActiveBorderTop</code>: 在失去焦点的编辑器组中的活动选项卡顶部的边框</li>
<li><code>tab.inactiveBackground</code>: 非活动选项卡的背景色</li>
<li><code>tab.inactiveForeground</code>: 活动组中非活动选项卡的前景色</li>
<li><code>tab.unfocusedActiveForeground</code>: 一个失去焦点的编辑器组中的活动选项卡的前景色</li>
<li><code>tab.unfocusedInactiveForeground</code>: 在一个失去焦点的组中非活动选项卡的前景色</li>
<li><code>tab.hoverBackground</code>: 鼠标悬停时选项卡的背景色</li>
<li><code>tab.unfocusedHoverBackground</code>: 鼠标悬停时非焦点组选项卡的背景色</li>
<li><code>tab.hoverBorder</code>: 鼠标悬停时选项卡的边框颜色</li>
<li><code>tab.unfocusedHoverBorder</code>: 鼠标悬停时非焦点组选项卡的边框颜色</li>
<li><code>tab.activeModifiedBorder</code> : 在活动编辑器组中已修改 (存在更新) 的活动选项卡的顶部边框</li>
<li><code>tab.inactiveModifiedBorder</code>: 在活动编辑器组中已修改 (存在更新) 的非活动选项卡的顶部边框</li>
<li><code>tab.unfocusedActiveModifiedBorder</code>: 在未获焦点的编辑器组中已修改 (存在更新) 的活动选项卡的顶部边框</li>
<li><code>tab.unfocusedInactiveModifiedBorder</code>: 在未获焦点的编辑器组中已修改 (存在更新) 的非活动选项卡的顶部边框</li>
<li><code>editorPane.background</code>: 居中编辑器布局中左侧与右侧编辑器窗格的背景色</li>
</ul>
<h2 id="编辑器色彩"><a class="header" href="#编辑器色彩">编辑器色彩</a></h2>
<hr />
<p>编辑器里面最重要的字符符号颜色主要是语法高亮。可以在色彩主题中或者使用<code>editor.tokenColorCustomizations</code>配置。参阅<a href="https://code.visualstudio.com/docs/getstarted/themes#_customizing-a-color-theme">定制色彩主题</a>以了解更新色彩主题和可用的标记类型</p>
<p>下面列出了所有的编辑器色彩:</p>
<ul>
<li><code>editor.background</code>: 编辑器背景色</li>
<li><code>editor.foreground</code>: 编辑器前景色</li>
<li><code>editorLineNumber.foreground</code>: 编辑器行号的颜色</li>
<li><code>editorLineNumber.activeForeground</code>: 编辑器活动行号的颜色</li>
<li><code>editorCursor.background</code>: 编辑器光标的背景色。可以自定义块型光标覆盖字符的颜色</li>
<li><code>editorCursor.foreground</code>: 编辑器光标的前景色。可以自定义块型光标覆盖字符的颜色</li>
</ul>
<p>当选中多个字符时会显示选区颜色。同时，与所选文本相关的区域也会高亮显示。</p>
<p><img src="https://media.githubusercontent.com/media/Microsoft/vscode-docs/master/api/references/images/theme-color/selectionhighlight.png" alt="选区高亮" /></p>
<ul>
<li><code>editor.selectionBackground</code>: 所选内容的背景色</li>
<li><code>editor.selectionForeground</code>: 所选文本的前景色</li>
<li><code>editor.inactiveSelectionBackground</code>: 非活动编辑器中所选内容的颜色，颜色需带有透明度，以免遮挡底层样式</li>
<li><code>editor.selectionHighlightBackground</code>: 具有与所选项相关内容的区域的颜色。颜色需带有透明度，以免遮挡底层样式</li>
<li><code>editor.selectionHighlightBorder</code>: 与所选项内容相同的区域的边框颜色</li>
</ul>
<p>当光标出现在符号或单词中时需显示单词高亮，依据语言插件的实现情况，可提供与高亮单词所对应声明和引用的语法高亮效果，但是这个高亮效果需和只读、书写的情况下的高亮效果有所区分。如果文档的语法插件不提供此项功能，那么高亮效果应降级到单纯的单词高亮:</p>
<p><img src="https://media.githubusercontent.com/media/Microsoft/vscode-docs/master/api/references/images/theme-color/occurrences.png" alt="符号和单词高亮" /></p>
<ul>
<li><code>editor.wordHighlightBackground</code>: 读取访问期间符号的背景色，例如读取变量时。颜色需带有透明度，以免遮挡底层样式</li>
<li><code>editor.wordHighlightBorder</code>: 符号在进行读取访问操作时的边框颜色，例如读取变量</li>
<li><code>editor.wordHighlightStrongBackground</code>: 写入访问过程中符号的背景色，例如写入变量时。颜色需带有透明度，以免遮挡底层样式</li>
<li><code>editor.wordHighlightStrongBorder</code>: 符号在进行写入访问操作时的边框颜色，例如写入变量</li>
</ul>
<p>搜索匹配项的颜色取决于搜索/替换对话框中的输入文字:</p>
<p><img src="https://media.githubusercontent.com/media/Microsoft/vscode-docs/master/api/references/images/theme-color/findmatches.png" alt="搜索匹配项" /></p>
<ul>
<li><code>editor.findMatchBackground</code>: 当前搜索匹配项的颜色</li>
<li><code>editor.findMatchHighlightBackground</code>: 其他搜索匹配项的颜色。颜色需带有透明度，以免遮挡底层样式</li>
<li><code>editor.findRangeHighlightBackground</code>: 限制搜索范围的颜色(搜索弹出框小部件的‘在结果中查找’中可用)。颜色需带有透明度，以免遮挡底层样式</li>
<li><code>editor.findMatchBorder</code>: 当前搜索匹配项的边框颜色</li>
<li><code>editor.findMatchHighlightBorder</code>: 其他搜索匹配项的边框颜色</li>
<li><code>editor.findRangeHighlightBorder</code>: 搜索范围限制中的边框颜色（搜索弹出框小部件的‘在结果中查找’中可用）</li>
</ul>
<p>鼠标悬停时符号的颜色:</p>
<p><img src="https://media.githubusercontent.com/media/Microsoft/vscode-docs/master/api/references/images/theme-color/hoverhighlight.png" alt="悬停高亮" /></p>
<ul>
<li><code>editor.hoverHighlightBackground</code>: 在下面突出显示悬停的字词。颜色需带有透明度，以免遮挡底层样式</li>
</ul>
<p>当前行(光标所在行)只会显示背景高亮或者边框高亮(两者之一)</p>
<p><img src="https://media.githubusercontent.com/media/Microsoft/vscode-docs/master/api/references/images/theme-color/line.png" alt="行高亮" /></p>
<ul>
<li><code>editor.lineHighlightBackground</code>: 光标所在行高亮内容的背景颜色</li>
<li><code>editor.lineHighlightBorder</code>: 光标所在行四周边框的背景颜色</li>
</ul>
<p>链接被点击时的颜色:</p>
<p><img src="https://media.githubusercontent.com/media/Microsoft/vscode-docs/master/api/references/images/theme-color/link.png" alt="点击链接" /></p>
<ul>
<li><code>editorLink.activeForeground</code>: 激活的链接的前景色</li>
</ul>
<p>选择搜索结果时的范围高亮:</p>
<p><img src="https://media.githubusercontent.com/media/Microsoft/vscode-docs/master/api/references/images/theme-color/rangehighlight.png" alt="范围高亮" /></p>
<ul>
<li><code>editor.rangeHighlightBackground</code>: 限制搜索范围的颜色，用于快速打开、文件中的符号、搜索结果。颜色需带有透明度，以免遮挡底层样式</li>
<li><code>editor.rangeHighlightBorder</code>: 限制搜索的范围的边框颜色</li>
</ul>
<p>要查看编辑器在空白字符上显示符号的方式，启用(enable)<strong>Toggle Render Whitespace</strong>配置项。</p>
<ul>
<li><code>editorWhitespace.foreground</code>: 编辑器中空白字符的前景色</li>
</ul>
<p>使用<code>&quot;editor.renderIndentGuides: true&quot;</code>配置编辑器显示缩进参考线</p>
<ul>
<li><code>editorIndentGuide.background</code>: 编辑器缩进参考线的颜色</li>
<li><code>editorIndentGuide.activeBackground</code>: 编辑器活动缩进参考线的颜色</li>
</ul>
<p>使用<code>&quot;editor.rulers&quot;</code>来配置编辑器标尺</p>
<ul>
<li><code>editorRuler.foreground</code>: 编辑器标尺的前景色</li>
</ul>
<p>CodeLens:</p>
<p><img src="https://media.githubusercontent.com/media/Microsoft/vscode-docs/master/api/references/images/theme-color/codelens.png" alt="CodeLens" /></p>
<ul>
<li><code>editorCodeLens.foreground</code>: 编辑器 CodeLens 的前景色</li>
</ul>
<p>括号匹配:</p>
<p><img src="https://media.githubusercontent.com/media/Microsoft/vscode-docs/master/api/references/images/theme-color/bracket-colors.png" alt="括号匹配" /></p>
<ul>
<li><code>editorBracketMatch.background</code>: 匹配括号的背景色</li>
<li><code>editorBracketMatch.border</code>: 匹配括号外框的颜色</li>
</ul>
<p>缩略图标尺:</p>
<p>位于编辑器右边缘滚动条下方，可以概览整个编辑器。</p>
<ul>
<li><code>editorOverviewRuler.border</code>: 缩略图标尺边框的颜色</li>
<li><code>editorOverviewRuler.findMatchForeground</code>: 用于查找匹配项的概述标尺标记颜色，颜色需带有透明度，以免遮挡底层样式</li>
<li><code>editorOverviewRuler.rangeHighlightForeground</code>: 用于突出显示范围的概述标尺标记颜色，比如快速打开、文件中的符号、查找功能。颜色需带有透明度，以免遮挡底层样式</li>
<li><code>editorOverviewRuler.selectionHighlightForeground</code>: 用于突出显示所选内容的概述标尺标记颜色。颜色需带有透明度，以免遮挡底层样式</li>
<li><code>editorOverviewRuler.wordHighlightForeground</code>: 用于突出显示符号的概述标尺标记颜色。颜色需带有透明度，以免遮挡底层样式</li>
<li><code>editorOverviewRuler.wordHighlightStrongForeground</code>: 用于突出显示写权限符号的概述标尺标记颜色。颜色需带有透明度，以免遮挡底层样式</li>
<li><code>editorOverviewRuler.modifiedForeground</code>: 缩略图标尺中已修改内容的颜色</li>
<li><code>editorOverviewRuler.addedForeground</code>: 缩略图标尺中已增加内容的颜色</li>
<li><code>editorOverviewRuler.deletedForeground</code>: 缩略图标尺中已删除内容的颜色</li>
<li><code>editorOverviewRuler.errorForeground</code>: 缩略图标尺中错误内容的颜色</li>
<li><code>editorOverviewRuler.warningForeground</code>: 缩略图标尺中警告信息的颜色</li>
<li><code>editorOverviewRuler.infoForeground</code>: 缩略图标尺中信息的颜色</li>
<li><code>editorOverviewRuler.bracketMatchForeground</code>: 缩略图标尺上表示匹配括号的标记颜色</li>
</ul>
<p>错误和警告:</p>
<ul>
<li><code>editorError.foreground</code>: 错误信息的整体前景色。此颜色仅在不被组件覆盖时适用</li>
<li><code>editorError.border</code>: 编辑器中错误波浪线的边框颜色</li>
<li><code>editorWarning.foreground</code>: 编辑器中警告波浪线的前景色</li>
<li><code>editorWarning.border</code>: 编辑器中警告波浪线的边框颜色</li>
<li><code>editorInfo.foreground</code>: 编辑器中信息波浪线的前景色</li>
<li><code>editorInfo.border</code>: 编辑器中信息波浪线的边框颜色</li>
<li><code>editorHint.foreground</code>: 编辑器中提示波浪线的前景色</li>
<li><code>editorHint.border</code>: 编辑器中提示波浪线的边框颜色</li>
</ul>
<p>未使用的源代码:</p>
<ul>
<li><code>editorUnnecessaryCode.border</code>: 编辑器中不必要(未使用)的源代码的边框颜色</li>
<li><code>editorUnnecessaryCode.opacity</code>: 不必要（未使用）代码的在编辑器中显示的不透明度。例如，<code>&quot;#000000c0&quot;</code> 将以 75% 的不透明度显示代码。对于高对比度主题，请使用 <code>&quot;editorUnnecessaryCode.border&quot;</code> 主题来为非必须代码添加下划线，以避免颜色淡化</li>
</ul>
<p>导航线包括字符边距和行号:</p>
<ul>
<li><code>editorGutter.background</code>: 编辑器导航线的背景色，导航线包括字符边距和行号</li>
<li><code>editorGutter.modifiedBackground</code>: 编辑器导航线中被修改行的背景颜色</li>
<li><code>editorGutter.addedBackground</code>: 编辑器导航线中已插入行的背景颜色</li>
<li><code>editorGutter.deletedBackground</code>: 编辑器导航线中被删除行的背景颜色</li>
</ul>
<h2 id="差异编辑器色彩"><a class="header" href="#差异编辑器色彩">差异编辑器色彩</a></h2>
<hr />
<p>已插入或者移除的文字的颜色，使用背景色或者边框色(两者选其一)</p>
<ul>
<li><code>diffEditor.insertedTextBackground</code>: 已插入的文本的背景色。颜色需带有透明度，以免遮挡底层样式</li>
<li><code>diffEditor.insertedTextBorder</code>: 插入的文本的轮廓颜色</li>
<li><code>diffEditor.removedTextBackground</code>: 已删除的文本的背景色。颜色需带有透明度，以免遮挡底层样式</li>
<li><code>diffEditor.removedTextBorder</code>: 被删除文本的轮廓颜色</li>
<li><code>diffEditor.border</code>: 两个文本编辑器之间的边框颜色</li>
</ul>
<h2 id="编辑器小部件色彩"><a class="header" href="#编辑器小部件色彩">编辑器小部件色彩</a></h2>
<hr />
<p>编辑器组件在其内容的前面。例如(查找/替换)对话框、建议组件、编辑器悬浮提示框</p>
<ul>
<li><code>editorWidget.background</code>: 编辑器组件(如查找/替换)背景颜色</li>
<li><code>editorWidget.border</code>: 编辑器小部件的边框颜色。此颜色仅在小部件有边框且不被小部件重写时适用</li>
<li><code>editorWidget.resizeBorder</code>: 编辑器小部件大小调整条的边框颜色。此颜色仅在小部件有调整边框且不被小部件颜色覆盖时使用</li>
<li><code>editorSuggestWidget.background</code>: 代码提示浮层的背景色</li>
<li><code>editorSuggestWidget.border</code>: 代码提示浮层的边框颜色</li>
<li><code>editorSuggestWidget.foreground</code>: 代码提示浮层的前景色</li>
<li><code>editorSuggestWidget.highlightForeground</code>: 代码提示浮层中匹配内容的高亮颜色</li>
<li><code>editorSuggestWidget.selectedBackground</code>: 代码提示浮层中所选条目的背景色</li>
<li><code>editorHoverWidget.background</code>: 代码提示浮层背景颜色</li>
<li><code>editorHoverWidget.border</code>: 代码提示浮层边框颜色</li>
</ul>
<p>异常小组件是一个速览窗口，当调试抛出异常时出现</p>
<ul>
<li><code>debugExceptionWidget.background</code>: 异常小组件背景颜色</li>
<li><code>debugExceptionWidget.border</code>: 异常小组件边框颜色</li>
</ul>
<p>编辑器标记，当导航至编辑器中的错误和警告时出现(<strong>跳到下一个错误或警告</strong>命令)</p>
<ul>
<li><code>editorMarkerNavigation.background</code>: 编辑器标记导航小组件背景色</li>
<li><code>editorMarkerNavigationError.background</code>: 编辑器标记导航小组件错误颜色</li>
<li><code>editorMarkerNavigationWarning.background</code>: 编辑器标记导航小组件警告颜色</li>
<li><code>editorMarkerNavigationInfo.background</code>: 编辑器标记导航小组件信息颜色</li>
</ul>
<h2 id="速览窗口色彩"><a class="header" href="#速览窗口色彩">速览窗口色彩</a></h2>
<hr />
<p>速览窗口在编辑器内部，将引用和声明显示为视图</p>
<p><img src="https://media.githubusercontent.com/media/Microsoft/vscode-docs/master/api/references/images/theme-color/peek-view.png" alt="速览窗口" /></p>
<ul>
<li><code>peekView.border</code>: 速览视图边框和箭头颜色</li>
<li><code>peekViewEditor.background</code>: 速览视图编辑器背景色</li>
<li><code>peekViewEditorGutter.background</code>: 速览视图编辑器中装订线的背景色</li>
<li><code>peekViewEditor.matchHighlightBackground</code>: 在速览视图编辑器中匹配突出显示颜色</li>
<li><code>peekViewEditor.matchHighlightBorder</code>: 在速览视图编辑器中匹配项的突出显示边框</li>
<li><code>peekViewResult.background</code>: 速览视图结果列表背景色</li>
<li><code>peekViewResult.fileForeground</code>: 速览视图结果列表中文件节点的前景色</li>
<li><code>peekViewResult.lineForeground</code>: 速览视图结果列表中行节点的前景色</li>
<li><code>peekViewResult.matchHighlightBackground</code>: 在速览视图结果列表中匹配突出显示颜色</li>
<li><code>peekViewResult.selectionBackground</code>: 速览视图结果列表中所选条目的背景色</li>
<li><code>peekViewResult.selectionForeground</code>: 速览视图结果列表中所选条目的前景色</li>
<li><code>peekViewTitle.background</code>: 速览视图标题区域背景颜色</li>
<li><code>peekViewTitleDescription.foreground</code>: 速览视图标题信息颜色</li>
<li><code>peekViewTitleLabel.foreground</code>: 速览视图标题颜色</li>
</ul>
<h2 id="合并冲突"><a class="header" href="#合并冲突">合并冲突</a></h2>
<hr />
<p>合并冲突装饰，当编辑器包含范围差异时显示</p>
<p><img src="https://media.githubusercontent.com/media/Microsoft/vscode-docs/master/api/references/images/theme-color/merge-ranges.png" alt="合并范围差异" /></p>
<ul>
<li><code>merge.currentHeaderBackground</code>: 当前标题的背景颜色。颜色需带有透明度，以免遮挡底层样式</li>
<li><code>merge.currentContentBackground</code>: 当前内容背景色。颜色需带有透明度，以免遮挡底层样式</li>
<li><code>merge.incomingHeaderBackground</code>: 传入标题背景色。颜色需带有透明度，以免遮挡底层样式</li>
<li><code>merge.incomingContentBackground</code>: 传入内容背景色。颜色需带有透明度，以免遮挡底层样式</li>
<li><code>merge.border</code>: 标头和分割线的边框颜色</li>
<li><code>merge.commonContentBackground</code>: 共同祖先的内容背景色。颜色需带有透明度，以免遮挡底层样式</li>
<li><code>merge.commonHeaderBackground</code>: 共同祖先的标头背景色，颜色需带有透明度，以免遮挡底层样式</li>
<li><code>editorOverviewRuler.currentContentForeground</code>: 当前版本区域的缩略图标尺前景色</li>
<li><code>editorOverviewRuler.incomingContentForeground</code>: 传入的版本区域的缩略图标尺前景色</li>
<li><code>editorOverviewRuler.commonContentForeground</code>: 共同祖先内容的缩略图标尺前景色</li>
</ul>
<h2 id="面板色彩"><a class="header" href="#面板色彩">面板色彩</a></h2>
<hr />
<p>面板显示在编辑器区域下方，包含输出和集成终端等视图</p>
<ul>
<li><code>panel.background</code>: 面板的背景色</li>
<li><code>panel.border</code>: 将面板与编辑器隔开的边框的颜色</li>
<li><code>panel.dropBackground</code>: 拖放面板标题项时的视觉反馈颜色，此颜色应有透明度，以免遮挡面板项</li>
<li><code>panelTitle.activeBorder</code>: 活动面板标题的边框颜色</li>
<li><code>panelTitle.activeForeground</code>: 活动面板的标题颜色</li>
<li><code>panelTitle.inactiveForeground</code>: 非活动面板的标题颜色</li>
</ul>
<h2 id="状态栏色彩"><a class="header" href="#状态栏色彩">状态栏色彩</a></h2>
<hr />
<p>状态栏显示在工作区底部</p>
<ul>
<li><code>statusBar.background</code>: 普通状态下，状态栏的背景色</li>
<li><code>statusBar.foreground</code>: 普通状态下，状态栏的前景色</li>
<li><code>statusBar.border</code>: 状态栏和编辑器间的分隔线颜色</li>
<li><code>statusBar.debuggingBackground</code>: 调试程序时状态栏的背景色</li>
<li><code>statusBar.debuggingForeground</code>: 调试程序时状态栏的前景色</li>
<li><code>statusBar.debuggingBorder</code>: 调试程序时，状态栏和编辑器的分隔线颜色</li>
<li><code>statusBar.noFolderForeground</code>: 没有打开文件夹时状态栏的前景色</li>
<li><code>statusBar.noFolderBackground</code>: 没有打开文件夹时状态栏的背景色</li>
<li><code>statusBar.noFolderBorder</code>: 没有打开文件夹时，状态栏和编辑器间的分隔线颜色</li>
<li><code>statusBarItem.activeBackground</code>: 单击时的状态栏项背景色</li>
<li><code>statusBarItem.hoverBackground</code>: 悬停时状态栏项背景色</li>
<li><code>statusBarItem.prominentBackground</code>: 状态栏突出显示项的背景颜色，突出显示项比状态栏中的其他条目更醒目以表明其重要性，在命令面板中更改<code>切换 Tab 键是否移动焦点</code>可查看示例</li>
<li><code>statusBarItem.prominentHoverBackground</code>: 鼠标悬停过程中状态栏突出显示项的背景颜色，突出显示项比状态栏中的其他条目更醒目以表明其重要性。在命令面板中更改<code>切换 Tab 键是否移动焦点</code>可查看示例</li>
</ul>
<h2 id="标题栏色彩"><a class="header" href="#标题栏色彩">标题栏色彩</a></h2>
<hr />
<ul>
<li><code>titleBar.activeBackground</code>: 窗口处于活动状态时的标题栏背景色</li>
<li><code>titleBar.activeForeground</code>: 窗口处于活动状态时的标题栏前景色</li>
<li><code>titleBar.inactiveBackground</code>: 窗口处于非活动状态时的标题栏背景色</li>
<li><code>titleBar.inactiveForeground</code>: 窗口处于非活动状态时的标题栏前景色</li>
<li><code>titleBar.border</code>: 标题栏边框颜色</li>
</ul>
<h2 id="菜单栏色彩"><a class="header" href="#菜单栏色彩">菜单栏色彩</a></h2>
<hr />
<ul>
<li><code>menubar.selectionForeground</code>: 菜单栏中选定菜单项的前景色</li>
<li><code>menubar.selectionBackground</code>: 菜单栏中选定菜单项的背景色</li>
<li><code>menubar.selectionBorder</code>: 菜单栏中所选菜单项的边框颜色</li>
<li><code>menu.foreground</code>: 菜单项的前景颜色</li>
<li><code>menu.background</code>: 菜单项的背景颜色</li>
<li><code>menu.selectionForeground</code>: 菜单中选定菜单项的前景色</li>
<li><code>menu.selectionBackground</code>: 菜单中所选菜单项的背景色</li>
<li><code>menu.selectionBorder</code>: 菜单中所选菜单项的边框颜色</li>
<li><code>menu.separatorBackground</code>: 菜单中分隔线的颜色</li>
</ul>
<h2 id="通知框色彩"><a class="header" href="#通知框色彩">通知框色彩</a></h2>
<hr />
<p>!&gt; <strong>注意</strong>: 下列的色彩只适用于VS Code-1.21或更高版本</p>
<p>通知横幅从窗口右下角弹出</p>
<p><img src="https://media.githubusercontent.com/media/Microsoft/vscode-docs/master/api/references/images/theme-color/notification-toast.png" alt="通知横幅" /></p>
<p>通知中心以带标题的列表显示</p>
<p><img src="https://media.githubusercontent.com/media/Microsoft/vscode-docs/master/api/references/images/theme-color/notification-center.png" alt="通知中心" /></p>
<ul>
<li><code>notificationCenter.border</code>: 通知中心的边框颜色</li>
<li><code>notificationCenterHeader.foreground</code>: 通知中心头部的前景色</li>
<li><code>notificationCenterHeader.background</code>: 通知中心头部的背景色</li>
<li><code>notificationToast.border</code>: 通知横幅的边框颜色</li>
<li><code>notifications.foreground</code>: 通知的前景色</li>
<li><code>notifications.background</code>: 通知的背景色</li>
<li><code>notifications.border</code>: 通知中心中分隔通知的边框的颜色</li>
<li><code>notificationLink.foreground</code>: 通知链接的前景色</li>
</ul>
<p>如果你使用的VS Code版本低于1.21(2018-2)，可以使用旧的色彩(不再支持):</p>
<ul>
<li><code>notification.background</code></li>
<li><code>notification.foreground</code></li>
<li><code>notification.buttonBackground</code></li>
<li><code>notification.buttonForeground</code></li>
<li><code>notification.buttonHoverBackground</code></li>
<li><code>notification.errorBackground</code></li>
<li><code>notification.errorForeground</code></li>
<li><code>notification.infoBackground</code></li>
<li><code>notification.infoForeground</code></li>
<li><code>notification.warningBackground</code></li>
<li><code>notification.warningForeground</code></li>
</ul>
<h2 id="插件栏"><a class="header" href="#插件栏">插件栏</a></h2>
<hr />
<ul>
<li><code>extensionButton.prominentForeground</code>: 扩展中突出操作的按钮前景色(比如 <strong>安装</strong>按钮)</li>
<li><code>extensionButton.prominentBackground</code>: 扩展中突出操作的按钮背景色</li>
<li><code>extensionButton.prominentHoverBackground</code>: 鼠标悬停时插件中突出操作的按钮的颜色</li>
</ul>
<h2 id="快速选取器"><a class="header" href="#快速选取器">快速选取器</a></h2>
<hr />
<ul>
<li><code>pickerGroup.border</code>: 快速选取(快速打开)器分组边框的颜色</li>
<li><code>pickerGroup.foreground</code>: 快速选取(快速打开)器分组标签的颜色</li>
</ul>
<h2 id="集成终端色彩"><a class="header" href="#集成终端色彩">集成终端色彩</a></h2>
<hr />
<ul>
<li><code>terminal.background</code>: 终端视口的背景颜色</li>
<li><code>terminal.border</code>: 分隔终端中拆分窗格的边框的颜色。默认为 panel.border 的颜色</li>
<li><code>terminal.foreground</code>: 集成终端的默认前景色</li>
<li><code>terminal.ansiBlack</code>: 终端中的'Black'ANSI</li>
<li><code>terminal.ansiBlue</code>: 终端中的'Blue'ANSI</li>
<li><code>terminal.ansiBrightBlack</code>: 终端中的'BrightBlack'ANSI</li>
<li><code>terminal.ansiBrightBlue</code>: 终端中的'BrightBlue'ANSI</li>
<li><code>terminal.ansiBrightCyan</code>: 终端中的'BrightCyan'ANSI</li>
<li><code>terminal.ansiBrightGreen</code>: 终端中的'BrightGreen'ANSI</li>
<li><code>terminal.ansiBrightMagenta</code>: 终端中的'BrightMagenta'ANSI</li>
<li><code>terminal.ansiBrightRed</code>: 终端中的'BrightRed'ANSI</li>
<li><code>terminal.ansiBrightWhite</code>: 终端中的'BrightWhite'ANSI</li>
<li><code>terminal.ansiBrightYellow</code>: 终端中的'BrightYellow'ANSI</li>
<li><code>terminal.ansiCyan</code>: 终端中的'Cyan'ANSI</li>
<li><code>terminal.ansiGreen</code>: 终端中的'Green'ANSI</li>
<li><code>terminal.ansiMagenta</code>: 终端中的'Magenta'ANSI</li>
<li><code>terminal.ansiRed</code>: 终端中的'Red'ANSI</li>
<li><code>terminal.ansiWhite</code>: 终端中的'White'ANSI</li>
<li><code>terminal.ansiYellow</code>: 终端中的'Yellow'ANSI</li>
<li><code>terminal.selectionBackground</code>: 终端中选中内容的背景色</li>
<li><code>terminalCursor.background</code>: 终端光标的背景色。允许自定义被 block 光标遮住的字符的颜色</li>
<li><code>terminalCursor.foreground</code>: 终端光标的前景色</li>
</ul>
<h2 id="调试-1"><a class="header" href="#调试-1">调试</a></h2>
<hr />
<ul>
<li><code>debugToolBar.background</code>: 调试工具栏背景颜色</li>
<li><code>debugToolBar.border</code>: 调试工具栏边框颜色</li>
<li><code>editor.stackFrameHighlightBackground</code>: 堆栈帧中顶部一行的高亮背景色</li>
<li><code>editor.focusedStackFrameHighlightBackground</code>: 堆栈帧中焦点一行的高亮背景色</li>
</ul>
<h2 id="欢迎界面"><a class="header" href="#欢迎界面">欢迎界面</a></h2>
<hr />
<ul>
<li><code>welcomePage.background</code>: 欢迎页面的背景色</li>
<li><code>welcomePage.buttonBackground</code>: 欢迎页按钮的背景色</li>
<li><code>welcomePage.buttonHoverBackground</code>: 鼠标悬停时欢迎页按钮的背景色</li>
<li><code>walkThrough.embeddedEditorBackground</code>: 嵌入于交互式操场中的编辑器的背景颜色</li>
</ul>
<h2 id="git色彩"><a class="header" href="#git色彩">Git色彩</a></h2>
<hr />
<ul>
<li><code>gitDecoration.addedResourceForeground</code>: 新增的Git资源的前景色。用于显示文件标签和源代码管理</li>
<li><code>gitDecoration.modifiedResourceForeground</code>: 修改过的Git资源的前景色。用于显示文件标签和源代码管理</li>
<li><code>gitDecoration.deletedResourceForeground</code>: 移除过的Git资源的前景色。用于显示文件标签和源代码管理</li>
<li><code>gitDecoration.untrackedResourceForeground</code>: 未跟踪的Git资源的前景色。用于文件标签和源代码管理</li>
<li><code>gitDecoration.ignoredResourceForeground</code>: 已忽视的Git资源的前景色。用于文件标签和源代码管理</li>
<li><code>gitDecoration.conflictingResourceForeground</code>: 冲突的Git资源的前景色。用于文件标签和源代码管理</li>
<li><code>gitDecoration.submoduleResourceForeground</code>: 子模块资源的前景色</li>
</ul>
<h2 id="设置编辑器色彩"><a class="header" href="#设置编辑器色彩">设置编辑器色彩</a></h2>
<hr />
<p>!&gt; <strong>注意</strong>: 下列色彩配置只适用于<strong>设置</strong>编辑器界面，可以通过<code>首选项: 打开设置(UI)</code>命令打开。</p>
<ul>
<li><code>settings.headerForeground</code>: 小节标题与活动标题的前景色</li>
<li><code>settings.modifiedItemIndicator</code>: 已修改设置指示器的颜色</li>
<li><code>settings.dropdownBackground</code>: 下拉列表的背景色</li>
<li><code>settings.dropdownForeground</code>: 下拉列表的前景色</li>
<li><code>settings.dropdownBorder</code>: 下拉列表的边框颜色</li>
<li><code>settings.dropdownListBorder</code>: 下拉列表选项的边框颜色</li>
<li><code>settings.checkboxBackground</code>: 复选框的背景色</li>
<li><code>settings.checkboxForeground</code>: 复选框的前景色</li>
<li><code>settings.checkboxBorder</code>: 复选框的边框颜色</li>
<li><code>settings.textInputBackground</code>: 文本输入框的背景色</li>
<li><code>settings.textInputForeground</code>: 文本输入框的前景色</li>
<li><code>settings.textInputBorder</code>: 文本输入框的边框颜色</li>
<li><code>settings.numberInputBackground</code>: 数字输入框的背景色</li>
<li><code>settings.numberInputForeground</code>: 数字输入框的前景色</li>
<li><code>settings.numberInputBorder</code>: 数字输入框的边框颜色</li>
</ul>
<h2 id="面包屑导航"><a class="header" href="#面包屑导航">面包屑导航</a></h2>
<hr />
<p>面包屑导航的色彩主题:</p>
<ul>
<li><code>breadcrumb.foreground</code>: 导航路径的前景色</li>
<li><code>breadcrumb.background</code>: 导航路径项的背景色</li>
<li><code>breadcrumb.focusForeground</code>: 焦点导航路径的颜色</li>
<li><code>breadcrumb.activeSelectionForeground</code>: 已选导航路径项的颜色</li>
<li><code>breadcrumbPicker.background</code>: 导航路径项选择器的背景色</li>
</ul>
<h2 id="代码片段-1"><a class="header" href="#代码片段-1">代码片段</a></h2>
<hr />
<p>代码片段的色彩主题:</p>
<ul>
<li><code>editor.snippetTabstopHighlightBackground</code>: 代码片段 Tab 位的高亮背景色</li>
<li><code>editor.snippetTabstopHighlightBorder</code>: 代码片段 Tab 位的高亮边框颜色</li>
<li><code>editor.snippetFinalTabstopHighlightBackground</code>: 代码片段中最后的 Tab 位的高亮背景色</li>
<li><code>editor.snippetFinalTabstopHighlightBorder</code>: 代码片段中最后的 Tab 位的高亮边框颜色</li>
</ul>
<p>也可以根据<a href="references//references/contribution-points#contributescolors">发布内容的颜色配置项</a>，使用插件来发布色彩id(Ids)。当在<code>workbench.colorCustomizations</code>配置项中使用代码补全或者编辑色彩主题文件时，这些色彩也会出现。用户可以在<a href="https://code.visualstudio.com/docs/editor/extension-gallery#_extension-details">插件发布</a>选项卡中看到插件定义的色彩。</p>
<h2 id="配置插件中的色彩"><a class="header" href="#配置插件中的色彩">配置插件中的色彩</a></h2>
<hr />
<p>也可以根据[发布内容的颜色配置项]((/references/contribution-points#contributescolors)，使用插件来发布色彩id。当在<code>workbench.colorCustomizations</code>当编辑<code>workbench.colorCustomizations</code>和主题颜色文件时，这些色彩会出现在代码补全中。用户可以在<a href="https://code.visualstudio.com/docs/editor/extension-gallery#_extension-details">插件发布</a>选项卡中看到插件定义的色彩。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="标签中的图标"><a class="header" href="#标签中的图标">标签中的图标</a></h1>
<p>你可以在插件中使用github提供的开源图标<a href="https://octicons.github.com/">Octicons</a>，你甚至可以在<a href="https://code.visualstudio.com/api/references/vscode-api#StatusBarItem"><code>StatusBarItem</code></a>文本和<a href="https://code.visualstudio.com/api/references/vscode-api#QuickPickItem"><code>QuickPickItem</code></a>标签中使用。添加图标的语法如下：</p>
<pre><code class="language-typescript">$(alert);
</code></pre>
<p>你还可以像这样使用多个标签</p>
<pre><code class="language-typescript">$(eye) $(heart) $(mark-github) GitHub
</code></pre>
<h4 id="图标列表"><a class="header" href="#图标列表">图标列表</a></h4>
<p><strong>图标列表</strong>请参考<a href="https://code.visualstudio.com/api/references/icons-in-labels">官方文档</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="文档选择器"><a class="header" href="#文档选择器">文档选择器</a></h1>
<p>插件的特性可以通过语言、类型、位置等文档选择器类型加以筛选，本节将深入文档选择器、文档协议等插件创作者应该了解的内容。</p>
<h2 id="不在磁盘上的文件"><a class="header" href="#不在磁盘上的文件">不在磁盘上的文件</a></h2>
<hr />
<p>并不是所有文件都是储存在磁盘上的，比如一份刚刚创建的文件。除非特别指明，文档选择器通常会应用于<strong>所有</strong>文档类型。使用<a href="https://code.visualstudio.com/api/references/vscode-api#DocumentFilter">DocumentFilter</a>的<code>scheme</code>属性将协议范围缩小，比如说，<code>{ scheme: 'file', language: 'typescript' }</code>是特定的用于储存在磁盘上的TypeScript文件。</p>
<h2 id="文档选择器-1"><a class="header" href="#文档选择器-1">文档选择器</a></h2>
<hr />
<p>VS Code插件API结合了特定的语言特性, 通过文档选择器的<a href="https://code.visualstudio.com/api/references/vscode-api#DocumentSelector">DocumentSelector</a>类型, 可以支持例如智能感知(IntelliSense)等特性. 这是实现特定语言所支持特性的最为简单的机制.</p>
<p>下面的片段注册了一个Typescript文件的<a href="https://code.visualstudio.com/api/references/vscode-api#HoverProvider">HoverProvider</a>, 此时的文档选择器是<code>typescript</code>语言标识符.</p>
<pre><code class="language-typescript">vscode.languages.registerHoverProvider('typescript', {
  provideHover(doc: vscode.TextDocument) {
    return new vscode.Hover('For *all* TypeScript documents.');
  }
});
</code></pre>
<p>文档选择器可以不只是一个语言标识符, 还可以是复杂选择器——比如基于<code>协议(scheme)</code>和文件路径的<a href="https://code.visualstudio.com/api/references/vscode-api#DocumentFilter">DocumentFilter</a>, 文件路径支持<code>pattern</code>参数和glob模式:</p>
<pre><code class="language-typescript">vscode.languages.registerHoverProvider(
  { pattern: '**/test/**' },
  {
    provideHover(doc: vscode.TextDocument) {
      return new vscode.Hover('For documents inside `test`-folders only');
    }
  }
);
</code></pre>
<p>下面这个片段, 使用合并后的<code>协议(scheme)</code>过滤器和语言标识符作为参数. <code>未命名的(untitled)</code>协议正是为暂未保存到本地磁盘的文件准备的.</p>
<pre><code class="language-typescript">vscode.languages.registerHoverProvider(
  { scheme: 'untitled', language: 'typescript' },
  {
    provideHover(doc: vscode.TextDocument) {
      return new vscode.Hover('For new, unsaved TypeScript documents only');
    }
  }
);
</code></pre>
<h2 id="文档协议"><a class="header" href="#文档协议">文档协议</a></h2>
<hr />
<p><code>文档协议</code>经常会被忽视, 但是它提供了很重要的信息. 插件开发者经常假设自己正在处理的文档也是存在磁盘上的. 用一个简单的<code>typescript</code>选择器做个例子, 假设<strong>Typescript文件在磁盘上</strong>, 不过大部分开发场景都过于宽松了，使用了诸如<code>{ scheme: 'file', language: 'typescript' }</code>显式的选择器。</p>
<p>当某项功能依赖于从磁盘上读/写文件时, 这个问题显得尤为重要. 请看下面的代码:</p>
<pre><code class="language-typescript">// 👎 too lax
vscode.languages.registerHoverProvider('typescript', {
  provideHover(doc: vscode.TextDocument) {
    const { size } = fs.statSync(doc.uri.fsPath); // ⚠️ what about 'untitled:/Untitled1.ts' or others?
    return new vscode.Hover(`Size in bytes is ${size}`);
  }
});
</code></pre>
<p>上面的例子中, 悬浮提示器想展示文件占用的磁盘大小, 但是它不会检查文档是不是真的存储在磁盘上. 比如, 一个新创建但是未保存的文件. 正确的做法是告诉VS Code只在文件存储在磁盘上时才开始工作.</p>
<pre><code class="language-typescript">// 👍 only works with files on disk
vscode.languages.registerHoverProvider(
  { scheme: 'file', language: 'typescript' },
  {
    provideHover(doc: vscode.TextDocument) {
      const { size } = fs.statSync(doc.uri.fsPath);
      return new vscode.Hover(`Size in bytes is ${size}`);
    }
  }
);
</code></pre>
<h2 id="总结-1"><a class="header" href="#总结-1">总结</a></h2>
<hr />
<p>文档通常都储存在文件系统中，但也有例外：未保存的新文件、Git使用的缓存文件、FTP上的远程文件等等。如果你的插件特性依赖于磁盘读取，那么你就要用文档选择器时应带上file协议。</p>
<h2 id="下一步-11"><a class="header" href="#下一步-11">下一步</a></h2>
<p>阅读下列文章来了解更多有关于VS Code可拓展模型的知识.</p>
<ul>
<li><a href="references//references/extension-manifest">插件清单</a> - VS Code的package.json(插件清单)文件配置相关</li>
<li><a href="references//references/contribution-points">发布内容配置</a> - VS Code发布内容相关</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="插件开发准则"><a class="header" href="#插件开发准则">插件开发准则</a></h1>
<h2 id="架构"><a class="header" href="#架构">架构</a></h2>
<p>VS Code UI 包含了两类元素：容器和容器项。容器是指视图的顶层层级，它包括：</p>
<p><img src="https://code.visualstudio.com/assets/api/references/guidelines/architecture-groups.png" alt="Overview of Visual Studio Code containers elements" /></p>
<ol>
<li>活动栏(<a href="references//references/extension-guidelines#%E8%A7%86%E5%9B%BE%E5%AE%B9%E5%99%A8">Activiti Bar</a>)</li>
<li>侧边栏(Sidebar)</li>
<li>编辑器(Editor)</li>
<li>面板(Panel)</li>
<li>状态栏(Status Bar)</li>
</ol>
<p>容器项则在容器的内部，他们的种类就很丰富了：</p>
<p><img src="https://code.visualstudio.com/assets/api/references/guidelines/architecture-sections.png" alt="Overview of Visual Studio Code item elements" /></p>
<ol>
<li>视图容器(View Container)</li>
<li>视图(<a href="references//references/extension-guidelines#%E8%A7%86%E5%9B%BE">View</a>)</li>
<li>视图工具区(View Toolbar)</li>
<li>侧边栏工具区(Sidebar Toolbar)</li>
<li>编辑器工具区(Editor Toolbar)</li>
<li>面板工具区(Pannel Toolbar)</li>
<li>状态栏项(<a href="references//references/extension-guidelines#%E7%8A%B6%E6%80%81%E6%A0%8F">Status Bar Item</a>)</li>
</ol>
<h2 id="通知框"><a class="header" href="#通知框">通知框</a></h2>
<p><a href="references//extension-capabilities/common-capabilities#display-notifications">通知框</a> 会从 VS Code 右下角弹出，它可以展示一些简要的信息。你能够设置的通知类型有三种：</p>
<ul>
<li><a href="https://code.visualstudio.com/api/references/vscode-api#window.showInformationMessage">信息提示</a></li>
<li><a href="https://code.visualstudio.com/api/references/vscode-api#window.showWarningMessage">警告提示</a></li>
<li><a href="https://code.visualstudio.com/api/references/vscode-api#window.showErrorMessage">错误提示</a></li>
</ul>
<p>不要过多地发送通知，以免分散用户的注意力。</p>
<p><img src="https://code.visualstudio.com/assets/api/references/guidelines/notification-info.png" alt="Information notification" /></p>
<p><em>这条通知是用户<strong>更新版本</strong>后弹出的，注意这个通知中仅仅展示了信息不含任何操作。</em></p>
<p><img src="https://code.visualstudio.com/assets/api/references/guidelines/notification-warning.png" alt="Warning notification" /></p>
<p><em>这个例子中带有一个黄色的高亮警告，附带 3 个按钮——它要求用户进行介入处理。</em></p>
<p><img src="https://code.visualstudio.com/assets/api/references/guidelines/notification-error.png" alt="Error notification" /></p>
<p><em>这个例子是无操作的错误通知。</em></p>
<p>✔建议</p>
<ul>
<li>发送通知的时候不要过分吸引用户的注意力</li>
<li>为每个通知添加 <strong>不要再提示</strong> 按钮</li>
<li>短时间内只提示一次</li>
</ul>
<p>❌  不要</p>
<ul>
<li>发送重复通知</li>
<li>用于促销广告</li>
<li>插件首次安装后用户收集用户反馈</li>
<li>没有必要的操作还硬加按钮</li>
</ul>
<h3 id="进度通知"><a class="header" href="#进度通知">进度通知</a></h3>
<p>当你需要展示一个不知何时才能完成的任务进度时（比如：初始化环境），你可以使用进度通知。这种类型的通知应该作为当前上下文（在视图或者编辑器内）处理进度通知类型的最后手段。</p>
<p>✔建议</p>
<ul>
<li>提供一个查看详情的链接（比如进度日志）</li>
<li>处理过程中给出信息（比如：初始化、构建，等等）</li>
<li>提供取消操作（如果可用的话）</li>
<li>如果有超时场景，提供倒计时</li>
</ul>
<p>❌  不要</p>
<ul>
<li>不销毁进度通知</li>
</ul>
<p><img src="https://code.visualstudio.com/assets/api/references/guidelines/notification-progress.png" alt="Progress notification" /></p>
<p><em>这个例子演示了远程连接初始化时的进度通知，它同时也提供了输出日志（details）</em></p>
<h2 id="视图"><a class="header" href="#视图">视图</a></h2>
<p><a href="references//references/contribution-points#contributesviews">视图</a>是内容的容器，它们会出现在注入侧边栏或者面板这样的地方。视图可以包含树视图或者自定义视图，这些视图可以包含视图操作。视图可被用户调整位置，比如放到其他视图、活动栏和面板中。请控制你的视图数量以便其他插件的视图还有空间展示。</p>
<p>✔建议</p>
<ul>
<li>如果可以的话，使用现有的图标</li>
<li>为语言文件使用文件图标</li>
<li>用树视图展示数据</li>
<li>为每个视图提供活动栏图标</li>
<li>控制视图数量最小化</li>
<li>控制名称长度最小化</li>
<li>克制地使用自定义 webview 视图</li>
</ul>
<p>❌  不要</p>
<ul>
<li>对已有功能重新造轮子</li>
<li>使用树视图项作为唯一的操作入口（如，搜索栏）</li>
<li>非必要的情况下也使用自定义 webview</li>
<li>在编辑器中使用视图容器装载 webview</li>
</ul>
<p><img src="https://code.visualstudio.com/assets/api/references/guidelines/views-example.png" alt="Views example" /></p>
<p><em>这个例子使用了树视图展示一组测试的测试状态。每种测试结果都有其唯一图标类型与之对应。</em></p>
<h3 id="视图位置"><a class="header" href="#视图位置">视图位置</a></h3>
<p>视图可被放在<a href="references//references/contribution-points#contributesviews">现有的视图容器</a>中，比如文件管理器、源管理器(SCM)和调试视图容器中。你也可以在活动栏中添加自定义视图容器，然后再往里添加视图。另外，视图可被添加到任何面板或者他们自己所属的自定义视图容器中。</p>
<p><img src="https://code.visualstudio.com/assets/api/references/guidelines/views-locations.png" alt="View locations" /></p>
<h3 id="视图容器-2"><a class="header" href="#视图容器-2">视图容器</a></h3>
<p><a href="references//references/contribution-points#contributesviewsContainers">视图容器</a>是活动栏的一部分，每个容器都有其独有的图标。</p>
<p><img src="https://code.visualstudio.com/assets/api/references/guidelines/view-container.png" alt="View Container" /></p>
<p>这个例子用了一个边框图标来展示自定义视图容器。</p>
<h3 id="视图中的进度条"><a class="header" href="#视图中的进度条">视图中的进度条</a></h3>
<p>如果你的视图在 源(SCM)视图容器中，你也可以<a href="https://code.visualstudio.com/api/references/vscode-api#ProgressLocation">显示进度条</a></p>
<h3 id="欢迎视图"><a class="header" href="#欢迎视图">欢迎视图</a></h3>
<p>当视图没有任何内容时，你可以<a href="references//references/contribution-points#contributesviewsWelcome">添加一些内容来引导用户</a>如何使用你的插件。欢迎视图支持链接和图标。</p>
<p>✔建议</p>
<ul>
<li>仅在必要时使用欢迎视图</li>
<li>如有需要可使用链接而不是按钮</li>
<li>按钮仅用于基础性的操作</li>
<li>描述清楚链接指向</li>
<li>控制内容的长度</li>
<li>控制欢迎视图的数量</li>
<li>控制视图中的按钮数量</li>
</ul>
<p>❌  不要</p>
<ul>
<li>非必要的场景中也使用按钮</li>
<li>将欢迎视图当成销售页面</li>
<li>每个链接的标题都叫&quot;查看更多&quot;</li>
</ul>
<p><img src="https://code.visualstudio.com/assets/api/references/guidelines/welcome-views.png" alt="Welcome Views" /></p>
<p>这个例子使用了一个基础按钮，其他视图则包含了期待用户知晓的具体文档链接。</p>
<h2 id="webviews"><a class="header" href="#webviews">Webviews</a></h2>
<p>如果你需要展示的自定义功能超出了VS Code API 的能力，那么你可以使用完全可定制的 <a href="references//extension-guides/webview">webview</a>。再次提示开发者：仅在必要时使用 webview。</p>
<p>✔建议</p>
<ul>
<li>仅在绝对必要时使用 webview</li>
<li>在合适的场景中启动你的插件</li>
<li>为激活窗口打开 webview</li>
<li>确保视图中的所有元素都是可定制主题的（查看 <a href="https://github.com/microsoft/vscode-extension-samples/blob/main/webview-view-sample/media/main.css">webview-view-sample</a>和<a href="references//references/theme-color">color tokens</a>文档）</li>
<li>确保你的视图遵循<a href="https://code.visualstudio.com/docs/editor/accessibility">可访问性指南</a>(色彩对比度、ARIA 标签、键盘导航)</li>
<li>在视图的工具区使用命令操作</li>
</ul>
<p>❌  不要</p>
<ul>
<li>用于广告宣传（包括升级、捐助等等）</li>
<li>作为插件的向导页面</li>
<li>在所有窗口中打开</li>
<li>插件升级后打开（请使用通知）</li>
<li>添加和编辑器或者工作区无关的功能</li>
<li>重复发明轮子（比如：欢迎页、设置、配置等等）</li>
</ul>
<h3 id="例子-1"><a class="header" href="#例子-1">例子</a></h3>
<p><strong>浏览器预览</strong>
这个插件在编辑器旁边打开了一个浏览器效果预览
<img src="https://code.visualstudio.com/assets/api/references/guidelines/webview-browser.png" alt="Weview Sample - Browser" /></p>
<p><strong>Pull Request</strong>
这个插件为自定义树视图中的工作区仓库展示了一个 Pull Request 页面，它用 webview 显示了 PR 的详细信息。</p>
<p><strong>初次使用培训</strong>
这个插件打开了一个快速启动页面，它包含了有用的操作、链接和更多信息。这个 Webview 仅仅在用户首次打开特定文件时展示，帮助用户检查是否遵循了特定步骤（比如安装或创建一个文件时）。</p>
<p><img src="https://code.visualstudio.com/assets/api/references/guidelines/webview-onboarding.png" alt="Webview Sample - Onboarding" /></p>
<h3 id="webview-视图"><a class="header" href="#webview-视图">webview 视图</a></h3>
<p>你可以在任意视图容器（侧边栏和面板）中添加 webview，这样的 webview 被称为 <a href="https://code.visualstudio.com/api/references/vscode-api#WebviewView">webview 视图</a>。它的使用方式和常规的 webview 是一样的。</p>
<p><img src="https://code.visualstudio.com/assets/api/references/guidelines/webview-view.png" alt="Webview View" /></p>
<p>这个 webview 视图内容展示了创建一个 PR 所需的下拉菜单、输入框和按钮。</p>
<h2 id="状态栏"><a class="header" href="#状态栏">状态栏</a></h2>
<p><a href="references//extension-capabilities/extending-workbench#%E7%8A%B6%E6%80%81%E6%A0%8F%E9%A1%B9">状态栏</a>位于 VS Code 工作台底部，用于展示和你的工作区相关的信息和操作。状态栏项分为两类：基础的（左）和次级的（右）。状态栏中和整个工作区（状态、问题/警告、同步状态）相关的位于左边，次级状态或者上下文相关的（语言、间距、反馈）处于右边。注意控制添加的状态栏项目数，为其他插件腾出空间。</p>
<p>✔建议</p>
<ul>
<li>使用短的文本标签</li>
<li>仅在必要时使用图标</li>
<li>使用语义清晰的图标</li>
<li>把首要（全局）项目放在左边</li>
<li>把次要（上下文）项目放在右边</li>
</ul>
<p>❌  不要</p>
<ul>
<li>添加自定义颜色</li>
<li>添加的图标数量在 1 个以上（除非必要）</li>
<li>添加的状态栏项数量在 1 个以上（除非必要）</li>
</ul>
<p><img src="https://code.visualstudio.com/assets/api/references/guidelines/statusbar-item.png" alt="Status Bar Item" /></p>
<p><em>这个例子中，状态栏项的信息和整个工作区相关，所以展示在左边</em></p>
<h3 id="进度状态栏项目"><a class="header" href="#进度状态栏项目">进度状态栏项目</a></h3>
<p>当需要展示静默进度（进度在后台处理）时，建议用带有加载图标（你可以添加旋转动画）的状态栏项来展示。如果进度状态是需要用户注意到的，我们建议你将其提升到通知维度。</p>
<p><img src="https://code.visualstudio.com/assets/api/references/guidelines/status-bar-progress.png" alt="Status Bar Progress" /></p>
<p><em>这个例子中，状态栏展示静默进度</em></p>
<h3 id="错误状态栏项"><a class="header" href="#错误状态栏项">错误状态栏项</a></h3>
<p>如果你需要展示的项目出于警示目的需要高亮，你可以使用错误状态栏项。请将错误状态栏项作为特殊场景下的最后手段。
<img src="https://code.visualstudio.com/assets/api/references/guidelines/status-bar-error.png" alt="Status Bar Error" /></p>
<p><em>这个例子中，错误状态栏项展示了文件中的代码错误</em></p>
<h2 id="快速选择-1"><a class="header" href="#快速选择-1">快速选择</a></h2>
<p><a href="references//extension-capabilities/common-capabilities#quick-pick">快速选择</a>是一个展示操作和接受用户输入的简易手段。在选择配置、过滤内容或者从列表中挑选项目时尤为有用。
<img src="https://code.visualstudio.com/assets/api/references/guidelines/quickpick.png" alt="Quick Pick" /></p>
<p><em>快速选择可以包含非常多的选项。而且选项可以由图标、详情和标签组成，而且还包括默认项。在这个例子的顶部，你可以看到多步骤模式下的后退、恢复和前进等操作。</em></p>
<p>✔建议</p>
<ul>
<li>使用语义清晰的图标</li>
<li>使用具体的描述展示当前项（如果需要的话）</li>
<li>使用详情提供额外（简短）的说明</li>
<li>在需要多选输入的场景中使用多步骤模式（比如：初始化向导）</li>
<li>提供一个创建更多的选项（如果需要的话）</li>
</ul>
<p>❌  不要</p>
<ul>
<li>重复造轮子</li>
<li>多种选项公用一个图标</li>
<li>列表中超过 6 种图标</li>
</ul>
<h2 id="编辑器操作"><a class="header" href="#编辑器操作">编辑器操作</a></h2>
<p>编辑器的工具区会展示<a href="references//references/contribution-points#contributescommands">编辑器操作</a>。你可以添加图标作为快速操作，或者在悬浮菜单中添加菜单项（...）。</p>
<p>✔建议</p>
<ul>
<li>在特定上下文场景中展示操作</li>
<li>尽量使用内置图标库中的图标</li>
<li>悬浮菜单中的项目应作为二级操作</li>
</ul>
<p>❌  不要</p>
<ul>
<li>添加多类图标</li>
<li>添加自定义颜色</li>
<li>使用 emoji</li>
</ul>
<p><img src="https://code.visualstudio.com/assets/api/references/guidelines/editor-actions.png" alt="Editor Actions" /></p>
<p><em>仅在 HTML 页面中展示这个图标来表示加载页面预览</em></p>
<h2 id="上下文菜单"><a class="header" href="#上下文菜单">上下文菜单</a></h2>
<p><a href="references//references/contribution-points#contributesmenus">菜单项</a>会展示在视图、操作、右击菜单中。要额外注意菜单组中的菜单项要保持其一致性。如果你的插件操作和文件相关，请将操作配置到文件管理器菜单中（适时）。如果插件是针对特定文件类型的，请仅仅在此类场景中展示操作。</p>
<p>✔建议</p>
<ul>
<li>当场景合适时才展示操作</li>
<li>相似操作分组</li>
<li>一个组中的操作过多时，使用子菜单</li>
</ul>
<p>❌  不要</p>
<ul>
<li>在所有场景中都展示操作</li>
</ul>
<p><img src="https://code.visualstudio.com/assets/api/references/guidelines/context-menu.png" alt="Context Menu" /></p>
<p><em>将 <strong>Copy Github Link</strong> 和其他复制命令放在一起。这个操作只会在 GitHub 仓库项目中可用</em></p>
<h2 id="设置"><a class="header" href="#设置">设置</a></h2>
<p><a href="references//references/contribution-points#contributesconfiguration">设置</a>是用户配置插件的入口。设置可以是输入框、布尔值、下拉菜单、列表、键值对。如果你的插件要求用户配置特定设置，你可以打开设置 UI 然后用设置 ID 查询你的插件设置。</p>
<p>✔建议</p>
<ul>
<li>为每项设置添加默认值</li>
<li>为每项设置添加清晰的描述</li>
<li>为复杂设置添加文档链接</li>
<li>为相关设置添加链接</li>
<li>当用户需要配置特定设置项时，提供设置 ID 链接</li>
</ul>
<p>❌  不要</p>
<ul>
<li>创建你自己的设置页面/webview</li>
<li>使用超长的描述</li>
</ul>
<p><img src="https://code.visualstudio.com/assets/api/references/guidelines/settings.png" alt="Settings" /></p>
<p><em>使用设置 ID 链接到特定设置项上</em></p>
<h2 id="命令面板"><a class="header" href="#命令面板">命令面板</a></h2>
<p><a href="references//references/contribution-points#contributescommands">命令面板</a>可以找到所有命令。注意：为你的命令使用清晰的名称和标签，便于用户查找。</p>
<p>✔建议</p>
<ul>
<li>必要时添加快捷键</li>
<li>为命令添加清晰的名字</li>
<li>为同类命令分组</li>
</ul>
<p>❌  不要</p>
<ul>
<li>重写已有的快捷键</li>
<li>命名命令时使用 emoji</li>
</ul>
<p><img src="https://code.visualstudio.com/assets/api/references/guidelines/command-palette.png" alt="Command Palette" /></p>
<p><em>命令被分组到 &quot;Debug&quot; 类目中， 而且每个命令都有清晰的名字，少部分命令有其快捷键</em></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
